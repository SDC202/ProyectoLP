Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    BEGIN
    CASE
    DIVIDE_ASSIGN
    DO
    ENSURE
    MINUS_ASSIGN
    MODULE
    MOD_ASSIGN
    PLUS_ASSIGN
    POWER_ASSIGN
    RESCUE
    RETRY
    SCOPE
    SELF
    SUPER
    THEN
    TIMES_ASSIGN
    UNLESS
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     enter_scope -> empty
Rule 3     enter_loop_scope -> empty
Rule 4     exit_scope -> empty
Rule 5     program -> optional_newlines statements optional_newlines
Rule 6     statements -> statements statement_separator statement
Rule 7     statements -> statement
Rule 8     statements -> empty
Rule 9     statement_separator -> NEWLINE
Rule 10    statement_separator -> SEMICOLON
Rule 11    statement_separator -> statement_separator NEWLINE
Rule 12    statement_separator -> statement_separator SEMICOLON
Rule 13    optional_newlines -> statement_separator
Rule 14    optional_newlines -> empty
Rule 15    statement -> expression
Rule 16    statement -> assignment
Rule 17    statement -> io_statement
Rule 18    statement -> control_statement
Rule 19    statement -> function_definition
Rule 20    statement -> class_definition
Rule 21    statement -> return_statement
Rule 22    expression -> INTEGER
Rule 23    expression -> FLOAT
Rule 24    expression -> STRING
Rule 25    expression -> SYMBOL
Rule 26    expression -> REGEXP
Rule 27    expression -> TRUE
Rule 28    expression -> FALSE
Rule 29    expression -> NIL
Rule 30    expression -> IDENTIFIER
Rule 31    expression -> INSTANCE_VARIABLE
Rule 32    expression -> CLASS_VARIABLE
Rule 33    expression -> GLOBAL_VARIABLE
Rule 34    expression -> CONSTANT
Rule 35    expression -> expression RANGE_INCLUSIVE expression
Rule 36    expression -> expression RANGE_EXCLUSIVE expression
Rule 37    expression -> IDENTIFIER LBRACKET expression RBRACKET
Rule 38    expression -> expression DOT IDENTIFIER
Rule 39    expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN
Rule 40    expression -> expression DOT IDENTIFIER LPAREN RPAREN
Rule 41    assignment -> IDENTIFIER ASSIGN expression
Rule 42    assignment -> INSTANCE_VARIABLE ASSIGN expression
Rule 43    assignment -> CLASS_VARIABLE ASSIGN expression
Rule 44    assignment -> GLOBAL_VARIABLE ASSIGN expression
Rule 45    assignment -> CONSTANT ASSIGN expression
Rule 46    assignment -> assignment_array ASSIGN expression
Rule 47    assignment_array -> IDENTIFIER LBRACKET expression RBRACKET
Rule 48    expression -> expression PLUS expression
Rule 49    expression -> expression MINUS expression
Rule 50    expression -> expression TIMES expression
Rule 51    expression -> expression DIVIDE expression
Rule 52    expression -> expression MODULE_OP expression
Rule 53    expression -> expression POWER expression
Rule 54    expression -> LPAREN expression RPAREN
Rule 55    expression -> MINUS expression
Rule 56    class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
Rule 57    class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
Rule 58    param_list -> IDENTIFIER COMMA param_list
Rule 59    param_list -> IDENTIFIER
Rule 60    return_statement -> RETURN expression
Rule 61    return_statement -> RETURN
Rule 62    function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END
Rule 63    func_name_hook -> IDENTIFIER
Rule 64    func_header -> LPAREN param_list RPAREN
Rule 65    func_header -> LPAREN RPAREN
Rule 66    func_header -> empty
Rule 67    expression -> LBRACE hash_pairs RBRACE
Rule 68    expression -> LBRACE RBRACE
Rule 69    hash_pairs -> hash_pairs COMMA hash_pair
Rule 70    hash_pairs -> hash_pair
Rule 71    hash_pair -> expression HASH_ROCKET expression
Rule 72    hash_pair -> SYMBOL HASH_ROCKET expression
Rule 73    hash_pair -> STRING HASH_ROCKET expression
Rule 74    io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER
Rule 75    io_statement -> IDENTIFIER ASSIGN GETS
Rule 76    condition -> expression EQUAL expression
Rule 77    condition -> expression NOT_EQUAL expression
Rule 78    condition -> expression GREATER expression
Rule 79    condition -> expression LESS expression
Rule 80    condition -> expression GREATER_EQUAL expression
Rule 81    condition -> expression LESS_EQUAL expression
Rule 82    condition -> expression SPACESHIP expression
Rule 83    condition -> expression CASE_EQUAL expression
Rule 84    condition -> condition LOGICAL_AND condition
Rule 85    condition -> condition AND condition
Rule 86    condition -> condition LOGICAL_OR condition
Rule 87    condition -> condition OR condition
Rule 88    condition -> LOGICAL_NOT condition
Rule 89    condition -> NOT condition
Rule 90    condition -> expression
Rule 91    expression -> LBRACKET array_elements RBRACKET
Rule 92    expression -> LBRACKET RBRACKET
Rule 93    array_elements -> array_elements COMMA expression
Rule 94    array_elements -> expression
Rule 95    io_statement -> PUTS expression
Rule 96    io_statement -> PUTS
Rule 97    control_statement -> FOR for_setup statements optional_newlines exit_scope END
Rule 98    for_setup -> IDENTIFIER IN expression enter_loop_scope
Rule 99    control_statement -> IF condition enter_scope statements optional_newlines exit_scope END
Rule 100   control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
Rule 101   control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
Rule 102   control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
Rule 103   elsif_clauses -> elsif_clauses ELSIF condition statements optional_newlines
Rule 104   elsif_clauses -> ELSIF condition statements optional_newlines
Rule 105   control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END
Rule 106   expression -> IDENTIFIER LPAREN arguments RPAREN
Rule 107   expression -> IDENTIFIER LPAREN RPAREN
Rule 108   expression -> IDENTIFIER arguments
Rule 109   arguments -> arguments COMMA expression
Rule 110   arguments -> expression
Rule 111   statement -> BREAK
Rule 112   statement -> NEXT

Terminals, with rules where they appear

ALIAS                : 
AND                  : 85
ASSIGN               : 41 42 43 44 45 46 74 75
BEGIN                : 
BREAK                : 111
CASE                 : 
CASE_EQUAL           : 83
CLASS                : 56 57
CLASS_VARIABLE       : 32 43
COMMA                : 58 69 93 109
CONSTANT             : 34 45 56 57 57
DEF                  : 62
DIVIDE               : 51
DIVIDE_ASSIGN        : 
DO                   : 
DOT                  : 38 39 40 74
ELSE                 : 100 102
ELSIF                : 103 104
END                  : 56 57 62 97 99 100 101 102 105
ENSURE               : 
EQUAL                : 76
FALSE                : 28
FLOAT                : 23
FOR                  : 97
GETS                 : 74 75
GLOBAL_VARIABLE      : 33 44
GREATER              : 78
GREATER_EQUAL        : 80
HASH_ROCKET          : 71 72 73
IDENTIFIER           : 30 37 38 39 40 41 47 58 59 63 74 74 75 98 106 107 108
IF                   : 99 100 101 102
IN                   : 98
INSTANCE_VARIABLE    : 31 42
INTEGER              : 22
LBRACE               : 67 68
LBRACKET             : 37 47 91 92
LESS                 : 57 79
LESS_EQUAL           : 81
LOGICAL_AND          : 84
LOGICAL_NOT          : 88
LOGICAL_OR           : 86
LPAREN               : 39 40 54 64 65 106 107
MINUS                : 49 55
MINUS_ASSIGN         : 
MODULE               : 
MODULE_OP            : 52
MOD_ASSIGN           : 
NEWLINE              : 9 11
NEXT                 : 112
NIL                  : 29
NOT                  : 89
NOT_EQUAL            : 77
OR                   : 87
PLUS                 : 48
PLUS_ASSIGN          : 
POWER                : 53
POWER_ASSIGN         : 
PUTS                 : 95 96
RANGE_EXCLUSIVE      : 36
RANGE_INCLUSIVE      : 35
RBRACE               : 67 68
RBRACKET             : 37 47 91 92
REGEXP               : 26
RESCUE               : 
RETRY                : 
RETURN               : 60 61
RPAREN               : 39 40 54 64 65 106 107
SCOPE                : 
SELF                 : 
SEMICOLON            : 10 12
SPACESHIP            : 82
STRING               : 24 73
SUPER                : 
SYMBOL               : 25 72
THEN                 : 
TIMES                : 50
TIMES_ASSIGN         : 
TRUE                 : 27
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 105
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arguments            : 39 106 108 109
array_elements       : 91 93
assignment           : 16
assignment_array     : 46
class_definition     : 20
condition            : 84 84 85 85 86 86 87 87 88 89 99 100 101 102 103 104 105
control_statement    : 18
elsif_clauses        : 101 102 103
empty                : 2 3 4 8 14 66
enter_loop_scope     : 98 105
enter_scope          : 56 57 99 100 100 101 102 102
exit_scope           : 56 57 62 97 99 100 100 101 102 105
expression           : 15 35 35 36 36 37 38 39 40 41 42 43 44 45 46 47 48 48 49 49 50 50 51 51 52 52 53 53 54 55 60 71 71 72 73 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 90 93 94 95 98 109 110
for_setup            : 97
func_header          : 62
func_name_hook       : 62
function_definition  : 19
hash_pair            : 69 70
hash_pairs           : 67 69
io_statement         : 17
optional_newlines    : 5 5 56 57 62 97 99 100 100 101 102 103 104 105
param_list           : 58 64
program              : 0
return_statement     : 21
statement            : 6 7
statement_separator  : 6 11 12 13
statements           : 5 6 56 57 62 97 99 100 100 101 102 102 103 104 105

Parsing method: LALR

state 0

    (0) S' -> . program
    (5) program -> . optional_newlines statements optional_newlines
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

  ! NEWLINE         [ reduce using rule 1 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 1 (empty -> .) ]

    program                        shift and go to state 1
    optional_newlines              shift and go to state 2
    statement_separator            shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (5) program -> optional_newlines . statements optional_newlines
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 7
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 3

    (13) optional_newlines -> statement_separator .
    (11) statement_separator -> statement_separator . NEWLINE
    (12) statement_separator -> statement_separator . SEMICOLON

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
    BREAK           reduce using rule 13 (optional_newlines -> statement_separator .)
    NEXT            reduce using rule 13 (optional_newlines -> statement_separator .)
    INTEGER         reduce using rule 13 (optional_newlines -> statement_separator .)
    FLOAT           reduce using rule 13 (optional_newlines -> statement_separator .)
    STRING          reduce using rule 13 (optional_newlines -> statement_separator .)
    SYMBOL          reduce using rule 13 (optional_newlines -> statement_separator .)
    REGEXP          reduce using rule 13 (optional_newlines -> statement_separator .)
    TRUE            reduce using rule 13 (optional_newlines -> statement_separator .)
    FALSE           reduce using rule 13 (optional_newlines -> statement_separator .)
    NIL             reduce using rule 13 (optional_newlines -> statement_separator .)
    IDENTIFIER      reduce using rule 13 (optional_newlines -> statement_separator .)
    INSTANCE_VARIABLE reduce using rule 13 (optional_newlines -> statement_separator .)
    CLASS_VARIABLE  reduce using rule 13 (optional_newlines -> statement_separator .)
    GLOBAL_VARIABLE reduce using rule 13 (optional_newlines -> statement_separator .)
    CONSTANT        reduce using rule 13 (optional_newlines -> statement_separator .)
    LPAREN          reduce using rule 13 (optional_newlines -> statement_separator .)
    MINUS           reduce using rule 13 (optional_newlines -> statement_separator .)
    LBRACE          reduce using rule 13 (optional_newlines -> statement_separator .)
    LBRACKET        reduce using rule 13 (optional_newlines -> statement_separator .)
    PUTS            reduce using rule 13 (optional_newlines -> statement_separator .)
    FOR             reduce using rule 13 (optional_newlines -> statement_separator .)
    IF              reduce using rule 13 (optional_newlines -> statement_separator .)
    WHILE           reduce using rule 13 (optional_newlines -> statement_separator .)
    DEF             reduce using rule 13 (optional_newlines -> statement_separator .)
    CLASS           reduce using rule 13 (optional_newlines -> statement_separator .)
    RETURN          reduce using rule 13 (optional_newlines -> statement_separator .)
    $end            reduce using rule 13 (optional_newlines -> statement_separator .)
    END             reduce using rule 13 (optional_newlines -> statement_separator .)
    NEWLINE         shift and go to state 44
    SEMICOLON       shift and go to state 45

  ! NEWLINE         [ reduce using rule 13 (optional_newlines -> statement_separator .) ]
  ! SEMICOLON       [ reduce using rule 13 (optional_newlines -> statement_separator .) ]


state 4

    (14) optional_newlines -> empty .

    BREAK           reduce using rule 14 (optional_newlines -> empty .)
    NEXT            reduce using rule 14 (optional_newlines -> empty .)
    INTEGER         reduce using rule 14 (optional_newlines -> empty .)
    FLOAT           reduce using rule 14 (optional_newlines -> empty .)
    STRING          reduce using rule 14 (optional_newlines -> empty .)
    SYMBOL          reduce using rule 14 (optional_newlines -> empty .)
    REGEXP          reduce using rule 14 (optional_newlines -> empty .)
    TRUE            reduce using rule 14 (optional_newlines -> empty .)
    FALSE           reduce using rule 14 (optional_newlines -> empty .)
    NIL             reduce using rule 14 (optional_newlines -> empty .)
    IDENTIFIER      reduce using rule 14 (optional_newlines -> empty .)
    INSTANCE_VARIABLE reduce using rule 14 (optional_newlines -> empty .)
    CLASS_VARIABLE  reduce using rule 14 (optional_newlines -> empty .)
    GLOBAL_VARIABLE reduce using rule 14 (optional_newlines -> empty .)
    CONSTANT        reduce using rule 14 (optional_newlines -> empty .)
    LPAREN          reduce using rule 14 (optional_newlines -> empty .)
    MINUS           reduce using rule 14 (optional_newlines -> empty .)
    LBRACE          reduce using rule 14 (optional_newlines -> empty .)
    LBRACKET        reduce using rule 14 (optional_newlines -> empty .)
    PUTS            reduce using rule 14 (optional_newlines -> empty .)
    FOR             reduce using rule 14 (optional_newlines -> empty .)
    IF              reduce using rule 14 (optional_newlines -> empty .)
    WHILE           reduce using rule 14 (optional_newlines -> empty .)
    DEF             reduce using rule 14 (optional_newlines -> empty .)
    CLASS           reduce using rule 14 (optional_newlines -> empty .)
    RETURN          reduce using rule 14 (optional_newlines -> empty .)
    NEWLINE         reduce using rule 14 (optional_newlines -> empty .)
    SEMICOLON       reduce using rule 14 (optional_newlines -> empty .)
    $end            reduce using rule 14 (optional_newlines -> empty .)
    END             reduce using rule 14 (optional_newlines -> empty .)
    ELSE            reduce using rule 14 (optional_newlines -> empty .)
    ELSIF           reduce using rule 14 (optional_newlines -> empty .)


state 5

    (9) statement_separator -> NEWLINE .

    NEWLINE         reduce using rule 9 (statement_separator -> NEWLINE .)
    SEMICOLON       reduce using rule 9 (statement_separator -> NEWLINE .)
    BREAK           reduce using rule 9 (statement_separator -> NEWLINE .)
    NEXT            reduce using rule 9 (statement_separator -> NEWLINE .)
    INTEGER         reduce using rule 9 (statement_separator -> NEWLINE .)
    FLOAT           reduce using rule 9 (statement_separator -> NEWLINE .)
    STRING          reduce using rule 9 (statement_separator -> NEWLINE .)
    SYMBOL          reduce using rule 9 (statement_separator -> NEWLINE .)
    REGEXP          reduce using rule 9 (statement_separator -> NEWLINE .)
    TRUE            reduce using rule 9 (statement_separator -> NEWLINE .)
    FALSE           reduce using rule 9 (statement_separator -> NEWLINE .)
    NIL             reduce using rule 9 (statement_separator -> NEWLINE .)
    IDENTIFIER      reduce using rule 9 (statement_separator -> NEWLINE .)
    INSTANCE_VARIABLE reduce using rule 9 (statement_separator -> NEWLINE .)
    CLASS_VARIABLE  reduce using rule 9 (statement_separator -> NEWLINE .)
    GLOBAL_VARIABLE reduce using rule 9 (statement_separator -> NEWLINE .)
    CONSTANT        reduce using rule 9 (statement_separator -> NEWLINE .)
    LPAREN          reduce using rule 9 (statement_separator -> NEWLINE .)
    MINUS           reduce using rule 9 (statement_separator -> NEWLINE .)
    LBRACE          reduce using rule 9 (statement_separator -> NEWLINE .)
    LBRACKET        reduce using rule 9 (statement_separator -> NEWLINE .)
    PUTS            reduce using rule 9 (statement_separator -> NEWLINE .)
    FOR             reduce using rule 9 (statement_separator -> NEWLINE .)
    IF              reduce using rule 9 (statement_separator -> NEWLINE .)
    WHILE           reduce using rule 9 (statement_separator -> NEWLINE .)
    DEF             reduce using rule 9 (statement_separator -> NEWLINE .)
    CLASS           reduce using rule 9 (statement_separator -> NEWLINE .)
    RETURN          reduce using rule 9 (statement_separator -> NEWLINE .)
    $end            reduce using rule 9 (statement_separator -> NEWLINE .)
    END             reduce using rule 9 (statement_separator -> NEWLINE .)
    ELSE            reduce using rule 9 (statement_separator -> NEWLINE .)
    ELSIF           reduce using rule 9 (statement_separator -> NEWLINE .)


state 6

    (10) statement_separator -> SEMICOLON .

    NEWLINE         reduce using rule 10 (statement_separator -> SEMICOLON .)
    SEMICOLON       reduce using rule 10 (statement_separator -> SEMICOLON .)
    BREAK           reduce using rule 10 (statement_separator -> SEMICOLON .)
    NEXT            reduce using rule 10 (statement_separator -> SEMICOLON .)
    INTEGER         reduce using rule 10 (statement_separator -> SEMICOLON .)
    FLOAT           reduce using rule 10 (statement_separator -> SEMICOLON .)
    STRING          reduce using rule 10 (statement_separator -> SEMICOLON .)
    SYMBOL          reduce using rule 10 (statement_separator -> SEMICOLON .)
    REGEXP          reduce using rule 10 (statement_separator -> SEMICOLON .)
    TRUE            reduce using rule 10 (statement_separator -> SEMICOLON .)
    FALSE           reduce using rule 10 (statement_separator -> SEMICOLON .)
    NIL             reduce using rule 10 (statement_separator -> SEMICOLON .)
    IDENTIFIER      reduce using rule 10 (statement_separator -> SEMICOLON .)
    INSTANCE_VARIABLE reduce using rule 10 (statement_separator -> SEMICOLON .)
    CLASS_VARIABLE  reduce using rule 10 (statement_separator -> SEMICOLON .)
    GLOBAL_VARIABLE reduce using rule 10 (statement_separator -> SEMICOLON .)
    CONSTANT        reduce using rule 10 (statement_separator -> SEMICOLON .)
    LPAREN          reduce using rule 10 (statement_separator -> SEMICOLON .)
    MINUS           reduce using rule 10 (statement_separator -> SEMICOLON .)
    LBRACE          reduce using rule 10 (statement_separator -> SEMICOLON .)
    LBRACKET        reduce using rule 10 (statement_separator -> SEMICOLON .)
    PUTS            reduce using rule 10 (statement_separator -> SEMICOLON .)
    FOR             reduce using rule 10 (statement_separator -> SEMICOLON .)
    IF              reduce using rule 10 (statement_separator -> SEMICOLON .)
    WHILE           reduce using rule 10 (statement_separator -> SEMICOLON .)
    DEF             reduce using rule 10 (statement_separator -> SEMICOLON .)
    CLASS           reduce using rule 10 (statement_separator -> SEMICOLON .)
    RETURN          reduce using rule 10 (statement_separator -> SEMICOLON .)
    $end            reduce using rule 10 (statement_separator -> SEMICOLON .)
    END             reduce using rule 10 (statement_separator -> SEMICOLON .)
    ELSE            reduce using rule 10 (statement_separator -> SEMICOLON .)
    ELSIF           reduce using rule 10 (statement_separator -> SEMICOLON .)


state 7

    (5) program -> optional_newlines statements . optional_newlines
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    $end            reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 46
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 8

    (7) statements -> statement .

    NEWLINE         reduce using rule 7 (statements -> statement .)
    SEMICOLON       reduce using rule 7 (statements -> statement .)
    $end            reduce using rule 7 (statements -> statement .)
    END             reduce using rule 7 (statements -> statement .)
    ELSIF           reduce using rule 7 (statements -> statement .)
    ELSE            reduce using rule 7 (statements -> statement .)


state 9

    (8) statements -> empty .

    NEWLINE         reduce using rule 8 (statements -> empty .)
    SEMICOLON       reduce using rule 8 (statements -> empty .)
    $end            reduce using rule 8 (statements -> empty .)
    END             reduce using rule 8 (statements -> empty .)
    ELSIF           reduce using rule 8 (statements -> empty .)
    ELSE            reduce using rule 8 (statements -> empty .)


state 10

    (15) statement -> expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 15 (statement -> expression .)
    SEMICOLON       reduce using rule 15 (statement -> expression .)
    $end            reduce using rule 15 (statement -> expression .)
    END             reduce using rule 15 (statement -> expression .)
    ELSIF           reduce using rule 15 (statement -> expression .)
    ELSE            reduce using rule 15 (statement -> expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 11

    (16) statement -> assignment .

    NEWLINE         reduce using rule 16 (statement -> assignment .)
    SEMICOLON       reduce using rule 16 (statement -> assignment .)
    $end            reduce using rule 16 (statement -> assignment .)
    END             reduce using rule 16 (statement -> assignment .)
    ELSIF           reduce using rule 16 (statement -> assignment .)
    ELSE            reduce using rule 16 (statement -> assignment .)


state 12

    (17) statement -> io_statement .

    NEWLINE         reduce using rule 17 (statement -> io_statement .)
    SEMICOLON       reduce using rule 17 (statement -> io_statement .)
    $end            reduce using rule 17 (statement -> io_statement .)
    END             reduce using rule 17 (statement -> io_statement .)
    ELSIF           reduce using rule 17 (statement -> io_statement .)
    ELSE            reduce using rule 17 (statement -> io_statement .)


state 13

    (18) statement -> control_statement .

    NEWLINE         reduce using rule 18 (statement -> control_statement .)
    SEMICOLON       reduce using rule 18 (statement -> control_statement .)
    $end            reduce using rule 18 (statement -> control_statement .)
    END             reduce using rule 18 (statement -> control_statement .)
    ELSIF           reduce using rule 18 (statement -> control_statement .)
    ELSE            reduce using rule 18 (statement -> control_statement .)


state 14

    (19) statement -> function_definition .

    NEWLINE         reduce using rule 19 (statement -> function_definition .)
    SEMICOLON       reduce using rule 19 (statement -> function_definition .)
    $end            reduce using rule 19 (statement -> function_definition .)
    END             reduce using rule 19 (statement -> function_definition .)
    ELSIF           reduce using rule 19 (statement -> function_definition .)
    ELSE            reduce using rule 19 (statement -> function_definition .)


state 15

    (20) statement -> class_definition .

    NEWLINE         reduce using rule 20 (statement -> class_definition .)
    SEMICOLON       reduce using rule 20 (statement -> class_definition .)
    $end            reduce using rule 20 (statement -> class_definition .)
    END             reduce using rule 20 (statement -> class_definition .)
    ELSIF           reduce using rule 20 (statement -> class_definition .)
    ELSE            reduce using rule 20 (statement -> class_definition .)


state 16

    (21) statement -> return_statement .

    NEWLINE         reduce using rule 21 (statement -> return_statement .)
    SEMICOLON       reduce using rule 21 (statement -> return_statement .)
    $end            reduce using rule 21 (statement -> return_statement .)
    END             reduce using rule 21 (statement -> return_statement .)
    ELSIF           reduce using rule 21 (statement -> return_statement .)
    ELSE            reduce using rule 21 (statement -> return_statement .)


state 17

    (111) statement -> BREAK .

    NEWLINE         reduce using rule 111 (statement -> BREAK .)
    SEMICOLON       reduce using rule 111 (statement -> BREAK .)
    $end            reduce using rule 111 (statement -> BREAK .)
    END             reduce using rule 111 (statement -> BREAK .)
    ELSIF           reduce using rule 111 (statement -> BREAK .)
    ELSE            reduce using rule 111 (statement -> BREAK .)


state 18

    (112) statement -> NEXT .

    NEWLINE         reduce using rule 112 (statement -> NEXT .)
    SEMICOLON       reduce using rule 112 (statement -> NEXT .)
    $end            reduce using rule 112 (statement -> NEXT .)
    END             reduce using rule 112 (statement -> NEXT .)
    ELSIF           reduce using rule 112 (statement -> NEXT .)
    ELSE            reduce using rule 112 (statement -> NEXT .)


state 19

    (22) expression -> INTEGER .

    RANGE_INCLUSIVE reduce using rule 22 (expression -> INTEGER .)
    RANGE_EXCLUSIVE reduce using rule 22 (expression -> INTEGER .)
    DOT             reduce using rule 22 (expression -> INTEGER .)
    PLUS            reduce using rule 22 (expression -> INTEGER .)
    MINUS           reduce using rule 22 (expression -> INTEGER .)
    TIMES           reduce using rule 22 (expression -> INTEGER .)
    DIVIDE          reduce using rule 22 (expression -> INTEGER .)
    MODULE_OP       reduce using rule 22 (expression -> INTEGER .)
    POWER           reduce using rule 22 (expression -> INTEGER .)
    NEWLINE         reduce using rule 22 (expression -> INTEGER .)
    SEMICOLON       reduce using rule 22 (expression -> INTEGER .)
    $end            reduce using rule 22 (expression -> INTEGER .)
    COMMA           reduce using rule 22 (expression -> INTEGER .)
    END             reduce using rule 22 (expression -> INTEGER .)
    ELSIF           reduce using rule 22 (expression -> INTEGER .)
    ELSE            reduce using rule 22 (expression -> INTEGER .)
    RBRACKET        reduce using rule 22 (expression -> INTEGER .)
    RPAREN          reduce using rule 22 (expression -> INTEGER .)
    HASH_ROCKET     reduce using rule 22 (expression -> INTEGER .)
    EQUAL           reduce using rule 22 (expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 22 (expression -> INTEGER .)
    GREATER         reduce using rule 22 (expression -> INTEGER .)
    LESS            reduce using rule 22 (expression -> INTEGER .)
    GREATER_EQUAL   reduce using rule 22 (expression -> INTEGER .)
    LESS_EQUAL      reduce using rule 22 (expression -> INTEGER .)
    SPACESHIP       reduce using rule 22 (expression -> INTEGER .)
    CASE_EQUAL      reduce using rule 22 (expression -> INTEGER .)
    LOGICAL_AND     reduce using rule 22 (expression -> INTEGER .)
    AND             reduce using rule 22 (expression -> INTEGER .)
    LOGICAL_OR      reduce using rule 22 (expression -> INTEGER .)
    OR              reduce using rule 22 (expression -> INTEGER .)
    BREAK           reduce using rule 22 (expression -> INTEGER .)
    NEXT            reduce using rule 22 (expression -> INTEGER .)
    INTEGER         reduce using rule 22 (expression -> INTEGER .)
    FLOAT           reduce using rule 22 (expression -> INTEGER .)
    STRING          reduce using rule 22 (expression -> INTEGER .)
    SYMBOL          reduce using rule 22 (expression -> INTEGER .)
    REGEXP          reduce using rule 22 (expression -> INTEGER .)
    TRUE            reduce using rule 22 (expression -> INTEGER .)
    FALSE           reduce using rule 22 (expression -> INTEGER .)
    NIL             reduce using rule 22 (expression -> INTEGER .)
    IDENTIFIER      reduce using rule 22 (expression -> INTEGER .)
    INSTANCE_VARIABLE reduce using rule 22 (expression -> INTEGER .)
    CLASS_VARIABLE  reduce using rule 22 (expression -> INTEGER .)
    GLOBAL_VARIABLE reduce using rule 22 (expression -> INTEGER .)
    CONSTANT        reduce using rule 22 (expression -> INTEGER .)
    LPAREN          reduce using rule 22 (expression -> INTEGER .)
    LBRACE          reduce using rule 22 (expression -> INTEGER .)
    LBRACKET        reduce using rule 22 (expression -> INTEGER .)
    PUTS            reduce using rule 22 (expression -> INTEGER .)
    FOR             reduce using rule 22 (expression -> INTEGER .)
    IF              reduce using rule 22 (expression -> INTEGER .)
    WHILE           reduce using rule 22 (expression -> INTEGER .)
    DEF             reduce using rule 22 (expression -> INTEGER .)
    CLASS           reduce using rule 22 (expression -> INTEGER .)
    RETURN          reduce using rule 22 (expression -> INTEGER .)
    RBRACE          reduce using rule 22 (expression -> INTEGER .)


state 20

    (23) expression -> FLOAT .

    RANGE_INCLUSIVE reduce using rule 23 (expression -> FLOAT .)
    RANGE_EXCLUSIVE reduce using rule 23 (expression -> FLOAT .)
    DOT             reduce using rule 23 (expression -> FLOAT .)
    PLUS            reduce using rule 23 (expression -> FLOAT .)
    MINUS           reduce using rule 23 (expression -> FLOAT .)
    TIMES           reduce using rule 23 (expression -> FLOAT .)
    DIVIDE          reduce using rule 23 (expression -> FLOAT .)
    MODULE_OP       reduce using rule 23 (expression -> FLOAT .)
    POWER           reduce using rule 23 (expression -> FLOAT .)
    NEWLINE         reduce using rule 23 (expression -> FLOAT .)
    SEMICOLON       reduce using rule 23 (expression -> FLOAT .)
    $end            reduce using rule 23 (expression -> FLOAT .)
    COMMA           reduce using rule 23 (expression -> FLOAT .)
    END             reduce using rule 23 (expression -> FLOAT .)
    ELSIF           reduce using rule 23 (expression -> FLOAT .)
    ELSE            reduce using rule 23 (expression -> FLOAT .)
    RBRACKET        reduce using rule 23 (expression -> FLOAT .)
    RPAREN          reduce using rule 23 (expression -> FLOAT .)
    HASH_ROCKET     reduce using rule 23 (expression -> FLOAT .)
    EQUAL           reduce using rule 23 (expression -> FLOAT .)
    NOT_EQUAL       reduce using rule 23 (expression -> FLOAT .)
    GREATER         reduce using rule 23 (expression -> FLOAT .)
    LESS            reduce using rule 23 (expression -> FLOAT .)
    GREATER_EQUAL   reduce using rule 23 (expression -> FLOAT .)
    LESS_EQUAL      reduce using rule 23 (expression -> FLOAT .)
    SPACESHIP       reduce using rule 23 (expression -> FLOAT .)
    CASE_EQUAL      reduce using rule 23 (expression -> FLOAT .)
    LOGICAL_AND     reduce using rule 23 (expression -> FLOAT .)
    AND             reduce using rule 23 (expression -> FLOAT .)
    LOGICAL_OR      reduce using rule 23 (expression -> FLOAT .)
    OR              reduce using rule 23 (expression -> FLOAT .)
    BREAK           reduce using rule 23 (expression -> FLOAT .)
    NEXT            reduce using rule 23 (expression -> FLOAT .)
    INTEGER         reduce using rule 23 (expression -> FLOAT .)
    FLOAT           reduce using rule 23 (expression -> FLOAT .)
    STRING          reduce using rule 23 (expression -> FLOAT .)
    SYMBOL          reduce using rule 23 (expression -> FLOAT .)
    REGEXP          reduce using rule 23 (expression -> FLOAT .)
    TRUE            reduce using rule 23 (expression -> FLOAT .)
    FALSE           reduce using rule 23 (expression -> FLOAT .)
    NIL             reduce using rule 23 (expression -> FLOAT .)
    IDENTIFIER      reduce using rule 23 (expression -> FLOAT .)
    INSTANCE_VARIABLE reduce using rule 23 (expression -> FLOAT .)
    CLASS_VARIABLE  reduce using rule 23 (expression -> FLOAT .)
    GLOBAL_VARIABLE reduce using rule 23 (expression -> FLOAT .)
    CONSTANT        reduce using rule 23 (expression -> FLOAT .)
    LPAREN          reduce using rule 23 (expression -> FLOAT .)
    LBRACE          reduce using rule 23 (expression -> FLOAT .)
    LBRACKET        reduce using rule 23 (expression -> FLOAT .)
    PUTS            reduce using rule 23 (expression -> FLOAT .)
    FOR             reduce using rule 23 (expression -> FLOAT .)
    IF              reduce using rule 23 (expression -> FLOAT .)
    WHILE           reduce using rule 23 (expression -> FLOAT .)
    DEF             reduce using rule 23 (expression -> FLOAT .)
    CLASS           reduce using rule 23 (expression -> FLOAT .)
    RETURN          reduce using rule 23 (expression -> FLOAT .)
    RBRACE          reduce using rule 23 (expression -> FLOAT .)


state 21

    (24) expression -> STRING .

    RANGE_INCLUSIVE reduce using rule 24 (expression -> STRING .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> STRING .)
    DOT             reduce using rule 24 (expression -> STRING .)
    PLUS            reduce using rule 24 (expression -> STRING .)
    MINUS           reduce using rule 24 (expression -> STRING .)
    TIMES           reduce using rule 24 (expression -> STRING .)
    DIVIDE          reduce using rule 24 (expression -> STRING .)
    MODULE_OP       reduce using rule 24 (expression -> STRING .)
    POWER           reduce using rule 24 (expression -> STRING .)
    NEWLINE         reduce using rule 24 (expression -> STRING .)
    SEMICOLON       reduce using rule 24 (expression -> STRING .)
    $end            reduce using rule 24 (expression -> STRING .)
    COMMA           reduce using rule 24 (expression -> STRING .)
    END             reduce using rule 24 (expression -> STRING .)
    ELSIF           reduce using rule 24 (expression -> STRING .)
    ELSE            reduce using rule 24 (expression -> STRING .)
    RBRACKET        reduce using rule 24 (expression -> STRING .)
    RPAREN          reduce using rule 24 (expression -> STRING .)
    HASH_ROCKET     reduce using rule 24 (expression -> STRING .)
    EQUAL           reduce using rule 24 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 24 (expression -> STRING .)
    GREATER         reduce using rule 24 (expression -> STRING .)
    LESS            reduce using rule 24 (expression -> STRING .)
    GREATER_EQUAL   reduce using rule 24 (expression -> STRING .)
    LESS_EQUAL      reduce using rule 24 (expression -> STRING .)
    SPACESHIP       reduce using rule 24 (expression -> STRING .)
    CASE_EQUAL      reduce using rule 24 (expression -> STRING .)
    LOGICAL_AND     reduce using rule 24 (expression -> STRING .)
    AND             reduce using rule 24 (expression -> STRING .)
    LOGICAL_OR      reduce using rule 24 (expression -> STRING .)
    OR              reduce using rule 24 (expression -> STRING .)
    BREAK           reduce using rule 24 (expression -> STRING .)
    NEXT            reduce using rule 24 (expression -> STRING .)
    INTEGER         reduce using rule 24 (expression -> STRING .)
    FLOAT           reduce using rule 24 (expression -> STRING .)
    STRING          reduce using rule 24 (expression -> STRING .)
    SYMBOL          reduce using rule 24 (expression -> STRING .)
    REGEXP          reduce using rule 24 (expression -> STRING .)
    TRUE            reduce using rule 24 (expression -> STRING .)
    FALSE           reduce using rule 24 (expression -> STRING .)
    NIL             reduce using rule 24 (expression -> STRING .)
    IDENTIFIER      reduce using rule 24 (expression -> STRING .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> STRING .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> STRING .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> STRING .)
    CONSTANT        reduce using rule 24 (expression -> STRING .)
    LPAREN          reduce using rule 24 (expression -> STRING .)
    LBRACE          reduce using rule 24 (expression -> STRING .)
    LBRACKET        reduce using rule 24 (expression -> STRING .)
    PUTS            reduce using rule 24 (expression -> STRING .)
    FOR             reduce using rule 24 (expression -> STRING .)
    IF              reduce using rule 24 (expression -> STRING .)
    WHILE           reduce using rule 24 (expression -> STRING .)
    DEF             reduce using rule 24 (expression -> STRING .)
    CLASS           reduce using rule 24 (expression -> STRING .)
    RETURN          reduce using rule 24 (expression -> STRING .)
    RBRACE          reduce using rule 24 (expression -> STRING .)


state 22

    (25) expression -> SYMBOL .

    RANGE_INCLUSIVE reduce using rule 25 (expression -> SYMBOL .)
    RANGE_EXCLUSIVE reduce using rule 25 (expression -> SYMBOL .)
    DOT             reduce using rule 25 (expression -> SYMBOL .)
    PLUS            reduce using rule 25 (expression -> SYMBOL .)
    MINUS           reduce using rule 25 (expression -> SYMBOL .)
    TIMES           reduce using rule 25 (expression -> SYMBOL .)
    DIVIDE          reduce using rule 25 (expression -> SYMBOL .)
    MODULE_OP       reduce using rule 25 (expression -> SYMBOL .)
    POWER           reduce using rule 25 (expression -> SYMBOL .)
    NEWLINE         reduce using rule 25 (expression -> SYMBOL .)
    SEMICOLON       reduce using rule 25 (expression -> SYMBOL .)
    $end            reduce using rule 25 (expression -> SYMBOL .)
    COMMA           reduce using rule 25 (expression -> SYMBOL .)
    END             reduce using rule 25 (expression -> SYMBOL .)
    ELSIF           reduce using rule 25 (expression -> SYMBOL .)
    ELSE            reduce using rule 25 (expression -> SYMBOL .)
    RBRACKET        reduce using rule 25 (expression -> SYMBOL .)
    RPAREN          reduce using rule 25 (expression -> SYMBOL .)
    HASH_ROCKET     reduce using rule 25 (expression -> SYMBOL .)
    EQUAL           reduce using rule 25 (expression -> SYMBOL .)
    NOT_EQUAL       reduce using rule 25 (expression -> SYMBOL .)
    GREATER         reduce using rule 25 (expression -> SYMBOL .)
    LESS            reduce using rule 25 (expression -> SYMBOL .)
    GREATER_EQUAL   reduce using rule 25 (expression -> SYMBOL .)
    LESS_EQUAL      reduce using rule 25 (expression -> SYMBOL .)
    SPACESHIP       reduce using rule 25 (expression -> SYMBOL .)
    CASE_EQUAL      reduce using rule 25 (expression -> SYMBOL .)
    LOGICAL_AND     reduce using rule 25 (expression -> SYMBOL .)
    AND             reduce using rule 25 (expression -> SYMBOL .)
    LOGICAL_OR      reduce using rule 25 (expression -> SYMBOL .)
    OR              reduce using rule 25 (expression -> SYMBOL .)
    BREAK           reduce using rule 25 (expression -> SYMBOL .)
    NEXT            reduce using rule 25 (expression -> SYMBOL .)
    INTEGER         reduce using rule 25 (expression -> SYMBOL .)
    FLOAT           reduce using rule 25 (expression -> SYMBOL .)
    STRING          reduce using rule 25 (expression -> SYMBOL .)
    SYMBOL          reduce using rule 25 (expression -> SYMBOL .)
    REGEXP          reduce using rule 25 (expression -> SYMBOL .)
    TRUE            reduce using rule 25 (expression -> SYMBOL .)
    FALSE           reduce using rule 25 (expression -> SYMBOL .)
    NIL             reduce using rule 25 (expression -> SYMBOL .)
    IDENTIFIER      reduce using rule 25 (expression -> SYMBOL .)
    INSTANCE_VARIABLE reduce using rule 25 (expression -> SYMBOL .)
    CLASS_VARIABLE  reduce using rule 25 (expression -> SYMBOL .)
    GLOBAL_VARIABLE reduce using rule 25 (expression -> SYMBOL .)
    CONSTANT        reduce using rule 25 (expression -> SYMBOL .)
    LPAREN          reduce using rule 25 (expression -> SYMBOL .)
    LBRACE          reduce using rule 25 (expression -> SYMBOL .)
    LBRACKET        reduce using rule 25 (expression -> SYMBOL .)
    PUTS            reduce using rule 25 (expression -> SYMBOL .)
    FOR             reduce using rule 25 (expression -> SYMBOL .)
    IF              reduce using rule 25 (expression -> SYMBOL .)
    WHILE           reduce using rule 25 (expression -> SYMBOL .)
    DEF             reduce using rule 25 (expression -> SYMBOL .)
    CLASS           reduce using rule 25 (expression -> SYMBOL .)
    RETURN          reduce using rule 25 (expression -> SYMBOL .)
    RBRACE          reduce using rule 25 (expression -> SYMBOL .)


state 23

    (26) expression -> REGEXP .

    RANGE_INCLUSIVE reduce using rule 26 (expression -> REGEXP .)
    RANGE_EXCLUSIVE reduce using rule 26 (expression -> REGEXP .)
    DOT             reduce using rule 26 (expression -> REGEXP .)
    PLUS            reduce using rule 26 (expression -> REGEXP .)
    MINUS           reduce using rule 26 (expression -> REGEXP .)
    TIMES           reduce using rule 26 (expression -> REGEXP .)
    DIVIDE          reduce using rule 26 (expression -> REGEXP .)
    MODULE_OP       reduce using rule 26 (expression -> REGEXP .)
    POWER           reduce using rule 26 (expression -> REGEXP .)
    NEWLINE         reduce using rule 26 (expression -> REGEXP .)
    SEMICOLON       reduce using rule 26 (expression -> REGEXP .)
    $end            reduce using rule 26 (expression -> REGEXP .)
    COMMA           reduce using rule 26 (expression -> REGEXP .)
    END             reduce using rule 26 (expression -> REGEXP .)
    ELSIF           reduce using rule 26 (expression -> REGEXP .)
    ELSE            reduce using rule 26 (expression -> REGEXP .)
    RBRACKET        reduce using rule 26 (expression -> REGEXP .)
    RPAREN          reduce using rule 26 (expression -> REGEXP .)
    HASH_ROCKET     reduce using rule 26 (expression -> REGEXP .)
    EQUAL           reduce using rule 26 (expression -> REGEXP .)
    NOT_EQUAL       reduce using rule 26 (expression -> REGEXP .)
    GREATER         reduce using rule 26 (expression -> REGEXP .)
    LESS            reduce using rule 26 (expression -> REGEXP .)
    GREATER_EQUAL   reduce using rule 26 (expression -> REGEXP .)
    LESS_EQUAL      reduce using rule 26 (expression -> REGEXP .)
    SPACESHIP       reduce using rule 26 (expression -> REGEXP .)
    CASE_EQUAL      reduce using rule 26 (expression -> REGEXP .)
    LOGICAL_AND     reduce using rule 26 (expression -> REGEXP .)
    AND             reduce using rule 26 (expression -> REGEXP .)
    LOGICAL_OR      reduce using rule 26 (expression -> REGEXP .)
    OR              reduce using rule 26 (expression -> REGEXP .)
    BREAK           reduce using rule 26 (expression -> REGEXP .)
    NEXT            reduce using rule 26 (expression -> REGEXP .)
    INTEGER         reduce using rule 26 (expression -> REGEXP .)
    FLOAT           reduce using rule 26 (expression -> REGEXP .)
    STRING          reduce using rule 26 (expression -> REGEXP .)
    SYMBOL          reduce using rule 26 (expression -> REGEXP .)
    REGEXP          reduce using rule 26 (expression -> REGEXP .)
    TRUE            reduce using rule 26 (expression -> REGEXP .)
    FALSE           reduce using rule 26 (expression -> REGEXP .)
    NIL             reduce using rule 26 (expression -> REGEXP .)
    IDENTIFIER      reduce using rule 26 (expression -> REGEXP .)
    INSTANCE_VARIABLE reduce using rule 26 (expression -> REGEXP .)
    CLASS_VARIABLE  reduce using rule 26 (expression -> REGEXP .)
    GLOBAL_VARIABLE reduce using rule 26 (expression -> REGEXP .)
    CONSTANT        reduce using rule 26 (expression -> REGEXP .)
    LPAREN          reduce using rule 26 (expression -> REGEXP .)
    LBRACE          reduce using rule 26 (expression -> REGEXP .)
    LBRACKET        reduce using rule 26 (expression -> REGEXP .)
    PUTS            reduce using rule 26 (expression -> REGEXP .)
    FOR             reduce using rule 26 (expression -> REGEXP .)
    IF              reduce using rule 26 (expression -> REGEXP .)
    WHILE           reduce using rule 26 (expression -> REGEXP .)
    DEF             reduce using rule 26 (expression -> REGEXP .)
    CLASS           reduce using rule 26 (expression -> REGEXP .)
    RETURN          reduce using rule 26 (expression -> REGEXP .)
    RBRACE          reduce using rule 26 (expression -> REGEXP .)


state 24

    (27) expression -> TRUE .

    RANGE_INCLUSIVE reduce using rule 27 (expression -> TRUE .)
    RANGE_EXCLUSIVE reduce using rule 27 (expression -> TRUE .)
    DOT             reduce using rule 27 (expression -> TRUE .)
    PLUS            reduce using rule 27 (expression -> TRUE .)
    MINUS           reduce using rule 27 (expression -> TRUE .)
    TIMES           reduce using rule 27 (expression -> TRUE .)
    DIVIDE          reduce using rule 27 (expression -> TRUE .)
    MODULE_OP       reduce using rule 27 (expression -> TRUE .)
    POWER           reduce using rule 27 (expression -> TRUE .)
    NEWLINE         reduce using rule 27 (expression -> TRUE .)
    SEMICOLON       reduce using rule 27 (expression -> TRUE .)
    $end            reduce using rule 27 (expression -> TRUE .)
    COMMA           reduce using rule 27 (expression -> TRUE .)
    END             reduce using rule 27 (expression -> TRUE .)
    ELSIF           reduce using rule 27 (expression -> TRUE .)
    ELSE            reduce using rule 27 (expression -> TRUE .)
    RBRACKET        reduce using rule 27 (expression -> TRUE .)
    RPAREN          reduce using rule 27 (expression -> TRUE .)
    HASH_ROCKET     reduce using rule 27 (expression -> TRUE .)
    EQUAL           reduce using rule 27 (expression -> TRUE .)
    NOT_EQUAL       reduce using rule 27 (expression -> TRUE .)
    GREATER         reduce using rule 27 (expression -> TRUE .)
    LESS            reduce using rule 27 (expression -> TRUE .)
    GREATER_EQUAL   reduce using rule 27 (expression -> TRUE .)
    LESS_EQUAL      reduce using rule 27 (expression -> TRUE .)
    SPACESHIP       reduce using rule 27 (expression -> TRUE .)
    CASE_EQUAL      reduce using rule 27 (expression -> TRUE .)
    LOGICAL_AND     reduce using rule 27 (expression -> TRUE .)
    AND             reduce using rule 27 (expression -> TRUE .)
    LOGICAL_OR      reduce using rule 27 (expression -> TRUE .)
    OR              reduce using rule 27 (expression -> TRUE .)
    BREAK           reduce using rule 27 (expression -> TRUE .)
    NEXT            reduce using rule 27 (expression -> TRUE .)
    INTEGER         reduce using rule 27 (expression -> TRUE .)
    FLOAT           reduce using rule 27 (expression -> TRUE .)
    STRING          reduce using rule 27 (expression -> TRUE .)
    SYMBOL          reduce using rule 27 (expression -> TRUE .)
    REGEXP          reduce using rule 27 (expression -> TRUE .)
    TRUE            reduce using rule 27 (expression -> TRUE .)
    FALSE           reduce using rule 27 (expression -> TRUE .)
    NIL             reduce using rule 27 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 27 (expression -> TRUE .)
    INSTANCE_VARIABLE reduce using rule 27 (expression -> TRUE .)
    CLASS_VARIABLE  reduce using rule 27 (expression -> TRUE .)
    GLOBAL_VARIABLE reduce using rule 27 (expression -> TRUE .)
    CONSTANT        reduce using rule 27 (expression -> TRUE .)
    LPAREN          reduce using rule 27 (expression -> TRUE .)
    LBRACE          reduce using rule 27 (expression -> TRUE .)
    LBRACKET        reduce using rule 27 (expression -> TRUE .)
    PUTS            reduce using rule 27 (expression -> TRUE .)
    FOR             reduce using rule 27 (expression -> TRUE .)
    IF              reduce using rule 27 (expression -> TRUE .)
    WHILE           reduce using rule 27 (expression -> TRUE .)
    DEF             reduce using rule 27 (expression -> TRUE .)
    CLASS           reduce using rule 27 (expression -> TRUE .)
    RETURN          reduce using rule 27 (expression -> TRUE .)
    RBRACE          reduce using rule 27 (expression -> TRUE .)


state 25

    (28) expression -> FALSE .

    RANGE_INCLUSIVE reduce using rule 28 (expression -> FALSE .)
    RANGE_EXCLUSIVE reduce using rule 28 (expression -> FALSE .)
    DOT             reduce using rule 28 (expression -> FALSE .)
    PLUS            reduce using rule 28 (expression -> FALSE .)
    MINUS           reduce using rule 28 (expression -> FALSE .)
    TIMES           reduce using rule 28 (expression -> FALSE .)
    DIVIDE          reduce using rule 28 (expression -> FALSE .)
    MODULE_OP       reduce using rule 28 (expression -> FALSE .)
    POWER           reduce using rule 28 (expression -> FALSE .)
    NEWLINE         reduce using rule 28 (expression -> FALSE .)
    SEMICOLON       reduce using rule 28 (expression -> FALSE .)
    $end            reduce using rule 28 (expression -> FALSE .)
    COMMA           reduce using rule 28 (expression -> FALSE .)
    END             reduce using rule 28 (expression -> FALSE .)
    ELSIF           reduce using rule 28 (expression -> FALSE .)
    ELSE            reduce using rule 28 (expression -> FALSE .)
    RBRACKET        reduce using rule 28 (expression -> FALSE .)
    RPAREN          reduce using rule 28 (expression -> FALSE .)
    HASH_ROCKET     reduce using rule 28 (expression -> FALSE .)
    EQUAL           reduce using rule 28 (expression -> FALSE .)
    NOT_EQUAL       reduce using rule 28 (expression -> FALSE .)
    GREATER         reduce using rule 28 (expression -> FALSE .)
    LESS            reduce using rule 28 (expression -> FALSE .)
    GREATER_EQUAL   reduce using rule 28 (expression -> FALSE .)
    LESS_EQUAL      reduce using rule 28 (expression -> FALSE .)
    SPACESHIP       reduce using rule 28 (expression -> FALSE .)
    CASE_EQUAL      reduce using rule 28 (expression -> FALSE .)
    LOGICAL_AND     reduce using rule 28 (expression -> FALSE .)
    AND             reduce using rule 28 (expression -> FALSE .)
    LOGICAL_OR      reduce using rule 28 (expression -> FALSE .)
    OR              reduce using rule 28 (expression -> FALSE .)
    BREAK           reduce using rule 28 (expression -> FALSE .)
    NEXT            reduce using rule 28 (expression -> FALSE .)
    INTEGER         reduce using rule 28 (expression -> FALSE .)
    FLOAT           reduce using rule 28 (expression -> FALSE .)
    STRING          reduce using rule 28 (expression -> FALSE .)
    SYMBOL          reduce using rule 28 (expression -> FALSE .)
    REGEXP          reduce using rule 28 (expression -> FALSE .)
    TRUE            reduce using rule 28 (expression -> FALSE .)
    FALSE           reduce using rule 28 (expression -> FALSE .)
    NIL             reduce using rule 28 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 28 (expression -> FALSE .)
    INSTANCE_VARIABLE reduce using rule 28 (expression -> FALSE .)
    CLASS_VARIABLE  reduce using rule 28 (expression -> FALSE .)
    GLOBAL_VARIABLE reduce using rule 28 (expression -> FALSE .)
    CONSTANT        reduce using rule 28 (expression -> FALSE .)
    LPAREN          reduce using rule 28 (expression -> FALSE .)
    LBRACE          reduce using rule 28 (expression -> FALSE .)
    LBRACKET        reduce using rule 28 (expression -> FALSE .)
    PUTS            reduce using rule 28 (expression -> FALSE .)
    FOR             reduce using rule 28 (expression -> FALSE .)
    IF              reduce using rule 28 (expression -> FALSE .)
    WHILE           reduce using rule 28 (expression -> FALSE .)
    DEF             reduce using rule 28 (expression -> FALSE .)
    CLASS           reduce using rule 28 (expression -> FALSE .)
    RETURN          reduce using rule 28 (expression -> FALSE .)
    RBRACE          reduce using rule 28 (expression -> FALSE .)


state 26

    (29) expression -> NIL .

    RANGE_INCLUSIVE reduce using rule 29 (expression -> NIL .)
    RANGE_EXCLUSIVE reduce using rule 29 (expression -> NIL .)
    DOT             reduce using rule 29 (expression -> NIL .)
    PLUS            reduce using rule 29 (expression -> NIL .)
    MINUS           reduce using rule 29 (expression -> NIL .)
    TIMES           reduce using rule 29 (expression -> NIL .)
    DIVIDE          reduce using rule 29 (expression -> NIL .)
    MODULE_OP       reduce using rule 29 (expression -> NIL .)
    POWER           reduce using rule 29 (expression -> NIL .)
    NEWLINE         reduce using rule 29 (expression -> NIL .)
    SEMICOLON       reduce using rule 29 (expression -> NIL .)
    $end            reduce using rule 29 (expression -> NIL .)
    COMMA           reduce using rule 29 (expression -> NIL .)
    END             reduce using rule 29 (expression -> NIL .)
    ELSIF           reduce using rule 29 (expression -> NIL .)
    ELSE            reduce using rule 29 (expression -> NIL .)
    RBRACKET        reduce using rule 29 (expression -> NIL .)
    RPAREN          reduce using rule 29 (expression -> NIL .)
    HASH_ROCKET     reduce using rule 29 (expression -> NIL .)
    EQUAL           reduce using rule 29 (expression -> NIL .)
    NOT_EQUAL       reduce using rule 29 (expression -> NIL .)
    GREATER         reduce using rule 29 (expression -> NIL .)
    LESS            reduce using rule 29 (expression -> NIL .)
    GREATER_EQUAL   reduce using rule 29 (expression -> NIL .)
    LESS_EQUAL      reduce using rule 29 (expression -> NIL .)
    SPACESHIP       reduce using rule 29 (expression -> NIL .)
    CASE_EQUAL      reduce using rule 29 (expression -> NIL .)
    LOGICAL_AND     reduce using rule 29 (expression -> NIL .)
    AND             reduce using rule 29 (expression -> NIL .)
    LOGICAL_OR      reduce using rule 29 (expression -> NIL .)
    OR              reduce using rule 29 (expression -> NIL .)
    BREAK           reduce using rule 29 (expression -> NIL .)
    NEXT            reduce using rule 29 (expression -> NIL .)
    INTEGER         reduce using rule 29 (expression -> NIL .)
    FLOAT           reduce using rule 29 (expression -> NIL .)
    STRING          reduce using rule 29 (expression -> NIL .)
    SYMBOL          reduce using rule 29 (expression -> NIL .)
    REGEXP          reduce using rule 29 (expression -> NIL .)
    TRUE            reduce using rule 29 (expression -> NIL .)
    FALSE           reduce using rule 29 (expression -> NIL .)
    NIL             reduce using rule 29 (expression -> NIL .)
    IDENTIFIER      reduce using rule 29 (expression -> NIL .)
    INSTANCE_VARIABLE reduce using rule 29 (expression -> NIL .)
    CLASS_VARIABLE  reduce using rule 29 (expression -> NIL .)
    GLOBAL_VARIABLE reduce using rule 29 (expression -> NIL .)
    CONSTANT        reduce using rule 29 (expression -> NIL .)
    LPAREN          reduce using rule 29 (expression -> NIL .)
    LBRACE          reduce using rule 29 (expression -> NIL .)
    LBRACKET        reduce using rule 29 (expression -> NIL .)
    PUTS            reduce using rule 29 (expression -> NIL .)
    FOR             reduce using rule 29 (expression -> NIL .)
    IF              reduce using rule 29 (expression -> NIL .)
    WHILE           reduce using rule 29 (expression -> NIL .)
    DEF             reduce using rule 29 (expression -> NIL .)
    CLASS           reduce using rule 29 (expression -> NIL .)
    RETURN          reduce using rule 29 (expression -> NIL .)
    RBRACE          reduce using rule 29 (expression -> NIL .)


state 27

    (30) expression -> IDENTIFIER .
    (37) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (106) expression -> IDENTIFIER . LPAREN arguments RPAREN
    (107) expression -> IDENTIFIER . LPAREN RPAREN
    (108) expression -> IDENTIFIER . arguments
    (41) assignment -> IDENTIFIER . ASSIGN expression
    (74) io_statement -> IDENTIFIER . ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> IDENTIFIER . ASSIGN GETS
    (47) assignment_array -> IDENTIFIER . LBRACKET expression RBRACKET
    (109) arguments -> . arguments COMMA expression
    (110) arguments -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

  ! shift/reduce conflict for MINUS resolved as shift
    RANGE_INCLUSIVE reduce using rule 30 (expression -> IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 30 (expression -> IDENTIFIER .)
    DOT             reduce using rule 30 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 30 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 30 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 30 (expression -> IDENTIFIER .)
    MODULE_OP       reduce using rule 30 (expression -> IDENTIFIER .)
    POWER           reduce using rule 30 (expression -> IDENTIFIER .)
    NEWLINE         reduce using rule 30 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 30 (expression -> IDENTIFIER .)
    $end            reduce using rule 30 (expression -> IDENTIFIER .)
    END             reduce using rule 30 (expression -> IDENTIFIER .)
    ELSIF           reduce using rule 30 (expression -> IDENTIFIER .)
    ELSE            reduce using rule 30 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 58
    LPAREN          shift and go to state 60
    ASSIGN          shift and go to state 62
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35

  ! MINUS           [ reduce using rule 30 (expression -> IDENTIFIER .) ]

    expression                     shift and go to state 59
    arguments                      shift and go to state 61

state 28

    (31) expression -> INSTANCE_VARIABLE .
    (42) assignment -> INSTANCE_VARIABLE . ASSIGN expression

    RANGE_INCLUSIVE reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    RANGE_EXCLUSIVE reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    DOT             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    PLUS            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    MINUS           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    TIMES           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    DIVIDE          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    MODULE_OP       reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    POWER           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    NEWLINE         reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    SEMICOLON       reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    $end            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    END             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    ELSIF           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    ELSE            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    ASSIGN          shift and go to state 67


state 29

    (32) expression -> CLASS_VARIABLE .
    (43) assignment -> CLASS_VARIABLE . ASSIGN expression

    RANGE_INCLUSIVE reduce using rule 32 (expression -> CLASS_VARIABLE .)
    RANGE_EXCLUSIVE reduce using rule 32 (expression -> CLASS_VARIABLE .)
    DOT             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    PLUS            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    MINUS           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    TIMES           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    DIVIDE          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    MODULE_OP       reduce using rule 32 (expression -> CLASS_VARIABLE .)
    POWER           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    NEWLINE         reduce using rule 32 (expression -> CLASS_VARIABLE .)
    SEMICOLON       reduce using rule 32 (expression -> CLASS_VARIABLE .)
    $end            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    END             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    ELSIF           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    ELSE            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    ASSIGN          shift and go to state 68


state 30

    (33) expression -> GLOBAL_VARIABLE .
    (44) assignment -> GLOBAL_VARIABLE . ASSIGN expression

    RANGE_INCLUSIVE reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    RANGE_EXCLUSIVE reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    DOT             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    PLUS            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    MINUS           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    TIMES           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    DIVIDE          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    MODULE_OP       reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    POWER           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    NEWLINE         reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    SEMICOLON       reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    $end            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    END             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    ELSIF           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    ELSE            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    ASSIGN          shift and go to state 69


state 31

    (34) expression -> CONSTANT .
    (45) assignment -> CONSTANT . ASSIGN expression

    RANGE_INCLUSIVE reduce using rule 34 (expression -> CONSTANT .)
    RANGE_EXCLUSIVE reduce using rule 34 (expression -> CONSTANT .)
    DOT             reduce using rule 34 (expression -> CONSTANT .)
    PLUS            reduce using rule 34 (expression -> CONSTANT .)
    MINUS           reduce using rule 34 (expression -> CONSTANT .)
    TIMES           reduce using rule 34 (expression -> CONSTANT .)
    DIVIDE          reduce using rule 34 (expression -> CONSTANT .)
    MODULE_OP       reduce using rule 34 (expression -> CONSTANT .)
    POWER           reduce using rule 34 (expression -> CONSTANT .)
    NEWLINE         reduce using rule 34 (expression -> CONSTANT .)
    SEMICOLON       reduce using rule 34 (expression -> CONSTANT .)
    $end            reduce using rule 34 (expression -> CONSTANT .)
    END             reduce using rule 34 (expression -> CONSTANT .)
    ELSIF           reduce using rule 34 (expression -> CONSTANT .)
    ELSE            reduce using rule 34 (expression -> CONSTANT .)
    ASSIGN          shift and go to state 70


state 32

    (91) expression -> LBRACKET . array_elements RBRACKET
    (92) expression -> LBRACKET . RBRACKET
    (93) array_elements -> . array_elements COMMA expression
    (94) array_elements -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    RBRACKET        shift and go to state 72
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    array_elements                 shift and go to state 71
    expression                     shift and go to state 73

state 33

    (54) expression -> LPAREN . expression RPAREN
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 74

state 34

    (55) expression -> MINUS . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 75

state 35

    (67) expression -> LBRACE . hash_pairs RBRACE
    (68) expression -> LBRACE . RBRACE
    (69) hash_pairs -> . hash_pairs COMMA hash_pair
    (70) hash_pairs -> . hash_pair
    (71) hash_pair -> . expression HASH_ROCKET expression
    (72) hash_pair -> . SYMBOL HASH_ROCKET expression
    (73) hash_pair -> . STRING HASH_ROCKET expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    RBRACE          shift and go to state 77
    SYMBOL          shift and go to state 80
    STRING          shift and go to state 81
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    hash_pairs                     shift and go to state 76
    hash_pair                      shift and go to state 78
    expression                     shift and go to state 79

state 36

    (46) assignment -> assignment_array . ASSIGN expression

    ASSIGN          shift and go to state 82


state 37

    (95) io_statement -> PUTS . expression
    (96) io_statement -> PUTS .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    NEWLINE         reduce using rule 96 (io_statement -> PUTS .)
    SEMICOLON       reduce using rule 96 (io_statement -> PUTS .)
    $end            reduce using rule 96 (io_statement -> PUTS .)
    END             reduce using rule 96 (io_statement -> PUTS .)
    ELSIF           reduce using rule 96 (io_statement -> PUTS .)
    ELSE            reduce using rule 96 (io_statement -> PUTS .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 83

state 38

    (97) control_statement -> FOR . for_setup statements optional_newlines exit_scope END
    (98) for_setup -> . IDENTIFIER IN expression enter_loop_scope

    IDENTIFIER      shift and go to state 85

    for_setup                      shift and go to state 84

state 39

    (99) control_statement -> IF . condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> IF . condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> IF . condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> IF . condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 86
    expression                     shift and go to state 87

state 40

    (105) control_statement -> WHILE . condition enter_loop_scope statements optional_newlines exit_scope END
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 90
    expression                     shift and go to state 87

state 41

    (62) function_definition -> DEF . func_name_hook func_header statements optional_newlines exit_scope END
    (63) func_name_hook -> . IDENTIFIER

    IDENTIFIER      shift and go to state 92

    func_name_hook                 shift and go to state 91

state 42

    (56) class_definition -> CLASS . CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> CLASS . CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END

    CONSTANT        shift and go to state 93


state 43

    (60) return_statement -> RETURN . expression
    (61) return_statement -> RETURN .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    NEWLINE         reduce using rule 61 (return_statement -> RETURN .)
    SEMICOLON       reduce using rule 61 (return_statement -> RETURN .)
    $end            reduce using rule 61 (return_statement -> RETURN .)
    END             reduce using rule 61 (return_statement -> RETURN .)
    ELSIF           reduce using rule 61 (return_statement -> RETURN .)
    ELSE            reduce using rule 61 (return_statement -> RETURN .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 94

state 44

    (11) statement_separator -> statement_separator NEWLINE .

    NEWLINE         reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    SEMICOLON       reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    BREAK           reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    NEXT            reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    INTEGER         reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    FLOAT           reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    STRING          reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    SYMBOL          reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    REGEXP          reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    TRUE            reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    FALSE           reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    NIL             reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    IDENTIFIER      reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    INSTANCE_VARIABLE reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    CLASS_VARIABLE  reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    GLOBAL_VARIABLE reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    CONSTANT        reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    LPAREN          reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    MINUS           reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    LBRACE          reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    LBRACKET        reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    PUTS            reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    FOR             reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    IF              reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    WHILE           reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    DEF             reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    CLASS           reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    RETURN          reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    $end            reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    END             reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    ELSE            reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)
    ELSIF           reduce using rule 11 (statement_separator -> statement_separator NEWLINE .)


state 45

    (12) statement_separator -> statement_separator SEMICOLON .

    NEWLINE         reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    SEMICOLON       reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    BREAK           reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    NEXT            reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    INTEGER         reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    FLOAT           reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    STRING          reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    SYMBOL          reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    REGEXP          reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    TRUE            reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    FALSE           reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    NIL             reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    INSTANCE_VARIABLE reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    CLASS_VARIABLE  reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    GLOBAL_VARIABLE reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    CONSTANT        reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    LPAREN          reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    MINUS           reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    LBRACE          reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    LBRACKET        reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    PUTS            reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    FOR             reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    IF              reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    WHILE           reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    DEF             reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    CLASS           reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    RETURN          reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    $end            reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    END             reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    ELSE            reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)
    ELSIF           reduce using rule 12 (statement_separator -> statement_separator SEMICOLON .)


state 46

    (5) program -> optional_newlines statements optional_newlines .

    $end            reduce using rule 5 (program -> optional_newlines statements optional_newlines .)


state 47

    (6) statements -> statements statement_separator . statement
    (13) optional_newlines -> statement_separator .
    (11) statement_separator -> statement_separator . NEWLINE
    (12) statement_separator -> statement_separator . SEMICOLON
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
    $end            reduce using rule 13 (optional_newlines -> statement_separator .)
    END             reduce using rule 13 (optional_newlines -> statement_separator .)
    ELSE            reduce using rule 13 (optional_newlines -> statement_separator .)
    ELSIF           reduce using rule 13 (optional_newlines -> statement_separator .)
    NEWLINE         shift and go to state 44
    SEMICOLON       shift and go to state 45
    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

  ! NEWLINE         [ reduce using rule 13 (optional_newlines -> statement_separator .) ]
  ! SEMICOLON       [ reduce using rule 13 (optional_newlines -> statement_separator .) ]

    statement                      shift and go to state 95
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 48

    (35) expression -> expression RANGE_INCLUSIVE . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 96

state 49

    (36) expression -> expression RANGE_EXCLUSIVE . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 97

state 50

    (38) expression -> expression DOT . IDENTIFIER
    (39) expression -> expression DOT . IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression DOT . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 98


state 51

    (48) expression -> expression PLUS . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 99

state 52

    (49) expression -> expression MINUS . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 100

state 53

    (50) expression -> expression TIMES . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 101

state 54

    (51) expression -> expression DIVIDE . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 102

state 55

    (52) expression -> expression MODULE_OP . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 103

state 56

    (53) expression -> expression POWER . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 104

state 57

    (30) expression -> IDENTIFIER .
    (37) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (106) expression -> IDENTIFIER . LPAREN arguments RPAREN
    (107) expression -> IDENTIFIER . LPAREN RPAREN
    (108) expression -> IDENTIFIER . arguments
    (109) arguments -> . arguments COMMA expression
    (110) arguments -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INSTANCE_VARIABLE resolved as shift
  ! shift/reduce conflict for CLASS_VARIABLE resolved as shift
  ! shift/reduce conflict for GLOBAL_VARIABLE resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
    COMMA           reduce using rule 30 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 30 (expression -> IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 30 (expression -> IDENTIFIER .)
    DOT             reduce using rule 30 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 30 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 30 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 30 (expression -> IDENTIFIER .)
    MODULE_OP       reduce using rule 30 (expression -> IDENTIFIER .)
    POWER           reduce using rule 30 (expression -> IDENTIFIER .)
    NEWLINE         reduce using rule 30 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 30 (expression -> IDENTIFIER .)
    $end            reduce using rule 30 (expression -> IDENTIFIER .)
    END             reduce using rule 30 (expression -> IDENTIFIER .)
    ELSIF           reduce using rule 30 (expression -> IDENTIFIER .)
    ELSE            reduce using rule 30 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 30 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 30 (expression -> IDENTIFIER .)
    HASH_ROCKET     reduce using rule 30 (expression -> IDENTIFIER .)
    EQUAL           reduce using rule 30 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 30 (expression -> IDENTIFIER .)
    GREATER         reduce using rule 30 (expression -> IDENTIFIER .)
    LESS            reduce using rule 30 (expression -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 30 (expression -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 30 (expression -> IDENTIFIER .)
    SPACESHIP       reduce using rule 30 (expression -> IDENTIFIER .)
    CASE_EQUAL      reduce using rule 30 (expression -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 30 (expression -> IDENTIFIER .)
    AND             reduce using rule 30 (expression -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 30 (expression -> IDENTIFIER .)
    OR              reduce using rule 30 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 30 (expression -> IDENTIFIER .)
    NEXT            reduce using rule 30 (expression -> IDENTIFIER .)
    PUTS            reduce using rule 30 (expression -> IDENTIFIER .)
    FOR             reduce using rule 30 (expression -> IDENTIFIER .)
    IF              reduce using rule 30 (expression -> IDENTIFIER .)
    WHILE           reduce using rule 30 (expression -> IDENTIFIER .)
    DEF             reduce using rule 30 (expression -> IDENTIFIER .)
    CLASS           reduce using rule 30 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 30 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 30 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 105
    LPAREN          shift and go to state 60
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35

  ! MINUS           [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! INTEGER         [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! FLOAT           [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! STRING          [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! SYMBOL          [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! REGEXP          [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! TRUE            [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! FALSE           [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! NIL             [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! CLASS_VARIABLE  [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! CONSTANT        [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! LBRACE          [ reduce using rule 30 (expression -> IDENTIFIER .) ]
  ! LBRACKET        [ reduce using rule 30 (expression -> IDENTIFIER .) ]

    expression                     shift and go to state 59
    arguments                      shift and go to state 61

state 58

    (37) expression -> IDENTIFIER LBRACKET . expression RBRACKET
    (47) assignment_array -> IDENTIFIER LBRACKET . expression RBRACKET
    (91) expression -> LBRACKET . array_elements RBRACKET
    (92) expression -> LBRACKET . RBRACKET
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (93) array_elements -> . array_elements COMMA expression
    (94) array_elements -> . expression

    RBRACKET        shift and go to state 72
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 106
    array_elements                 shift and go to state 71

state 59

    (110) arguments -> expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    COMMA           reduce using rule 110 (arguments -> expression .)
    NEWLINE         reduce using rule 110 (arguments -> expression .)
    SEMICOLON       reduce using rule 110 (arguments -> expression .)
    $end            reduce using rule 110 (arguments -> expression .)
    END             reduce using rule 110 (arguments -> expression .)
    ELSIF           reduce using rule 110 (arguments -> expression .)
    ELSE            reduce using rule 110 (arguments -> expression .)
    RBRACKET        reduce using rule 110 (arguments -> expression .)
    RPAREN          reduce using rule 110 (arguments -> expression .)
    HASH_ROCKET     reduce using rule 110 (arguments -> expression .)
    EQUAL           reduce using rule 110 (arguments -> expression .)
    NOT_EQUAL       reduce using rule 110 (arguments -> expression .)
    GREATER         reduce using rule 110 (arguments -> expression .)
    LESS            reduce using rule 110 (arguments -> expression .)
    GREATER_EQUAL   reduce using rule 110 (arguments -> expression .)
    LESS_EQUAL      reduce using rule 110 (arguments -> expression .)
    SPACESHIP       reduce using rule 110 (arguments -> expression .)
    CASE_EQUAL      reduce using rule 110 (arguments -> expression .)
    LOGICAL_AND     reduce using rule 110 (arguments -> expression .)
    AND             reduce using rule 110 (arguments -> expression .)
    LOGICAL_OR      reduce using rule 110 (arguments -> expression .)
    OR              reduce using rule 110 (arguments -> expression .)
    BREAK           reduce using rule 110 (arguments -> expression .)
    NEXT            reduce using rule 110 (arguments -> expression .)
    INTEGER         reduce using rule 110 (arguments -> expression .)
    FLOAT           reduce using rule 110 (arguments -> expression .)
    STRING          reduce using rule 110 (arguments -> expression .)
    SYMBOL          reduce using rule 110 (arguments -> expression .)
    REGEXP          reduce using rule 110 (arguments -> expression .)
    TRUE            reduce using rule 110 (arguments -> expression .)
    FALSE           reduce using rule 110 (arguments -> expression .)
    NIL             reduce using rule 110 (arguments -> expression .)
    IDENTIFIER      reduce using rule 110 (arguments -> expression .)
    INSTANCE_VARIABLE reduce using rule 110 (arguments -> expression .)
    CLASS_VARIABLE  reduce using rule 110 (arguments -> expression .)
    GLOBAL_VARIABLE reduce using rule 110 (arguments -> expression .)
    CONSTANT        reduce using rule 110 (arguments -> expression .)
    LPAREN          reduce using rule 110 (arguments -> expression .)
    LBRACE          reduce using rule 110 (arguments -> expression .)
    LBRACKET        reduce using rule 110 (arguments -> expression .)
    PUTS            reduce using rule 110 (arguments -> expression .)
    FOR             reduce using rule 110 (arguments -> expression .)
    IF              reduce using rule 110 (arguments -> expression .)
    WHILE           reduce using rule 110 (arguments -> expression .)
    DEF             reduce using rule 110 (arguments -> expression .)
    CLASS           reduce using rule 110 (arguments -> expression .)
    RETURN          reduce using rule 110 (arguments -> expression .)
    RBRACE          reduce using rule 110 (arguments -> expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! RANGE_INCLUSIVE [ reduce using rule 110 (arguments -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 110 (arguments -> expression .) ]
  ! DOT             [ reduce using rule 110 (arguments -> expression .) ]
  ! PLUS            [ reduce using rule 110 (arguments -> expression .) ]
  ! MINUS           [ reduce using rule 110 (arguments -> expression .) ]
  ! TIMES           [ reduce using rule 110 (arguments -> expression .) ]
  ! DIVIDE          [ reduce using rule 110 (arguments -> expression .) ]
  ! MODULE_OP       [ reduce using rule 110 (arguments -> expression .) ]
  ! POWER           [ reduce using rule 110 (arguments -> expression .) ]


state 60

    (106) expression -> IDENTIFIER LPAREN . arguments RPAREN
    (107) expression -> IDENTIFIER LPAREN . RPAREN
    (54) expression -> LPAREN . expression RPAREN
    (109) arguments -> . arguments COMMA expression
    (110) arguments -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    RPAREN          shift and go to state 108
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    arguments                      shift and go to state 107
    expression                     shift and go to state 109

state 61

    (108) expression -> IDENTIFIER arguments .
    (109) arguments -> arguments . COMMA expression

  ! shift/reduce conflict for COMMA resolved as shift
    RANGE_INCLUSIVE reduce using rule 108 (expression -> IDENTIFIER arguments .)
    RANGE_EXCLUSIVE reduce using rule 108 (expression -> IDENTIFIER arguments .)
    DOT             reduce using rule 108 (expression -> IDENTIFIER arguments .)
    PLUS            reduce using rule 108 (expression -> IDENTIFIER arguments .)
    MINUS           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    TIMES           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    DIVIDE          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    MODULE_OP       reduce using rule 108 (expression -> IDENTIFIER arguments .)
    POWER           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    NEWLINE         reduce using rule 108 (expression -> IDENTIFIER arguments .)
    SEMICOLON       reduce using rule 108 (expression -> IDENTIFIER arguments .)
    $end            reduce using rule 108 (expression -> IDENTIFIER arguments .)
    END             reduce using rule 108 (expression -> IDENTIFIER arguments .)
    ELSIF           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    ELSE            reduce using rule 108 (expression -> IDENTIFIER arguments .)
    RBRACKET        reduce using rule 108 (expression -> IDENTIFIER arguments .)
    RPAREN          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    HASH_ROCKET     reduce using rule 108 (expression -> IDENTIFIER arguments .)
    EQUAL           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    NOT_EQUAL       reduce using rule 108 (expression -> IDENTIFIER arguments .)
    GREATER         reduce using rule 108 (expression -> IDENTIFIER arguments .)
    LESS            reduce using rule 108 (expression -> IDENTIFIER arguments .)
    GREATER_EQUAL   reduce using rule 108 (expression -> IDENTIFIER arguments .)
    LESS_EQUAL      reduce using rule 108 (expression -> IDENTIFIER arguments .)
    SPACESHIP       reduce using rule 108 (expression -> IDENTIFIER arguments .)
    CASE_EQUAL      reduce using rule 108 (expression -> IDENTIFIER arguments .)
    LOGICAL_AND     reduce using rule 108 (expression -> IDENTIFIER arguments .)
    AND             reduce using rule 108 (expression -> IDENTIFIER arguments .)
    LOGICAL_OR      reduce using rule 108 (expression -> IDENTIFIER arguments .)
    OR              reduce using rule 108 (expression -> IDENTIFIER arguments .)
    BREAK           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    NEXT            reduce using rule 108 (expression -> IDENTIFIER arguments .)
    INTEGER         reduce using rule 108 (expression -> IDENTIFIER arguments .)
    FLOAT           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    STRING          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    SYMBOL          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    REGEXP          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    TRUE            reduce using rule 108 (expression -> IDENTIFIER arguments .)
    FALSE           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    NIL             reduce using rule 108 (expression -> IDENTIFIER arguments .)
    IDENTIFIER      reduce using rule 108 (expression -> IDENTIFIER arguments .)
    INSTANCE_VARIABLE reduce using rule 108 (expression -> IDENTIFIER arguments .)
    CLASS_VARIABLE  reduce using rule 108 (expression -> IDENTIFIER arguments .)
    GLOBAL_VARIABLE reduce using rule 108 (expression -> IDENTIFIER arguments .)
    CONSTANT        reduce using rule 108 (expression -> IDENTIFIER arguments .)
    LPAREN          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    LBRACE          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    LBRACKET        reduce using rule 108 (expression -> IDENTIFIER arguments .)
    PUTS            reduce using rule 108 (expression -> IDENTIFIER arguments .)
    FOR             reduce using rule 108 (expression -> IDENTIFIER arguments .)
    IF              reduce using rule 108 (expression -> IDENTIFIER arguments .)
    WHILE           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    DEF             reduce using rule 108 (expression -> IDENTIFIER arguments .)
    CLASS           reduce using rule 108 (expression -> IDENTIFIER arguments .)
    RETURN          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    RBRACE          reduce using rule 108 (expression -> IDENTIFIER arguments .)
    COMMA           shift and go to state 110

  ! COMMA           [ reduce using rule 108 (expression -> IDENTIFIER arguments .) ]


state 62

    (41) assignment -> IDENTIFIER ASSIGN . expression
    (74) io_statement -> IDENTIFIER ASSIGN . GETS DOT IDENTIFIER
    (75) io_statement -> IDENTIFIER ASSIGN . GETS
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    GETS            shift and go to state 112
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 111

state 63

    (31) expression -> INSTANCE_VARIABLE .

    COMMA           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    RANGE_INCLUSIVE reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    RANGE_EXCLUSIVE reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    DOT             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    PLUS            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    MINUS           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    TIMES           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    DIVIDE          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    MODULE_OP       reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    POWER           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    NEWLINE         reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    SEMICOLON       reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    $end            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    END             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    ELSIF           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    ELSE            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    RBRACKET        reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    RPAREN          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    HASH_ROCKET     reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    EQUAL           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    NOT_EQUAL       reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    GREATER         reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    LESS            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    GREATER_EQUAL   reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    LESS_EQUAL      reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    SPACESHIP       reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    CASE_EQUAL      reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    LOGICAL_AND     reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    AND             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    LOGICAL_OR      reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    OR              reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    BREAK           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    NEXT            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    INTEGER         reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    FLOAT           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    STRING          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    SYMBOL          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    REGEXP          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    TRUE            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    FALSE           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    NIL             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    IDENTIFIER      reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    INSTANCE_VARIABLE reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    CLASS_VARIABLE  reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    GLOBAL_VARIABLE reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    CONSTANT        reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    LPAREN          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    LBRACE          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    LBRACKET        reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    PUTS            reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    FOR             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    IF              reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    WHILE           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    DEF             reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    CLASS           reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    RETURN          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)
    RBRACE          reduce using rule 31 (expression -> INSTANCE_VARIABLE .)


state 64

    (32) expression -> CLASS_VARIABLE .

    COMMA           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    RANGE_INCLUSIVE reduce using rule 32 (expression -> CLASS_VARIABLE .)
    RANGE_EXCLUSIVE reduce using rule 32 (expression -> CLASS_VARIABLE .)
    DOT             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    PLUS            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    MINUS           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    TIMES           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    DIVIDE          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    MODULE_OP       reduce using rule 32 (expression -> CLASS_VARIABLE .)
    POWER           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    NEWLINE         reduce using rule 32 (expression -> CLASS_VARIABLE .)
    SEMICOLON       reduce using rule 32 (expression -> CLASS_VARIABLE .)
    $end            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    END             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    ELSIF           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    ELSE            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    RBRACKET        reduce using rule 32 (expression -> CLASS_VARIABLE .)
    RPAREN          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    HASH_ROCKET     reduce using rule 32 (expression -> CLASS_VARIABLE .)
    EQUAL           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    NOT_EQUAL       reduce using rule 32 (expression -> CLASS_VARIABLE .)
    GREATER         reduce using rule 32 (expression -> CLASS_VARIABLE .)
    LESS            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    GREATER_EQUAL   reduce using rule 32 (expression -> CLASS_VARIABLE .)
    LESS_EQUAL      reduce using rule 32 (expression -> CLASS_VARIABLE .)
    SPACESHIP       reduce using rule 32 (expression -> CLASS_VARIABLE .)
    CASE_EQUAL      reduce using rule 32 (expression -> CLASS_VARIABLE .)
    LOGICAL_AND     reduce using rule 32 (expression -> CLASS_VARIABLE .)
    AND             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    LOGICAL_OR      reduce using rule 32 (expression -> CLASS_VARIABLE .)
    OR              reduce using rule 32 (expression -> CLASS_VARIABLE .)
    BREAK           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    NEXT            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    INTEGER         reduce using rule 32 (expression -> CLASS_VARIABLE .)
    FLOAT           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    STRING          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    SYMBOL          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    REGEXP          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    TRUE            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    FALSE           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    NIL             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    IDENTIFIER      reduce using rule 32 (expression -> CLASS_VARIABLE .)
    INSTANCE_VARIABLE reduce using rule 32 (expression -> CLASS_VARIABLE .)
    CLASS_VARIABLE  reduce using rule 32 (expression -> CLASS_VARIABLE .)
    GLOBAL_VARIABLE reduce using rule 32 (expression -> CLASS_VARIABLE .)
    CONSTANT        reduce using rule 32 (expression -> CLASS_VARIABLE .)
    LPAREN          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    LBRACE          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    LBRACKET        reduce using rule 32 (expression -> CLASS_VARIABLE .)
    PUTS            reduce using rule 32 (expression -> CLASS_VARIABLE .)
    FOR             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    IF              reduce using rule 32 (expression -> CLASS_VARIABLE .)
    WHILE           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    DEF             reduce using rule 32 (expression -> CLASS_VARIABLE .)
    CLASS           reduce using rule 32 (expression -> CLASS_VARIABLE .)
    RETURN          reduce using rule 32 (expression -> CLASS_VARIABLE .)
    RBRACE          reduce using rule 32 (expression -> CLASS_VARIABLE .)


state 65

    (33) expression -> GLOBAL_VARIABLE .

    COMMA           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    RANGE_INCLUSIVE reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    RANGE_EXCLUSIVE reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    DOT             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    PLUS            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    MINUS           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    TIMES           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    DIVIDE          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    MODULE_OP       reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    POWER           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    NEWLINE         reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    SEMICOLON       reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    $end            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    END             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    ELSIF           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    ELSE            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    RBRACKET        reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    RPAREN          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    HASH_ROCKET     reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    EQUAL           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    NOT_EQUAL       reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    GREATER         reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    LESS            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    GREATER_EQUAL   reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    LESS_EQUAL      reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    SPACESHIP       reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    CASE_EQUAL      reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    LOGICAL_AND     reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    AND             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    LOGICAL_OR      reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    OR              reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    BREAK           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    NEXT            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    INTEGER         reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    FLOAT           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    STRING          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    SYMBOL          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    REGEXP          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    TRUE            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    FALSE           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    NIL             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    IDENTIFIER      reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    INSTANCE_VARIABLE reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    CLASS_VARIABLE  reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    GLOBAL_VARIABLE reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    CONSTANT        reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    LPAREN          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    LBRACE          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    LBRACKET        reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    PUTS            reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    FOR             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    IF              reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    WHILE           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    DEF             reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    CLASS           reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    RETURN          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)
    RBRACE          reduce using rule 33 (expression -> GLOBAL_VARIABLE .)


state 66

    (34) expression -> CONSTANT .

    COMMA           reduce using rule 34 (expression -> CONSTANT .)
    RANGE_INCLUSIVE reduce using rule 34 (expression -> CONSTANT .)
    RANGE_EXCLUSIVE reduce using rule 34 (expression -> CONSTANT .)
    DOT             reduce using rule 34 (expression -> CONSTANT .)
    PLUS            reduce using rule 34 (expression -> CONSTANT .)
    MINUS           reduce using rule 34 (expression -> CONSTANT .)
    TIMES           reduce using rule 34 (expression -> CONSTANT .)
    DIVIDE          reduce using rule 34 (expression -> CONSTANT .)
    MODULE_OP       reduce using rule 34 (expression -> CONSTANT .)
    POWER           reduce using rule 34 (expression -> CONSTANT .)
    NEWLINE         reduce using rule 34 (expression -> CONSTANT .)
    SEMICOLON       reduce using rule 34 (expression -> CONSTANT .)
    $end            reduce using rule 34 (expression -> CONSTANT .)
    END             reduce using rule 34 (expression -> CONSTANT .)
    ELSIF           reduce using rule 34 (expression -> CONSTANT .)
    ELSE            reduce using rule 34 (expression -> CONSTANT .)
    RBRACKET        reduce using rule 34 (expression -> CONSTANT .)
    RPAREN          reduce using rule 34 (expression -> CONSTANT .)
    HASH_ROCKET     reduce using rule 34 (expression -> CONSTANT .)
    EQUAL           reduce using rule 34 (expression -> CONSTANT .)
    NOT_EQUAL       reduce using rule 34 (expression -> CONSTANT .)
    GREATER         reduce using rule 34 (expression -> CONSTANT .)
    LESS            reduce using rule 34 (expression -> CONSTANT .)
    GREATER_EQUAL   reduce using rule 34 (expression -> CONSTANT .)
    LESS_EQUAL      reduce using rule 34 (expression -> CONSTANT .)
    SPACESHIP       reduce using rule 34 (expression -> CONSTANT .)
    CASE_EQUAL      reduce using rule 34 (expression -> CONSTANT .)
    LOGICAL_AND     reduce using rule 34 (expression -> CONSTANT .)
    AND             reduce using rule 34 (expression -> CONSTANT .)
    LOGICAL_OR      reduce using rule 34 (expression -> CONSTANT .)
    OR              reduce using rule 34 (expression -> CONSTANT .)
    BREAK           reduce using rule 34 (expression -> CONSTANT .)
    NEXT            reduce using rule 34 (expression -> CONSTANT .)
    INTEGER         reduce using rule 34 (expression -> CONSTANT .)
    FLOAT           reduce using rule 34 (expression -> CONSTANT .)
    STRING          reduce using rule 34 (expression -> CONSTANT .)
    SYMBOL          reduce using rule 34 (expression -> CONSTANT .)
    REGEXP          reduce using rule 34 (expression -> CONSTANT .)
    TRUE            reduce using rule 34 (expression -> CONSTANT .)
    FALSE           reduce using rule 34 (expression -> CONSTANT .)
    NIL             reduce using rule 34 (expression -> CONSTANT .)
    IDENTIFIER      reduce using rule 34 (expression -> CONSTANT .)
    INSTANCE_VARIABLE reduce using rule 34 (expression -> CONSTANT .)
    CLASS_VARIABLE  reduce using rule 34 (expression -> CONSTANT .)
    GLOBAL_VARIABLE reduce using rule 34 (expression -> CONSTANT .)
    CONSTANT        reduce using rule 34 (expression -> CONSTANT .)
    LPAREN          reduce using rule 34 (expression -> CONSTANT .)
    LBRACE          reduce using rule 34 (expression -> CONSTANT .)
    LBRACKET        reduce using rule 34 (expression -> CONSTANT .)
    PUTS            reduce using rule 34 (expression -> CONSTANT .)
    FOR             reduce using rule 34 (expression -> CONSTANT .)
    IF              reduce using rule 34 (expression -> CONSTANT .)
    WHILE           reduce using rule 34 (expression -> CONSTANT .)
    DEF             reduce using rule 34 (expression -> CONSTANT .)
    CLASS           reduce using rule 34 (expression -> CONSTANT .)
    RETURN          reduce using rule 34 (expression -> CONSTANT .)
    RBRACE          reduce using rule 34 (expression -> CONSTANT .)


state 67

    (42) assignment -> INSTANCE_VARIABLE ASSIGN . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 113

state 68

    (43) assignment -> CLASS_VARIABLE ASSIGN . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 114

state 69

    (44) assignment -> GLOBAL_VARIABLE ASSIGN . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 115

state 70

    (45) assignment -> CONSTANT ASSIGN . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 116

state 71

    (91) expression -> LBRACKET array_elements . RBRACKET
    (93) array_elements -> array_elements . COMMA expression

    RBRACKET        shift and go to state 117
    COMMA           shift and go to state 118


state 72

    (92) expression -> LBRACKET RBRACKET .

    RANGE_INCLUSIVE reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    DOT             reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    PLUS            reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    TIMES           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    MODULE_OP       reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    POWER           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    NEWLINE         reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    $end            reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    END             reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    ELSIF           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    ELSE            reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    HASH_ROCKET     reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    EQUAL           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    NOT_EQUAL       reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    GREATER         reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    LESS            reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    GREATER_EQUAL   reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    LESS_EQUAL      reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    SPACESHIP       reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    CASE_EQUAL      reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    LOGICAL_AND     reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    AND             reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    LOGICAL_OR      reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    OR              reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    BREAK           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    NEXT            reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    INTEGER         reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    FLOAT           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    STRING          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    SYMBOL          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    REGEXP          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    TRUE            reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    FALSE           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    NIL             reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    INSTANCE_VARIABLE reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    CLASS_VARIABLE  reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    GLOBAL_VARIABLE reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    CONSTANT        reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    LPAREN          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    LBRACE          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    PUTS            reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    FOR             reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    IF              reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    DEF             reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    CLASS           reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    RETURN          reduce using rule 92 (expression -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 92 (expression -> LBRACKET RBRACKET .)


state 73

    (94) array_elements -> expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RBRACKET        reduce using rule 94 (array_elements -> expression .)
    COMMA           reduce using rule 94 (array_elements -> expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 74

    (54) expression -> LPAREN expression . RPAREN
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RPAREN          shift and go to state 119
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 75

    (55) expression -> MINUS expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RANGE_INCLUSIVE reduce using rule 55 (expression -> MINUS expression .)
    RANGE_EXCLUSIVE reduce using rule 55 (expression -> MINUS expression .)
    DOT             reduce using rule 55 (expression -> MINUS expression .)
    PLUS            reduce using rule 55 (expression -> MINUS expression .)
    MINUS           reduce using rule 55 (expression -> MINUS expression .)
    TIMES           reduce using rule 55 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 55 (expression -> MINUS expression .)
    MODULE_OP       reduce using rule 55 (expression -> MINUS expression .)
    POWER           reduce using rule 55 (expression -> MINUS expression .)
    NEWLINE         reduce using rule 55 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 55 (expression -> MINUS expression .)
    $end            reduce using rule 55 (expression -> MINUS expression .)
    COMMA           reduce using rule 55 (expression -> MINUS expression .)
    END             reduce using rule 55 (expression -> MINUS expression .)
    ELSIF           reduce using rule 55 (expression -> MINUS expression .)
    ELSE            reduce using rule 55 (expression -> MINUS expression .)
    RBRACKET        reduce using rule 55 (expression -> MINUS expression .)
    RPAREN          reduce using rule 55 (expression -> MINUS expression .)
    HASH_ROCKET     reduce using rule 55 (expression -> MINUS expression .)
    EQUAL           reduce using rule 55 (expression -> MINUS expression .)
    NOT_EQUAL       reduce using rule 55 (expression -> MINUS expression .)
    GREATER         reduce using rule 55 (expression -> MINUS expression .)
    LESS            reduce using rule 55 (expression -> MINUS expression .)
    GREATER_EQUAL   reduce using rule 55 (expression -> MINUS expression .)
    LESS_EQUAL      reduce using rule 55 (expression -> MINUS expression .)
    SPACESHIP       reduce using rule 55 (expression -> MINUS expression .)
    CASE_EQUAL      reduce using rule 55 (expression -> MINUS expression .)
    LOGICAL_AND     reduce using rule 55 (expression -> MINUS expression .)
    AND             reduce using rule 55 (expression -> MINUS expression .)
    LOGICAL_OR      reduce using rule 55 (expression -> MINUS expression .)
    OR              reduce using rule 55 (expression -> MINUS expression .)
    BREAK           reduce using rule 55 (expression -> MINUS expression .)
    NEXT            reduce using rule 55 (expression -> MINUS expression .)
    INTEGER         reduce using rule 55 (expression -> MINUS expression .)
    FLOAT           reduce using rule 55 (expression -> MINUS expression .)
    STRING          reduce using rule 55 (expression -> MINUS expression .)
    SYMBOL          reduce using rule 55 (expression -> MINUS expression .)
    REGEXP          reduce using rule 55 (expression -> MINUS expression .)
    TRUE            reduce using rule 55 (expression -> MINUS expression .)
    FALSE           reduce using rule 55 (expression -> MINUS expression .)
    NIL             reduce using rule 55 (expression -> MINUS expression .)
    IDENTIFIER      reduce using rule 55 (expression -> MINUS expression .)
    INSTANCE_VARIABLE reduce using rule 55 (expression -> MINUS expression .)
    CLASS_VARIABLE  reduce using rule 55 (expression -> MINUS expression .)
    GLOBAL_VARIABLE reduce using rule 55 (expression -> MINUS expression .)
    CONSTANT        reduce using rule 55 (expression -> MINUS expression .)
    LPAREN          reduce using rule 55 (expression -> MINUS expression .)
    LBRACE          reduce using rule 55 (expression -> MINUS expression .)
    LBRACKET        reduce using rule 55 (expression -> MINUS expression .)
    PUTS            reduce using rule 55 (expression -> MINUS expression .)
    FOR             reduce using rule 55 (expression -> MINUS expression .)
    IF              reduce using rule 55 (expression -> MINUS expression .)
    WHILE           reduce using rule 55 (expression -> MINUS expression .)
    DEF             reduce using rule 55 (expression -> MINUS expression .)
    CLASS           reduce using rule 55 (expression -> MINUS expression .)
    RETURN          reduce using rule 55 (expression -> MINUS expression .)
    RBRACE          reduce using rule 55 (expression -> MINUS expression .)

  ! RANGE_INCLUSIVE [ shift and go to state 48 ]
  ! RANGE_EXCLUSIVE [ shift and go to state 49 ]
  ! DOT             [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MODULE_OP       [ shift and go to state 55 ]
  ! POWER           [ shift and go to state 56 ]


state 76

    (67) expression -> LBRACE hash_pairs . RBRACE
    (69) hash_pairs -> hash_pairs . COMMA hash_pair

    RBRACE          shift and go to state 120
    COMMA           shift and go to state 121


state 77

    (68) expression -> LBRACE RBRACE .

    RANGE_INCLUSIVE reduce using rule 68 (expression -> LBRACE RBRACE .)
    RANGE_EXCLUSIVE reduce using rule 68 (expression -> LBRACE RBRACE .)
    DOT             reduce using rule 68 (expression -> LBRACE RBRACE .)
    PLUS            reduce using rule 68 (expression -> LBRACE RBRACE .)
    MINUS           reduce using rule 68 (expression -> LBRACE RBRACE .)
    TIMES           reduce using rule 68 (expression -> LBRACE RBRACE .)
    DIVIDE          reduce using rule 68 (expression -> LBRACE RBRACE .)
    MODULE_OP       reduce using rule 68 (expression -> LBRACE RBRACE .)
    POWER           reduce using rule 68 (expression -> LBRACE RBRACE .)
    NEWLINE         reduce using rule 68 (expression -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 68 (expression -> LBRACE RBRACE .)
    $end            reduce using rule 68 (expression -> LBRACE RBRACE .)
    COMMA           reduce using rule 68 (expression -> LBRACE RBRACE .)
    END             reduce using rule 68 (expression -> LBRACE RBRACE .)
    ELSIF           reduce using rule 68 (expression -> LBRACE RBRACE .)
    ELSE            reduce using rule 68 (expression -> LBRACE RBRACE .)
    RBRACKET        reduce using rule 68 (expression -> LBRACE RBRACE .)
    RPAREN          reduce using rule 68 (expression -> LBRACE RBRACE .)
    HASH_ROCKET     reduce using rule 68 (expression -> LBRACE RBRACE .)
    EQUAL           reduce using rule 68 (expression -> LBRACE RBRACE .)
    NOT_EQUAL       reduce using rule 68 (expression -> LBRACE RBRACE .)
    GREATER         reduce using rule 68 (expression -> LBRACE RBRACE .)
    LESS            reduce using rule 68 (expression -> LBRACE RBRACE .)
    GREATER_EQUAL   reduce using rule 68 (expression -> LBRACE RBRACE .)
    LESS_EQUAL      reduce using rule 68 (expression -> LBRACE RBRACE .)
    SPACESHIP       reduce using rule 68 (expression -> LBRACE RBRACE .)
    CASE_EQUAL      reduce using rule 68 (expression -> LBRACE RBRACE .)
    LOGICAL_AND     reduce using rule 68 (expression -> LBRACE RBRACE .)
    AND             reduce using rule 68 (expression -> LBRACE RBRACE .)
    LOGICAL_OR      reduce using rule 68 (expression -> LBRACE RBRACE .)
    OR              reduce using rule 68 (expression -> LBRACE RBRACE .)
    BREAK           reduce using rule 68 (expression -> LBRACE RBRACE .)
    NEXT            reduce using rule 68 (expression -> LBRACE RBRACE .)
    INTEGER         reduce using rule 68 (expression -> LBRACE RBRACE .)
    FLOAT           reduce using rule 68 (expression -> LBRACE RBRACE .)
    STRING          reduce using rule 68 (expression -> LBRACE RBRACE .)
    SYMBOL          reduce using rule 68 (expression -> LBRACE RBRACE .)
    REGEXP          reduce using rule 68 (expression -> LBRACE RBRACE .)
    TRUE            reduce using rule 68 (expression -> LBRACE RBRACE .)
    FALSE           reduce using rule 68 (expression -> LBRACE RBRACE .)
    NIL             reduce using rule 68 (expression -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 68 (expression -> LBRACE RBRACE .)
    INSTANCE_VARIABLE reduce using rule 68 (expression -> LBRACE RBRACE .)
    CLASS_VARIABLE  reduce using rule 68 (expression -> LBRACE RBRACE .)
    GLOBAL_VARIABLE reduce using rule 68 (expression -> LBRACE RBRACE .)
    CONSTANT        reduce using rule 68 (expression -> LBRACE RBRACE .)
    LPAREN          reduce using rule 68 (expression -> LBRACE RBRACE .)
    LBRACE          reduce using rule 68 (expression -> LBRACE RBRACE .)
    LBRACKET        reduce using rule 68 (expression -> LBRACE RBRACE .)
    PUTS            reduce using rule 68 (expression -> LBRACE RBRACE .)
    FOR             reduce using rule 68 (expression -> LBRACE RBRACE .)
    IF              reduce using rule 68 (expression -> LBRACE RBRACE .)
    WHILE           reduce using rule 68 (expression -> LBRACE RBRACE .)
    DEF             reduce using rule 68 (expression -> LBRACE RBRACE .)
    CLASS           reduce using rule 68 (expression -> LBRACE RBRACE .)
    RETURN          reduce using rule 68 (expression -> LBRACE RBRACE .)
    RBRACE          reduce using rule 68 (expression -> LBRACE RBRACE .)


state 78

    (70) hash_pairs -> hash_pair .

    RBRACE          reduce using rule 70 (hash_pairs -> hash_pair .)
    COMMA           reduce using rule 70 (hash_pairs -> hash_pair .)


state 79

    (71) hash_pair -> expression . HASH_ROCKET expression
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    HASH_ROCKET     shift and go to state 122
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 80

    (72) hash_pair -> SYMBOL . HASH_ROCKET expression
    (25) expression -> SYMBOL .

  ! shift/reduce conflict for HASH_ROCKET resolved as shift
    HASH_ROCKET     shift and go to state 123
    RANGE_INCLUSIVE reduce using rule 25 (expression -> SYMBOL .)
    RANGE_EXCLUSIVE reduce using rule 25 (expression -> SYMBOL .)
    DOT             reduce using rule 25 (expression -> SYMBOL .)
    PLUS            reduce using rule 25 (expression -> SYMBOL .)
    MINUS           reduce using rule 25 (expression -> SYMBOL .)
    TIMES           reduce using rule 25 (expression -> SYMBOL .)
    DIVIDE          reduce using rule 25 (expression -> SYMBOL .)
    MODULE_OP       reduce using rule 25 (expression -> SYMBOL .)
    POWER           reduce using rule 25 (expression -> SYMBOL .)

  ! HASH_ROCKET     [ reduce using rule 25 (expression -> SYMBOL .) ]


state 81

    (73) hash_pair -> STRING . HASH_ROCKET expression
    (24) expression -> STRING .

  ! shift/reduce conflict for HASH_ROCKET resolved as shift
    HASH_ROCKET     shift and go to state 124
    RANGE_INCLUSIVE reduce using rule 24 (expression -> STRING .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> STRING .)
    DOT             reduce using rule 24 (expression -> STRING .)
    PLUS            reduce using rule 24 (expression -> STRING .)
    MINUS           reduce using rule 24 (expression -> STRING .)
    TIMES           reduce using rule 24 (expression -> STRING .)
    DIVIDE          reduce using rule 24 (expression -> STRING .)
    MODULE_OP       reduce using rule 24 (expression -> STRING .)
    POWER           reduce using rule 24 (expression -> STRING .)

  ! HASH_ROCKET     [ reduce using rule 24 (expression -> STRING .) ]


state 82

    (46) assignment -> assignment_array ASSIGN . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 125

state 83

    (95) io_statement -> PUTS expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 95 (io_statement -> PUTS expression .)
    SEMICOLON       reduce using rule 95 (io_statement -> PUTS expression .)
    $end            reduce using rule 95 (io_statement -> PUTS expression .)
    END             reduce using rule 95 (io_statement -> PUTS expression .)
    ELSIF           reduce using rule 95 (io_statement -> PUTS expression .)
    ELSE            reduce using rule 95 (io_statement -> PUTS expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 84

    (97) control_statement -> FOR for_setup . statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 126
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 85

    (98) for_setup -> IDENTIFIER . IN expression enter_loop_scope

    IN              shift and go to state 127


state 86

    (99) control_statement -> IF condition . enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> IF condition . enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> IF condition . enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> IF condition . enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition
    (2) enter_scope -> . empty
    (1) empty -> .

    LOGICAL_AND     shift and go to state 129
    AND             shift and go to state 130
    LOGICAL_OR      shift and go to state 131
    OR              shift and go to state 132
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 128
    empty                          shift and go to state 133

state 87

    (76) condition -> expression . EQUAL expression
    (77) condition -> expression . NOT_EQUAL expression
    (78) condition -> expression . GREATER expression
    (79) condition -> expression . LESS expression
    (80) condition -> expression . GREATER_EQUAL expression
    (81) condition -> expression . LESS_EQUAL expression
    (82) condition -> expression . SPACESHIP expression
    (83) condition -> expression . CASE_EQUAL expression
    (90) condition -> expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    EQUAL           shift and go to state 134
    NOT_EQUAL       shift and go to state 135
    GREATER         shift and go to state 136
    LESS            shift and go to state 137
    GREATER_EQUAL   shift and go to state 138
    LESS_EQUAL      shift and go to state 139
    SPACESHIP       shift and go to state 140
    CASE_EQUAL      shift and go to state 141
    LOGICAL_AND     reduce using rule 90 (condition -> expression .)
    AND             reduce using rule 90 (condition -> expression .)
    LOGICAL_OR      reduce using rule 90 (condition -> expression .)
    OR              reduce using rule 90 (condition -> expression .)
    BREAK           reduce using rule 90 (condition -> expression .)
    NEXT            reduce using rule 90 (condition -> expression .)
    INTEGER         reduce using rule 90 (condition -> expression .)
    FLOAT           reduce using rule 90 (condition -> expression .)
    STRING          reduce using rule 90 (condition -> expression .)
    SYMBOL          reduce using rule 90 (condition -> expression .)
    REGEXP          reduce using rule 90 (condition -> expression .)
    TRUE            reduce using rule 90 (condition -> expression .)
    FALSE           reduce using rule 90 (condition -> expression .)
    NIL             reduce using rule 90 (condition -> expression .)
    IDENTIFIER      reduce using rule 90 (condition -> expression .)
    INSTANCE_VARIABLE reduce using rule 90 (condition -> expression .)
    CLASS_VARIABLE  reduce using rule 90 (condition -> expression .)
    GLOBAL_VARIABLE reduce using rule 90 (condition -> expression .)
    CONSTANT        reduce using rule 90 (condition -> expression .)
    LPAREN          reduce using rule 90 (condition -> expression .)
    LBRACE          reduce using rule 90 (condition -> expression .)
    LBRACKET        reduce using rule 90 (condition -> expression .)
    PUTS            reduce using rule 90 (condition -> expression .)
    FOR             reduce using rule 90 (condition -> expression .)
    IF              reduce using rule 90 (condition -> expression .)
    WHILE           reduce using rule 90 (condition -> expression .)
    DEF             reduce using rule 90 (condition -> expression .)
    CLASS           reduce using rule 90 (condition -> expression .)
    RETURN          reduce using rule 90 (condition -> expression .)
    ELSIF           reduce using rule 90 (condition -> expression .)
    NEWLINE         reduce using rule 90 (condition -> expression .)
    SEMICOLON       reduce using rule 90 (condition -> expression .)
    END             reduce using rule 90 (condition -> expression .)
    ELSE            reduce using rule 90 (condition -> expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 90 (condition -> expression .) ]


state 88

    (88) condition -> LOGICAL_NOT . condition
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 142
    expression                     shift and go to state 87

state 89

    (89) condition -> NOT . condition
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 143
    expression                     shift and go to state 87

state 90

    (105) control_statement -> WHILE condition . enter_loop_scope statements optional_newlines exit_scope END
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition
    (3) enter_loop_scope -> . empty
    (1) empty -> .

    LOGICAL_AND     shift and go to state 129
    AND             shift and go to state 130
    LOGICAL_OR      shift and go to state 131
    OR              shift and go to state 132
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_loop_scope               shift and go to state 144
    empty                          shift and go to state 145

state 91

    (62) function_definition -> DEF func_name_hook . func_header statements optional_newlines exit_scope END
    (64) func_header -> . LPAREN param_list RPAREN
    (65) func_header -> . LPAREN RPAREN
    (66) func_header -> . empty
    (1) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 147
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

  ! LPAREN          [ reduce using rule 1 (empty -> .) ]

    func_header                    shift and go to state 146
    empty                          shift and go to state 148

state 92

    (63) func_name_hook -> IDENTIFIER .

    LPAREN          reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    BREAK           reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    NEXT            reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    INTEGER         reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    FLOAT           reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    STRING          reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    SYMBOL          reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    REGEXP          reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    TRUE            reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    FALSE           reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    NIL             reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    INSTANCE_VARIABLE reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    CLASS_VARIABLE  reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    GLOBAL_VARIABLE reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    CONSTANT        reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    MINUS           reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    LBRACE          reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    LBRACKET        reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    PUTS            reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    FOR             reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    IF              reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    WHILE           reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    DEF             reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    CLASS           reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    RETURN          reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    NEWLINE         reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    SEMICOLON       reduce using rule 63 (func_name_hook -> IDENTIFIER .)
    END             reduce using rule 63 (func_name_hook -> IDENTIFIER .)


state 93

    (56) class_definition -> CLASS CONSTANT . enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> CLASS CONSTANT . LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    LESS            shift and go to state 150
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 149
    empty                          shift and go to state 133

state 94

    (60) return_statement -> RETURN expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 60 (return_statement -> RETURN expression .)
    SEMICOLON       reduce using rule 60 (return_statement -> RETURN expression .)
    $end            reduce using rule 60 (return_statement -> RETURN expression .)
    END             reduce using rule 60 (return_statement -> RETURN expression .)
    ELSIF           reduce using rule 60 (return_statement -> RETURN expression .)
    ELSE            reduce using rule 60 (return_statement -> RETURN expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 95

    (6) statements -> statements statement_separator statement .

    NEWLINE         reduce using rule 6 (statements -> statements statement_separator statement .)
    SEMICOLON       reduce using rule 6 (statements -> statements statement_separator statement .)
    $end            reduce using rule 6 (statements -> statements statement_separator statement .)
    END             reduce using rule 6 (statements -> statements statement_separator statement .)
    ELSIF           reduce using rule 6 (statements -> statements statement_separator statement .)
    ELSE            reduce using rule 6 (statements -> statements statement_separator statement .)


state 96

    (35) expression -> expression RANGE_INCLUSIVE expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    NEWLINE         reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    SEMICOLON       reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    $end            reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    COMMA           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    END             reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    ELSIF           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    ELSE            reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACKET        reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    RPAREN          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    HASH_ROCKET     reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    EQUAL           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    NOT_EQUAL       reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    GREATER         reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    LESS            reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    GREATER_EQUAL   reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    LESS_EQUAL      reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    SPACESHIP       reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    CASE_EQUAL      reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    LOGICAL_AND     reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    AND             reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    LOGICAL_OR      reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    OR              reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    BREAK           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    NEXT            reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    INTEGER         reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    FLOAT           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    STRING          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    SYMBOL          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    REGEXP          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    TRUE            reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    FALSE           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    NIL             reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    IDENTIFIER      reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    INSTANCE_VARIABLE reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    CLASS_VARIABLE  reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    GLOBAL_VARIABLE reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    CONSTANT        reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    LPAREN          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    LBRACE          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    LBRACKET        reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    PUTS            reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    FOR             reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    IF              reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    WHILE           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    DEF             reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    CLASS           reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    RETURN          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACE          reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! RANGE_INCLUSIVE [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! DOT             [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! PLUS            [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MINUS           [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! TIMES           [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! DIVIDE          [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MODULE_OP       [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! POWER           [ reduce using rule 35 (expression -> expression RANGE_INCLUSIVE expression .) ]


state 97

    (36) expression -> expression RANGE_EXCLUSIVE expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    NEWLINE         reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    SEMICOLON       reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    $end            reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    COMMA           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    END             reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    ELSIF           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    ELSE            reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    RBRACKET        reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    RPAREN          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    HASH_ROCKET     reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    EQUAL           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    NOT_EQUAL       reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    GREATER         reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    LESS            reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    GREATER_EQUAL   reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    LESS_EQUAL      reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    SPACESHIP       reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    CASE_EQUAL      reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    LOGICAL_AND     reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    AND             reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    LOGICAL_OR      reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    OR              reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    BREAK           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    NEXT            reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    INTEGER         reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    FLOAT           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    STRING          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    SYMBOL          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    REGEXP          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    TRUE            reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    FALSE           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    NIL             reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    IDENTIFIER      reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    INSTANCE_VARIABLE reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    CLASS_VARIABLE  reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    GLOBAL_VARIABLE reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    CONSTANT        reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    LPAREN          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    LBRACE          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    LBRACKET        reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    PUTS            reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    FOR             reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    IF              reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    WHILE           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    DEF             reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    CLASS           reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    RETURN          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    RBRACE          reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! RANGE_INCLUSIVE [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! DOT             [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! PLUS            [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! MODULE_OP       [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! POWER           [ reduce using rule 36 (expression -> expression RANGE_EXCLUSIVE expression .) ]


state 98

    (38) expression -> expression DOT IDENTIFIER .
    (39) expression -> expression DOT IDENTIFIER . LPAREN arguments RPAREN
    (40) expression -> expression DOT IDENTIFIER . LPAREN RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    RANGE_INCLUSIVE reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    DOT             reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    PLUS            reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    MINUS           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    TIMES           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    DIVIDE          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    MODULE_OP       reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    POWER           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    NEWLINE         reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    $end            reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    COMMA           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    END             reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    ELSIF           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    ELSE            reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    RBRACKET        reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    RPAREN          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    HASH_ROCKET     reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    EQUAL           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    NOT_EQUAL       reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    GREATER         reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    LESS            reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    LESS_EQUAL      reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    SPACESHIP       reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    CASE_EQUAL      reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    LOGICAL_AND     reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    AND             reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    LOGICAL_OR      reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    OR              reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    BREAK           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    NEXT            reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    INTEGER         reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    FLOAT           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    STRING          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    SYMBOL          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    REGEXP          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    TRUE            reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    FALSE           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    NIL             reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    INSTANCE_VARIABLE reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    CLASS_VARIABLE  reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    GLOBAL_VARIABLE reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    CONSTANT        reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    LBRACE          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    LBRACKET        reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    PUTS            reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    FOR             reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    IF              reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    WHILE           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    DEF             reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    CLASS           reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    RETURN          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    RBRACE          reduce using rule 38 (expression -> expression DOT IDENTIFIER .)
    LPAREN          shift and go to state 151

  ! LPAREN          [ reduce using rule 38 (expression -> expression DOT IDENTIFIER .) ]


state 99

    (48) expression -> expression PLUS expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RANGE_INCLUSIVE reduce using rule 48 (expression -> expression PLUS expression .)
    RANGE_EXCLUSIVE reduce using rule 48 (expression -> expression PLUS expression .)
    DOT             reduce using rule 48 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 48 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 48 (expression -> expression PLUS expression .)
    NEWLINE         reduce using rule 48 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 48 (expression -> expression PLUS expression .)
    $end            reduce using rule 48 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 48 (expression -> expression PLUS expression .)
    END             reduce using rule 48 (expression -> expression PLUS expression .)
    ELSIF           reduce using rule 48 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 48 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 48 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 48 (expression -> expression PLUS expression .)
    HASH_ROCKET     reduce using rule 48 (expression -> expression PLUS expression .)
    EQUAL           reduce using rule 48 (expression -> expression PLUS expression .)
    NOT_EQUAL       reduce using rule 48 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 48 (expression -> expression PLUS expression .)
    LESS            reduce using rule 48 (expression -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 48 (expression -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 48 (expression -> expression PLUS expression .)
    SPACESHIP       reduce using rule 48 (expression -> expression PLUS expression .)
    CASE_EQUAL      reduce using rule 48 (expression -> expression PLUS expression .)
    LOGICAL_AND     reduce using rule 48 (expression -> expression PLUS expression .)
    AND             reduce using rule 48 (expression -> expression PLUS expression .)
    LOGICAL_OR      reduce using rule 48 (expression -> expression PLUS expression .)
    OR              reduce using rule 48 (expression -> expression PLUS expression .)
    BREAK           reduce using rule 48 (expression -> expression PLUS expression .)
    NEXT            reduce using rule 48 (expression -> expression PLUS expression .)
    INTEGER         reduce using rule 48 (expression -> expression PLUS expression .)
    FLOAT           reduce using rule 48 (expression -> expression PLUS expression .)
    STRING          reduce using rule 48 (expression -> expression PLUS expression .)
    SYMBOL          reduce using rule 48 (expression -> expression PLUS expression .)
    REGEXP          reduce using rule 48 (expression -> expression PLUS expression .)
    TRUE            reduce using rule 48 (expression -> expression PLUS expression .)
    FALSE           reduce using rule 48 (expression -> expression PLUS expression .)
    NIL             reduce using rule 48 (expression -> expression PLUS expression .)
    IDENTIFIER      reduce using rule 48 (expression -> expression PLUS expression .)
    INSTANCE_VARIABLE reduce using rule 48 (expression -> expression PLUS expression .)
    CLASS_VARIABLE  reduce using rule 48 (expression -> expression PLUS expression .)
    GLOBAL_VARIABLE reduce using rule 48 (expression -> expression PLUS expression .)
    CONSTANT        reduce using rule 48 (expression -> expression PLUS expression .)
    LPAREN          reduce using rule 48 (expression -> expression PLUS expression .)
    LBRACE          reduce using rule 48 (expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 48 (expression -> expression PLUS expression .)
    PUTS            reduce using rule 48 (expression -> expression PLUS expression .)
    FOR             reduce using rule 48 (expression -> expression PLUS expression .)
    IF              reduce using rule 48 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 48 (expression -> expression PLUS expression .)
    DEF             reduce using rule 48 (expression -> expression PLUS expression .)
    CLASS           reduce using rule 48 (expression -> expression PLUS expression .)
    RETURN          reduce using rule 48 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 48 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! TIMES           [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! MODULE_OP       [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! POWER           [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! RANGE_INCLUSIVE [ shift and go to state 48 ]
  ! RANGE_EXCLUSIVE [ shift and go to state 49 ]
  ! DOT             [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]


state 100

    (49) expression -> expression MINUS expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RANGE_INCLUSIVE reduce using rule 49 (expression -> expression MINUS expression .)
    RANGE_EXCLUSIVE reduce using rule 49 (expression -> expression MINUS expression .)
    DOT             reduce using rule 49 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 49 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 49 (expression -> expression MINUS expression .)
    NEWLINE         reduce using rule 49 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 49 (expression -> expression MINUS expression .)
    $end            reduce using rule 49 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 49 (expression -> expression MINUS expression .)
    END             reduce using rule 49 (expression -> expression MINUS expression .)
    ELSIF           reduce using rule 49 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 49 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 49 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 49 (expression -> expression MINUS expression .)
    HASH_ROCKET     reduce using rule 49 (expression -> expression MINUS expression .)
    EQUAL           reduce using rule 49 (expression -> expression MINUS expression .)
    NOT_EQUAL       reduce using rule 49 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 49 (expression -> expression MINUS expression .)
    LESS            reduce using rule 49 (expression -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 49 (expression -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 49 (expression -> expression MINUS expression .)
    SPACESHIP       reduce using rule 49 (expression -> expression MINUS expression .)
    CASE_EQUAL      reduce using rule 49 (expression -> expression MINUS expression .)
    LOGICAL_AND     reduce using rule 49 (expression -> expression MINUS expression .)
    AND             reduce using rule 49 (expression -> expression MINUS expression .)
    LOGICAL_OR      reduce using rule 49 (expression -> expression MINUS expression .)
    OR              reduce using rule 49 (expression -> expression MINUS expression .)
    BREAK           reduce using rule 49 (expression -> expression MINUS expression .)
    NEXT            reduce using rule 49 (expression -> expression MINUS expression .)
    INTEGER         reduce using rule 49 (expression -> expression MINUS expression .)
    FLOAT           reduce using rule 49 (expression -> expression MINUS expression .)
    STRING          reduce using rule 49 (expression -> expression MINUS expression .)
    SYMBOL          reduce using rule 49 (expression -> expression MINUS expression .)
    REGEXP          reduce using rule 49 (expression -> expression MINUS expression .)
    TRUE            reduce using rule 49 (expression -> expression MINUS expression .)
    FALSE           reduce using rule 49 (expression -> expression MINUS expression .)
    NIL             reduce using rule 49 (expression -> expression MINUS expression .)
    IDENTIFIER      reduce using rule 49 (expression -> expression MINUS expression .)
    INSTANCE_VARIABLE reduce using rule 49 (expression -> expression MINUS expression .)
    CLASS_VARIABLE  reduce using rule 49 (expression -> expression MINUS expression .)
    GLOBAL_VARIABLE reduce using rule 49 (expression -> expression MINUS expression .)
    CONSTANT        reduce using rule 49 (expression -> expression MINUS expression .)
    LPAREN          reduce using rule 49 (expression -> expression MINUS expression .)
    LBRACE          reduce using rule 49 (expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 49 (expression -> expression MINUS expression .)
    PUTS            reduce using rule 49 (expression -> expression MINUS expression .)
    FOR             reduce using rule 49 (expression -> expression MINUS expression .)
    IF              reduce using rule 49 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 49 (expression -> expression MINUS expression .)
    DEF             reduce using rule 49 (expression -> expression MINUS expression .)
    CLASS           reduce using rule 49 (expression -> expression MINUS expression .)
    RETURN          reduce using rule 49 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 49 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! TIMES           [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! MODULE_OP       [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! POWER           [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! RANGE_INCLUSIVE [ shift and go to state 48 ]
  ! RANGE_EXCLUSIVE [ shift and go to state 49 ]
  ! DOT             [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]


state 101

    (50) expression -> expression TIMES expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RANGE_INCLUSIVE reduce using rule 50 (expression -> expression TIMES expression .)
    RANGE_EXCLUSIVE reduce using rule 50 (expression -> expression TIMES expression .)
    DOT             reduce using rule 50 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 50 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 50 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 50 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 50 (expression -> expression TIMES expression .)
    MODULE_OP       reduce using rule 50 (expression -> expression TIMES expression .)
    NEWLINE         reduce using rule 50 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 50 (expression -> expression TIMES expression .)
    $end            reduce using rule 50 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 50 (expression -> expression TIMES expression .)
    END             reduce using rule 50 (expression -> expression TIMES expression .)
    ELSIF           reduce using rule 50 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 50 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 50 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 50 (expression -> expression TIMES expression .)
    HASH_ROCKET     reduce using rule 50 (expression -> expression TIMES expression .)
    EQUAL           reduce using rule 50 (expression -> expression TIMES expression .)
    NOT_EQUAL       reduce using rule 50 (expression -> expression TIMES expression .)
    GREATER         reduce using rule 50 (expression -> expression TIMES expression .)
    LESS            reduce using rule 50 (expression -> expression TIMES expression .)
    GREATER_EQUAL   reduce using rule 50 (expression -> expression TIMES expression .)
    LESS_EQUAL      reduce using rule 50 (expression -> expression TIMES expression .)
    SPACESHIP       reduce using rule 50 (expression -> expression TIMES expression .)
    CASE_EQUAL      reduce using rule 50 (expression -> expression TIMES expression .)
    LOGICAL_AND     reduce using rule 50 (expression -> expression TIMES expression .)
    AND             reduce using rule 50 (expression -> expression TIMES expression .)
    LOGICAL_OR      reduce using rule 50 (expression -> expression TIMES expression .)
    OR              reduce using rule 50 (expression -> expression TIMES expression .)
    BREAK           reduce using rule 50 (expression -> expression TIMES expression .)
    NEXT            reduce using rule 50 (expression -> expression TIMES expression .)
    INTEGER         reduce using rule 50 (expression -> expression TIMES expression .)
    FLOAT           reduce using rule 50 (expression -> expression TIMES expression .)
    STRING          reduce using rule 50 (expression -> expression TIMES expression .)
    SYMBOL          reduce using rule 50 (expression -> expression TIMES expression .)
    REGEXP          reduce using rule 50 (expression -> expression TIMES expression .)
    TRUE            reduce using rule 50 (expression -> expression TIMES expression .)
    FALSE           reduce using rule 50 (expression -> expression TIMES expression .)
    NIL             reduce using rule 50 (expression -> expression TIMES expression .)
    IDENTIFIER      reduce using rule 50 (expression -> expression TIMES expression .)
    INSTANCE_VARIABLE reduce using rule 50 (expression -> expression TIMES expression .)
    CLASS_VARIABLE  reduce using rule 50 (expression -> expression TIMES expression .)
    GLOBAL_VARIABLE reduce using rule 50 (expression -> expression TIMES expression .)
    CONSTANT        reduce using rule 50 (expression -> expression TIMES expression .)
    LPAREN          reduce using rule 50 (expression -> expression TIMES expression .)
    LBRACE          reduce using rule 50 (expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 50 (expression -> expression TIMES expression .)
    PUTS            reduce using rule 50 (expression -> expression TIMES expression .)
    FOR             reduce using rule 50 (expression -> expression TIMES expression .)
    IF              reduce using rule 50 (expression -> expression TIMES expression .)
    WHILE           reduce using rule 50 (expression -> expression TIMES expression .)
    DEF             reduce using rule 50 (expression -> expression TIMES expression .)
    CLASS           reduce using rule 50 (expression -> expression TIMES expression .)
    RETURN          reduce using rule 50 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 50 (expression -> expression TIMES expression .)
    POWER           shift and go to state 56

  ! POWER           [ reduce using rule 50 (expression -> expression TIMES expression .) ]
  ! RANGE_INCLUSIVE [ shift and go to state 48 ]
  ! RANGE_EXCLUSIVE [ shift and go to state 49 ]
  ! DOT             [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MODULE_OP       [ shift and go to state 55 ]


state 102

    (51) expression -> expression DIVIDE expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RANGE_INCLUSIVE reduce using rule 51 (expression -> expression DIVIDE expression .)
    RANGE_EXCLUSIVE reduce using rule 51 (expression -> expression DIVIDE expression .)
    DOT             reduce using rule 51 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 51 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 51 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 51 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 51 (expression -> expression DIVIDE expression .)
    MODULE_OP       reduce using rule 51 (expression -> expression DIVIDE expression .)
    NEWLINE         reduce using rule 51 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 51 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 51 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 51 (expression -> expression DIVIDE expression .)
    END             reduce using rule 51 (expression -> expression DIVIDE expression .)
    ELSIF           reduce using rule 51 (expression -> expression DIVIDE expression .)
    ELSE            reduce using rule 51 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 51 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 51 (expression -> expression DIVIDE expression .)
    HASH_ROCKET     reduce using rule 51 (expression -> expression DIVIDE expression .)
    EQUAL           reduce using rule 51 (expression -> expression DIVIDE expression .)
    NOT_EQUAL       reduce using rule 51 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 51 (expression -> expression DIVIDE expression .)
    LESS            reduce using rule 51 (expression -> expression DIVIDE expression .)
    GREATER_EQUAL   reduce using rule 51 (expression -> expression DIVIDE expression .)
    LESS_EQUAL      reduce using rule 51 (expression -> expression DIVIDE expression .)
    SPACESHIP       reduce using rule 51 (expression -> expression DIVIDE expression .)
    CASE_EQUAL      reduce using rule 51 (expression -> expression DIVIDE expression .)
    LOGICAL_AND     reduce using rule 51 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 51 (expression -> expression DIVIDE expression .)
    LOGICAL_OR      reduce using rule 51 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 51 (expression -> expression DIVIDE expression .)
    BREAK           reduce using rule 51 (expression -> expression DIVIDE expression .)
    NEXT            reduce using rule 51 (expression -> expression DIVIDE expression .)
    INTEGER         reduce using rule 51 (expression -> expression DIVIDE expression .)
    FLOAT           reduce using rule 51 (expression -> expression DIVIDE expression .)
    STRING          reduce using rule 51 (expression -> expression DIVIDE expression .)
    SYMBOL          reduce using rule 51 (expression -> expression DIVIDE expression .)
    REGEXP          reduce using rule 51 (expression -> expression DIVIDE expression .)
    TRUE            reduce using rule 51 (expression -> expression DIVIDE expression .)
    FALSE           reduce using rule 51 (expression -> expression DIVIDE expression .)
    NIL             reduce using rule 51 (expression -> expression DIVIDE expression .)
    IDENTIFIER      reduce using rule 51 (expression -> expression DIVIDE expression .)
    INSTANCE_VARIABLE reduce using rule 51 (expression -> expression DIVIDE expression .)
    CLASS_VARIABLE  reduce using rule 51 (expression -> expression DIVIDE expression .)
    GLOBAL_VARIABLE reduce using rule 51 (expression -> expression DIVIDE expression .)
    CONSTANT        reduce using rule 51 (expression -> expression DIVIDE expression .)
    LPAREN          reduce using rule 51 (expression -> expression DIVIDE expression .)
    LBRACE          reduce using rule 51 (expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 51 (expression -> expression DIVIDE expression .)
    PUTS            reduce using rule 51 (expression -> expression DIVIDE expression .)
    FOR             reduce using rule 51 (expression -> expression DIVIDE expression .)
    IF              reduce using rule 51 (expression -> expression DIVIDE expression .)
    WHILE           reduce using rule 51 (expression -> expression DIVIDE expression .)
    DEF             reduce using rule 51 (expression -> expression DIVIDE expression .)
    CLASS           reduce using rule 51 (expression -> expression DIVIDE expression .)
    RETURN          reduce using rule 51 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 51 (expression -> expression DIVIDE expression .)
    POWER           shift and go to state 56

  ! POWER           [ reduce using rule 51 (expression -> expression DIVIDE expression .) ]
  ! RANGE_INCLUSIVE [ shift and go to state 48 ]
  ! RANGE_EXCLUSIVE [ shift and go to state 49 ]
  ! DOT             [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MODULE_OP       [ shift and go to state 55 ]


state 103

    (52) expression -> expression MODULE_OP expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RANGE_INCLUSIVE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RANGE_EXCLUSIVE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    DOT             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    PLUS            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    MINUS           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    TIMES           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    DIVIDE          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    MODULE_OP       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    NEWLINE         reduce using rule 52 (expression -> expression MODULE_OP expression .)
    SEMICOLON       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    $end            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    COMMA           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    END             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    ELSIF           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    ELSE            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RBRACKET        reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RPAREN          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    HASH_ROCKET     reduce using rule 52 (expression -> expression MODULE_OP expression .)
    EQUAL           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    NOT_EQUAL       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    GREATER         reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LESS            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    GREATER_EQUAL   reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LESS_EQUAL      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    SPACESHIP       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CASE_EQUAL      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LOGICAL_AND     reduce using rule 52 (expression -> expression MODULE_OP expression .)
    AND             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LOGICAL_OR      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    OR              reduce using rule 52 (expression -> expression MODULE_OP expression .)
    BREAK           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    NEXT            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    INTEGER         reduce using rule 52 (expression -> expression MODULE_OP expression .)
    FLOAT           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    STRING          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    SYMBOL          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    REGEXP          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    TRUE            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    FALSE           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    NIL             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    IDENTIFIER      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    INSTANCE_VARIABLE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CLASS_VARIABLE  reduce using rule 52 (expression -> expression MODULE_OP expression .)
    GLOBAL_VARIABLE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CONSTANT        reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LPAREN          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LBRACE          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LBRACKET        reduce using rule 52 (expression -> expression MODULE_OP expression .)
    PUTS            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    FOR             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    IF              reduce using rule 52 (expression -> expression MODULE_OP expression .)
    WHILE           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    DEF             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CLASS           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RETURN          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RBRACE          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    POWER           shift and go to state 56

  ! POWER           [ reduce using rule 52 (expression -> expression MODULE_OP expression .) ]
  ! RANGE_INCLUSIVE [ shift and go to state 48 ]
  ! RANGE_EXCLUSIVE [ shift and go to state 49 ]
  ! DOT             [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MODULE_OP       [ shift and go to state 55 ]


state 104

    (53) expression -> expression POWER expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RANGE_INCLUSIVE reduce using rule 53 (expression -> expression POWER expression .)
    RANGE_EXCLUSIVE reduce using rule 53 (expression -> expression POWER expression .)
    DOT             reduce using rule 53 (expression -> expression POWER expression .)
    PLUS            reduce using rule 53 (expression -> expression POWER expression .)
    MINUS           reduce using rule 53 (expression -> expression POWER expression .)
    TIMES           reduce using rule 53 (expression -> expression POWER expression .)
    DIVIDE          reduce using rule 53 (expression -> expression POWER expression .)
    MODULE_OP       reduce using rule 53 (expression -> expression POWER expression .)
    NEWLINE         reduce using rule 53 (expression -> expression POWER expression .)
    SEMICOLON       reduce using rule 53 (expression -> expression POWER expression .)
    $end            reduce using rule 53 (expression -> expression POWER expression .)
    COMMA           reduce using rule 53 (expression -> expression POWER expression .)
    END             reduce using rule 53 (expression -> expression POWER expression .)
    ELSIF           reduce using rule 53 (expression -> expression POWER expression .)
    ELSE            reduce using rule 53 (expression -> expression POWER expression .)
    RBRACKET        reduce using rule 53 (expression -> expression POWER expression .)
    RPAREN          reduce using rule 53 (expression -> expression POWER expression .)
    HASH_ROCKET     reduce using rule 53 (expression -> expression POWER expression .)
    EQUAL           reduce using rule 53 (expression -> expression POWER expression .)
    NOT_EQUAL       reduce using rule 53 (expression -> expression POWER expression .)
    GREATER         reduce using rule 53 (expression -> expression POWER expression .)
    LESS            reduce using rule 53 (expression -> expression POWER expression .)
    GREATER_EQUAL   reduce using rule 53 (expression -> expression POWER expression .)
    LESS_EQUAL      reduce using rule 53 (expression -> expression POWER expression .)
    SPACESHIP       reduce using rule 53 (expression -> expression POWER expression .)
    CASE_EQUAL      reduce using rule 53 (expression -> expression POWER expression .)
    LOGICAL_AND     reduce using rule 53 (expression -> expression POWER expression .)
    AND             reduce using rule 53 (expression -> expression POWER expression .)
    LOGICAL_OR      reduce using rule 53 (expression -> expression POWER expression .)
    OR              reduce using rule 53 (expression -> expression POWER expression .)
    BREAK           reduce using rule 53 (expression -> expression POWER expression .)
    NEXT            reduce using rule 53 (expression -> expression POWER expression .)
    INTEGER         reduce using rule 53 (expression -> expression POWER expression .)
    FLOAT           reduce using rule 53 (expression -> expression POWER expression .)
    STRING          reduce using rule 53 (expression -> expression POWER expression .)
    SYMBOL          reduce using rule 53 (expression -> expression POWER expression .)
    REGEXP          reduce using rule 53 (expression -> expression POWER expression .)
    TRUE            reduce using rule 53 (expression -> expression POWER expression .)
    FALSE           reduce using rule 53 (expression -> expression POWER expression .)
    NIL             reduce using rule 53 (expression -> expression POWER expression .)
    IDENTIFIER      reduce using rule 53 (expression -> expression POWER expression .)
    INSTANCE_VARIABLE reduce using rule 53 (expression -> expression POWER expression .)
    CLASS_VARIABLE  reduce using rule 53 (expression -> expression POWER expression .)
    GLOBAL_VARIABLE reduce using rule 53 (expression -> expression POWER expression .)
    CONSTANT        reduce using rule 53 (expression -> expression POWER expression .)
    LPAREN          reduce using rule 53 (expression -> expression POWER expression .)
    LBRACE          reduce using rule 53 (expression -> expression POWER expression .)
    LBRACKET        reduce using rule 53 (expression -> expression POWER expression .)
    PUTS            reduce using rule 53 (expression -> expression POWER expression .)
    FOR             reduce using rule 53 (expression -> expression POWER expression .)
    IF              reduce using rule 53 (expression -> expression POWER expression .)
    WHILE           reduce using rule 53 (expression -> expression POWER expression .)
    DEF             reduce using rule 53 (expression -> expression POWER expression .)
    CLASS           reduce using rule 53 (expression -> expression POWER expression .)
    RETURN          reduce using rule 53 (expression -> expression POWER expression .)
    RBRACE          reduce using rule 53 (expression -> expression POWER expression .)
    POWER           shift and go to state 56

  ! POWER           [ reduce using rule 53 (expression -> expression POWER expression .) ]
  ! RANGE_INCLUSIVE [ shift and go to state 48 ]
  ! RANGE_EXCLUSIVE [ shift and go to state 49 ]
  ! DOT             [ shift and go to state 50 ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! MODULE_OP       [ shift and go to state 55 ]


state 105

    (37) expression -> IDENTIFIER LBRACKET . expression RBRACKET
    (91) expression -> LBRACKET . array_elements RBRACKET
    (92) expression -> LBRACKET . RBRACKET
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (93) array_elements -> . array_elements COMMA expression
    (94) array_elements -> . expression

    RBRACKET        shift and go to state 72
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 152
    array_elements                 shift and go to state 71

state 106

    (37) expression -> IDENTIFIER LBRACKET expression . RBRACKET
    (47) assignment_array -> IDENTIFIER LBRACKET expression . RBRACKET
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (94) array_elements -> expression .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 153
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56
    COMMA           reduce using rule 94 (array_elements -> expression .)

  ! RBRACKET        [ reduce using rule 94 (array_elements -> expression .) ]


state 107

    (106) expression -> IDENTIFIER LPAREN arguments . RPAREN
    (109) arguments -> arguments . COMMA expression

    RPAREN          shift and go to state 154
    COMMA           shift and go to state 110


state 108

    (107) expression -> IDENTIFIER LPAREN RPAREN .

    RANGE_INCLUSIVE reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    MODULE_OP       reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    POWER           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    SEMICOLON       reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    END             reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    ELSIF           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    ELSE            reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    HASH_ROCKET     reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    EQUAL           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    GREATER         reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    LESS            reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    GREATER_EQUAL   reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    LESS_EQUAL      reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    SPACESHIP       reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    CASE_EQUAL      reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    LOGICAL_AND     reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    LOGICAL_OR      reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    BREAK           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    NEXT            reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    INTEGER         reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    FLOAT           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    STRING          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    SYMBOL          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    REGEXP          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    TRUE            reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    FALSE           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    NIL             reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    INSTANCE_VARIABLE reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    CLASS_VARIABLE  reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    GLOBAL_VARIABLE reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    CONSTANT        reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    LPAREN          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    LBRACKET        reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    PUTS            reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    DEF             reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    CLASS           reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 107 (expression -> IDENTIFIER LPAREN RPAREN .)


state 109

    (54) expression -> LPAREN expression . RPAREN
    (110) arguments -> expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 119
    COMMA           reduce using rule 110 (arguments -> expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! RPAREN          [ reduce using rule 110 (arguments -> expression .) ]


state 110

    (109) arguments -> arguments COMMA . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 155

state 111

    (41) assignment -> IDENTIFIER ASSIGN expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    END             reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    ELSIF           reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    ELSE            reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 112

    (74) io_statement -> IDENTIFIER ASSIGN GETS . DOT IDENTIFIER
    (75) io_statement -> IDENTIFIER ASSIGN GETS .

    DOT             shift and go to state 156
    NEWLINE         reduce using rule 75 (io_statement -> IDENTIFIER ASSIGN GETS .)
    SEMICOLON       reduce using rule 75 (io_statement -> IDENTIFIER ASSIGN GETS .)
    $end            reduce using rule 75 (io_statement -> IDENTIFIER ASSIGN GETS .)
    END             reduce using rule 75 (io_statement -> IDENTIFIER ASSIGN GETS .)
    ELSIF           reduce using rule 75 (io_statement -> IDENTIFIER ASSIGN GETS .)
    ELSE            reduce using rule 75 (io_statement -> IDENTIFIER ASSIGN GETS .)


state 113

    (42) assignment -> INSTANCE_VARIABLE ASSIGN expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    $end            reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    END             reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    ELSIF           reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    ELSE            reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 114

    (43) assignment -> CLASS_VARIABLE ASSIGN expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    $end            reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    END             reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    ELSIF           reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    ELSE            reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 115

    (44) assignment -> GLOBAL_VARIABLE ASSIGN expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    $end            reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    END             reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    ELSIF           reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    ELSE            reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 116

    (45) assignment -> CONSTANT ASSIGN expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    SEMICOLON       reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    $end            reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    END             reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    ELSIF           reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    ELSE            reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 117

    (91) expression -> LBRACKET array_elements RBRACKET .

    RANGE_INCLUSIVE reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    DOT             reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    PLUS            reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    MINUS           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    TIMES           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    DIVIDE          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    MODULE_OP       reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    POWER           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    NEWLINE         reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    SEMICOLON       reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    $end            reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    COMMA           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    END             reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    ELSIF           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    ELSE            reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    RBRACKET        reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    RPAREN          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    HASH_ROCKET     reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    EQUAL           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    NOT_EQUAL       reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    GREATER         reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    LESS            reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    GREATER_EQUAL   reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    LESS_EQUAL      reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    SPACESHIP       reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    CASE_EQUAL      reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    LOGICAL_AND     reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    AND             reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    LOGICAL_OR      reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    OR              reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    BREAK           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    NEXT            reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    INTEGER         reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    FLOAT           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    STRING          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    SYMBOL          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    REGEXP          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    TRUE            reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    FALSE           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    NIL             reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    IDENTIFIER      reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    INSTANCE_VARIABLE reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    CLASS_VARIABLE  reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    GLOBAL_VARIABLE reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    CONSTANT        reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    LPAREN          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    LBRACE          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    LBRACKET        reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    PUTS            reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    FOR             reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    IF              reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    WHILE           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    DEF             reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    CLASS           reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    RETURN          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)
    RBRACE          reduce using rule 91 (expression -> LBRACKET array_elements RBRACKET .)


state 118

    (93) array_elements -> array_elements COMMA . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 157

state 119

    (54) expression -> LPAREN expression RPAREN .

    RANGE_INCLUSIVE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    MODULE_OP       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    POWER           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    END             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    ELSIF           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    HASH_ROCKET     reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LESS            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    GREATER_EQUAL   reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LESS_EQUAL      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    SPACESHIP       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CASE_EQUAL      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LOGICAL_AND     reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LOGICAL_OR      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    NEXT            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    STRING          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    SYMBOL          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    REGEXP          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    NIL             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    INSTANCE_VARIABLE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CLASS_VARIABLE  reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    GLOBAL_VARIABLE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CONSTANT        reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    DEF             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CLASS           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 54 (expression -> LPAREN expression RPAREN .)


state 120

    (67) expression -> LBRACE hash_pairs RBRACE .

    RANGE_INCLUSIVE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RANGE_EXCLUSIVE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    DOT             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    PLUS            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    MINUS           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    TIMES           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    DIVIDE          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    MODULE_OP       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    POWER           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    NEWLINE         reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    SEMICOLON       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    $end            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    COMMA           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    END             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    ELSIF           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    ELSE            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RBRACKET        reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RPAREN          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    HASH_ROCKET     reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    EQUAL           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    NOT_EQUAL       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    GREATER         reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LESS            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    GREATER_EQUAL   reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LESS_EQUAL      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    SPACESHIP       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CASE_EQUAL      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LOGICAL_AND     reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    AND             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LOGICAL_OR      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    OR              reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    BREAK           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    NEXT            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    INTEGER         reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    FLOAT           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    STRING          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    SYMBOL          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    REGEXP          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    TRUE            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    FALSE           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    NIL             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    IDENTIFIER      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    INSTANCE_VARIABLE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CLASS_VARIABLE  reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    GLOBAL_VARIABLE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CONSTANT        reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LPAREN          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LBRACE          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LBRACKET        reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    PUTS            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    FOR             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    IF              reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    WHILE           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    DEF             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CLASS           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RETURN          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RBRACE          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)


state 121

    (69) hash_pairs -> hash_pairs COMMA . hash_pair
    (71) hash_pair -> . expression HASH_ROCKET expression
    (72) hash_pair -> . SYMBOL HASH_ROCKET expression
    (73) hash_pair -> . STRING HASH_ROCKET expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    SYMBOL          shift and go to state 80
    STRING          shift and go to state 81
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    hash_pair                      shift and go to state 158
    expression                     shift and go to state 79

state 122

    (71) hash_pair -> expression HASH_ROCKET . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 159

state 123

    (72) hash_pair -> SYMBOL HASH_ROCKET . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 160

state 124

    (73) hash_pair -> STRING HASH_ROCKET . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 161

state 125

    (46) assignment -> assignment_array ASSIGN expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    NEWLINE         reduce using rule 46 (assignment -> assignment_array ASSIGN expression .)
    SEMICOLON       reduce using rule 46 (assignment -> assignment_array ASSIGN expression .)
    $end            reduce using rule 46 (assignment -> assignment_array ASSIGN expression .)
    END             reduce using rule 46 (assignment -> assignment_array ASSIGN expression .)
    ELSIF           reduce using rule 46 (assignment -> assignment_array ASSIGN expression .)
    ELSE            reduce using rule 46 (assignment -> assignment_array ASSIGN expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 126

    (97) control_statement -> FOR for_setup statements . optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 162
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 127

    (98) for_setup -> IDENTIFIER IN . expression enter_loop_scope
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 163

state 128

    (99) control_statement -> IF condition enter_scope . statements optional_newlines exit_scope END
    (100) control_statement -> IF condition enter_scope . statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> IF condition enter_scope . statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> IF condition enter_scope . statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    ELSIF           reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 164
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 129

    (84) condition -> condition LOGICAL_AND . condition
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 165
    expression                     shift and go to state 87

state 130

    (85) condition -> condition AND . condition
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 166
    expression                     shift and go to state 87

state 131

    (86) condition -> condition LOGICAL_OR . condition
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 167
    expression                     shift and go to state 87

state 132

    (87) condition -> condition OR . condition
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 168
    expression                     shift and go to state 87

state 133

    (2) enter_scope -> empty .

    BREAK           reduce using rule 2 (enter_scope -> empty .)
    NEXT            reduce using rule 2 (enter_scope -> empty .)
    INTEGER         reduce using rule 2 (enter_scope -> empty .)
    FLOAT           reduce using rule 2 (enter_scope -> empty .)
    STRING          reduce using rule 2 (enter_scope -> empty .)
    SYMBOL          reduce using rule 2 (enter_scope -> empty .)
    REGEXP          reduce using rule 2 (enter_scope -> empty .)
    TRUE            reduce using rule 2 (enter_scope -> empty .)
    FALSE           reduce using rule 2 (enter_scope -> empty .)
    NIL             reduce using rule 2 (enter_scope -> empty .)
    IDENTIFIER      reduce using rule 2 (enter_scope -> empty .)
    INSTANCE_VARIABLE reduce using rule 2 (enter_scope -> empty .)
    CLASS_VARIABLE  reduce using rule 2 (enter_scope -> empty .)
    GLOBAL_VARIABLE reduce using rule 2 (enter_scope -> empty .)
    CONSTANT        reduce using rule 2 (enter_scope -> empty .)
    LPAREN          reduce using rule 2 (enter_scope -> empty .)
    MINUS           reduce using rule 2 (enter_scope -> empty .)
    LBRACE          reduce using rule 2 (enter_scope -> empty .)
    LBRACKET        reduce using rule 2 (enter_scope -> empty .)
    PUTS            reduce using rule 2 (enter_scope -> empty .)
    FOR             reduce using rule 2 (enter_scope -> empty .)
    IF              reduce using rule 2 (enter_scope -> empty .)
    WHILE           reduce using rule 2 (enter_scope -> empty .)
    DEF             reduce using rule 2 (enter_scope -> empty .)
    CLASS           reduce using rule 2 (enter_scope -> empty .)
    RETURN          reduce using rule 2 (enter_scope -> empty .)
    ELSIF           reduce using rule 2 (enter_scope -> empty .)
    NEWLINE         reduce using rule 2 (enter_scope -> empty .)
    SEMICOLON       reduce using rule 2 (enter_scope -> empty .)
    END             reduce using rule 2 (enter_scope -> empty .)
    ELSE            reduce using rule 2 (enter_scope -> empty .)


state 134

    (76) condition -> expression EQUAL . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 169

state 135

    (77) condition -> expression NOT_EQUAL . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 170

state 136

    (78) condition -> expression GREATER . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 171

state 137

    (79) condition -> expression LESS . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 172

state 138

    (80) condition -> expression GREATER_EQUAL . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 173

state 139

    (81) condition -> expression LESS_EQUAL . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 174

state 140

    (82) condition -> expression SPACESHIP . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 175

state 141

    (83) condition -> expression CASE_EQUAL . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 176

state 142

    (88) condition -> LOGICAL_NOT condition .
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition

    LOGICAL_AND     reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    AND             reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    LOGICAL_OR      reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    OR              reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    BREAK           reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    NEXT            reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    INTEGER         reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    FLOAT           reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    STRING          reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    SYMBOL          reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    REGEXP          reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    TRUE            reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    FALSE           reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    NIL             reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    IDENTIFIER      reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    INSTANCE_VARIABLE reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    CLASS_VARIABLE  reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    GLOBAL_VARIABLE reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    CONSTANT        reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    LPAREN          reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    MINUS           reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    LBRACE          reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    LBRACKET        reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    PUTS            reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    FOR             reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    IF              reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    WHILE           reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    DEF             reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    CLASS           reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    RETURN          reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    ELSIF           reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    NEWLINE         reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    SEMICOLON       reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    END             reduce using rule 88 (condition -> LOGICAL_NOT condition .)
    ELSE            reduce using rule 88 (condition -> LOGICAL_NOT condition .)

  ! LOGICAL_AND     [ shift and go to state 129 ]
  ! AND             [ shift and go to state 130 ]
  ! LOGICAL_OR      [ shift and go to state 131 ]
  ! OR              [ shift and go to state 132 ]


state 143

    (89) condition -> NOT condition .
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BREAK           reduce using rule 89 (condition -> NOT condition .)
    NEXT            reduce using rule 89 (condition -> NOT condition .)
    INTEGER         reduce using rule 89 (condition -> NOT condition .)
    FLOAT           reduce using rule 89 (condition -> NOT condition .)
    STRING          reduce using rule 89 (condition -> NOT condition .)
    SYMBOL          reduce using rule 89 (condition -> NOT condition .)
    REGEXP          reduce using rule 89 (condition -> NOT condition .)
    TRUE            reduce using rule 89 (condition -> NOT condition .)
    FALSE           reduce using rule 89 (condition -> NOT condition .)
    NIL             reduce using rule 89 (condition -> NOT condition .)
    IDENTIFIER      reduce using rule 89 (condition -> NOT condition .)
    INSTANCE_VARIABLE reduce using rule 89 (condition -> NOT condition .)
    CLASS_VARIABLE  reduce using rule 89 (condition -> NOT condition .)
    GLOBAL_VARIABLE reduce using rule 89 (condition -> NOT condition .)
    CONSTANT        reduce using rule 89 (condition -> NOT condition .)
    LPAREN          reduce using rule 89 (condition -> NOT condition .)
    MINUS           reduce using rule 89 (condition -> NOT condition .)
    LBRACE          reduce using rule 89 (condition -> NOT condition .)
    LBRACKET        reduce using rule 89 (condition -> NOT condition .)
    PUTS            reduce using rule 89 (condition -> NOT condition .)
    FOR             reduce using rule 89 (condition -> NOT condition .)
    IF              reduce using rule 89 (condition -> NOT condition .)
    WHILE           reduce using rule 89 (condition -> NOT condition .)
    DEF             reduce using rule 89 (condition -> NOT condition .)
    CLASS           reduce using rule 89 (condition -> NOT condition .)
    RETURN          reduce using rule 89 (condition -> NOT condition .)
    ELSIF           reduce using rule 89 (condition -> NOT condition .)
    NEWLINE         reduce using rule 89 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 89 (condition -> NOT condition .)
    END             reduce using rule 89 (condition -> NOT condition .)
    ELSE            reduce using rule 89 (condition -> NOT condition .)
    LOGICAL_AND     shift and go to state 129
    AND             shift and go to state 130
    LOGICAL_OR      shift and go to state 131
    OR              shift and go to state 132

  ! LOGICAL_AND     [ reduce using rule 89 (condition -> NOT condition .) ]
  ! AND             [ reduce using rule 89 (condition -> NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 89 (condition -> NOT condition .) ]
  ! OR              [ reduce using rule 89 (condition -> NOT condition .) ]


state 144

    (105) control_statement -> WHILE condition enter_loop_scope . statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 177
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 145

    (3) enter_loop_scope -> empty .

    BREAK           reduce using rule 3 (enter_loop_scope -> empty .)
    NEXT            reduce using rule 3 (enter_loop_scope -> empty .)
    INTEGER         reduce using rule 3 (enter_loop_scope -> empty .)
    FLOAT           reduce using rule 3 (enter_loop_scope -> empty .)
    STRING          reduce using rule 3 (enter_loop_scope -> empty .)
    SYMBOL          reduce using rule 3 (enter_loop_scope -> empty .)
    REGEXP          reduce using rule 3 (enter_loop_scope -> empty .)
    TRUE            reduce using rule 3 (enter_loop_scope -> empty .)
    FALSE           reduce using rule 3 (enter_loop_scope -> empty .)
    NIL             reduce using rule 3 (enter_loop_scope -> empty .)
    IDENTIFIER      reduce using rule 3 (enter_loop_scope -> empty .)
    INSTANCE_VARIABLE reduce using rule 3 (enter_loop_scope -> empty .)
    CLASS_VARIABLE  reduce using rule 3 (enter_loop_scope -> empty .)
    GLOBAL_VARIABLE reduce using rule 3 (enter_loop_scope -> empty .)
    CONSTANT        reduce using rule 3 (enter_loop_scope -> empty .)
    LPAREN          reduce using rule 3 (enter_loop_scope -> empty .)
    MINUS           reduce using rule 3 (enter_loop_scope -> empty .)
    LBRACE          reduce using rule 3 (enter_loop_scope -> empty .)
    LBRACKET        reduce using rule 3 (enter_loop_scope -> empty .)
    PUTS            reduce using rule 3 (enter_loop_scope -> empty .)
    FOR             reduce using rule 3 (enter_loop_scope -> empty .)
    IF              reduce using rule 3 (enter_loop_scope -> empty .)
    WHILE           reduce using rule 3 (enter_loop_scope -> empty .)
    DEF             reduce using rule 3 (enter_loop_scope -> empty .)
    CLASS           reduce using rule 3 (enter_loop_scope -> empty .)
    RETURN          reduce using rule 3 (enter_loop_scope -> empty .)
    NEWLINE         reduce using rule 3 (enter_loop_scope -> empty .)
    SEMICOLON       reduce using rule 3 (enter_loop_scope -> empty .)
    END             reduce using rule 3 (enter_loop_scope -> empty .)


state 146

    (62) function_definition -> DEF func_name_hook func_header . statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 178
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 147

    (64) func_header -> LPAREN . param_list RPAREN
    (65) func_header -> LPAREN . RPAREN
    (58) param_list -> . IDENTIFIER COMMA param_list
    (59) param_list -> . IDENTIFIER

    RPAREN          shift and go to state 180
    IDENTIFIER      shift and go to state 181

    param_list                     shift and go to state 179

state 148

    (66) func_header -> empty .

    BREAK           reduce using rule 66 (func_header -> empty .)
    NEXT            reduce using rule 66 (func_header -> empty .)
    INTEGER         reduce using rule 66 (func_header -> empty .)
    FLOAT           reduce using rule 66 (func_header -> empty .)
    STRING          reduce using rule 66 (func_header -> empty .)
    SYMBOL          reduce using rule 66 (func_header -> empty .)
    REGEXP          reduce using rule 66 (func_header -> empty .)
    TRUE            reduce using rule 66 (func_header -> empty .)
    FALSE           reduce using rule 66 (func_header -> empty .)
    NIL             reduce using rule 66 (func_header -> empty .)
    IDENTIFIER      reduce using rule 66 (func_header -> empty .)
    INSTANCE_VARIABLE reduce using rule 66 (func_header -> empty .)
    CLASS_VARIABLE  reduce using rule 66 (func_header -> empty .)
    GLOBAL_VARIABLE reduce using rule 66 (func_header -> empty .)
    CONSTANT        reduce using rule 66 (func_header -> empty .)
    LPAREN          reduce using rule 66 (func_header -> empty .)
    MINUS           reduce using rule 66 (func_header -> empty .)
    LBRACE          reduce using rule 66 (func_header -> empty .)
    LBRACKET        reduce using rule 66 (func_header -> empty .)
    PUTS            reduce using rule 66 (func_header -> empty .)
    FOR             reduce using rule 66 (func_header -> empty .)
    IF              reduce using rule 66 (func_header -> empty .)
    WHILE           reduce using rule 66 (func_header -> empty .)
    DEF             reduce using rule 66 (func_header -> empty .)
    CLASS           reduce using rule 66 (func_header -> empty .)
    RETURN          reduce using rule 66 (func_header -> empty .)
    NEWLINE         reduce using rule 66 (func_header -> empty .)
    SEMICOLON       reduce using rule 66 (func_header -> empty .)
    END             reduce using rule 66 (func_header -> empty .)


state 149

    (56) class_definition -> CLASS CONSTANT enter_scope . statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 182
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 150

    (57) class_definition -> CLASS CONSTANT LESS . CONSTANT enter_scope statements optional_newlines exit_scope END

    CONSTANT        shift and go to state 183


state 151

    (39) expression -> expression DOT IDENTIFIER LPAREN . arguments RPAREN
    (40) expression -> expression DOT IDENTIFIER LPAREN . RPAREN
    (109) arguments -> . arguments COMMA expression
    (110) arguments -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    RPAREN          shift and go to state 185
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    expression                     shift and go to state 59
    arguments                      shift and go to state 184

state 152

    (37) expression -> IDENTIFIER LBRACKET expression . RBRACKET
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (94) array_elements -> expression .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 186
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56
    COMMA           reduce using rule 94 (array_elements -> expression .)

  ! RBRACKET        [ reduce using rule 94 (array_elements -> expression .) ]


state 153

    (37) expression -> IDENTIFIER LBRACKET expression RBRACKET .
    (47) assignment_array -> IDENTIFIER LBRACKET expression RBRACKET .

    RANGE_INCLUSIVE reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DOT             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MODULE_OP       reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    POWER           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NEWLINE         reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    $end            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    END             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    ELSIF           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    ASSIGN          reduce using rule 47 (assignment_array -> IDENTIFIER LBRACKET expression RBRACKET .)


state 154

    (106) expression -> IDENTIFIER LPAREN arguments RPAREN .

    RANGE_INCLUSIVE reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    DOT             reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    PLUS            reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    MINUS           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    TIMES           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    MODULE_OP       reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    POWER           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    NEWLINE         reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    $end            reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    COMMA           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    END             reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    ELSIF           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    ELSE            reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    RBRACKET        reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    HASH_ROCKET     reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    NOT_EQUAL       reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    GREATER         reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    LESS            reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    GREATER_EQUAL   reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    LESS_EQUAL      reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    SPACESHIP       reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    CASE_EQUAL      reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    LOGICAL_AND     reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    AND             reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    LOGICAL_OR      reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    OR              reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    BREAK           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    NEXT            reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    INTEGER         reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    FLOAT           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    STRING          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    SYMBOL          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    REGEXP          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    TRUE            reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    FALSE           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    NIL             reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    IDENTIFIER      reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    INSTANCE_VARIABLE reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    CLASS_VARIABLE  reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    GLOBAL_VARIABLE reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    CONSTANT        reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    LPAREN          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    LBRACE          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    LBRACKET        reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    PUTS            reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    FOR             reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    IF              reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    WHILE           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    DEF             reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    CLASS           reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    RETURN          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 106 (expression -> IDENTIFIER LPAREN arguments RPAREN .)


state 155

    (109) arguments -> arguments COMMA expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    COMMA           reduce using rule 109 (arguments -> arguments COMMA expression .)
    NEWLINE         reduce using rule 109 (arguments -> arguments COMMA expression .)
    SEMICOLON       reduce using rule 109 (arguments -> arguments COMMA expression .)
    $end            reduce using rule 109 (arguments -> arguments COMMA expression .)
    END             reduce using rule 109 (arguments -> arguments COMMA expression .)
    ELSIF           reduce using rule 109 (arguments -> arguments COMMA expression .)
    ELSE            reduce using rule 109 (arguments -> arguments COMMA expression .)
    RBRACKET        reduce using rule 109 (arguments -> arguments COMMA expression .)
    RPAREN          reduce using rule 109 (arguments -> arguments COMMA expression .)
    HASH_ROCKET     reduce using rule 109 (arguments -> arguments COMMA expression .)
    EQUAL           reduce using rule 109 (arguments -> arguments COMMA expression .)
    NOT_EQUAL       reduce using rule 109 (arguments -> arguments COMMA expression .)
    GREATER         reduce using rule 109 (arguments -> arguments COMMA expression .)
    LESS            reduce using rule 109 (arguments -> arguments COMMA expression .)
    GREATER_EQUAL   reduce using rule 109 (arguments -> arguments COMMA expression .)
    LESS_EQUAL      reduce using rule 109 (arguments -> arguments COMMA expression .)
    SPACESHIP       reduce using rule 109 (arguments -> arguments COMMA expression .)
    CASE_EQUAL      reduce using rule 109 (arguments -> arguments COMMA expression .)
    LOGICAL_AND     reduce using rule 109 (arguments -> arguments COMMA expression .)
    AND             reduce using rule 109 (arguments -> arguments COMMA expression .)
    LOGICAL_OR      reduce using rule 109 (arguments -> arguments COMMA expression .)
    OR              reduce using rule 109 (arguments -> arguments COMMA expression .)
    BREAK           reduce using rule 109 (arguments -> arguments COMMA expression .)
    NEXT            reduce using rule 109 (arguments -> arguments COMMA expression .)
    INTEGER         reduce using rule 109 (arguments -> arguments COMMA expression .)
    FLOAT           reduce using rule 109 (arguments -> arguments COMMA expression .)
    STRING          reduce using rule 109 (arguments -> arguments COMMA expression .)
    SYMBOL          reduce using rule 109 (arguments -> arguments COMMA expression .)
    REGEXP          reduce using rule 109 (arguments -> arguments COMMA expression .)
    TRUE            reduce using rule 109 (arguments -> arguments COMMA expression .)
    FALSE           reduce using rule 109 (arguments -> arguments COMMA expression .)
    NIL             reduce using rule 109 (arguments -> arguments COMMA expression .)
    IDENTIFIER      reduce using rule 109 (arguments -> arguments COMMA expression .)
    INSTANCE_VARIABLE reduce using rule 109 (arguments -> arguments COMMA expression .)
    CLASS_VARIABLE  reduce using rule 109 (arguments -> arguments COMMA expression .)
    GLOBAL_VARIABLE reduce using rule 109 (arguments -> arguments COMMA expression .)
    CONSTANT        reduce using rule 109 (arguments -> arguments COMMA expression .)
    LPAREN          reduce using rule 109 (arguments -> arguments COMMA expression .)
    LBRACE          reduce using rule 109 (arguments -> arguments COMMA expression .)
    LBRACKET        reduce using rule 109 (arguments -> arguments COMMA expression .)
    PUTS            reduce using rule 109 (arguments -> arguments COMMA expression .)
    FOR             reduce using rule 109 (arguments -> arguments COMMA expression .)
    IF              reduce using rule 109 (arguments -> arguments COMMA expression .)
    WHILE           reduce using rule 109 (arguments -> arguments COMMA expression .)
    DEF             reduce using rule 109 (arguments -> arguments COMMA expression .)
    CLASS           reduce using rule 109 (arguments -> arguments COMMA expression .)
    RETURN          reduce using rule 109 (arguments -> arguments COMMA expression .)
    RBRACE          reduce using rule 109 (arguments -> arguments COMMA expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! RANGE_INCLUSIVE [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! DOT             [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! PLUS            [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! MINUS           [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! TIMES           [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! DIVIDE          [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! MODULE_OP       [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]
  ! POWER           [ reduce using rule 109 (arguments -> arguments COMMA expression .) ]


state 156

    (74) io_statement -> IDENTIFIER ASSIGN GETS DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 187


state 157

    (93) array_elements -> array_elements COMMA expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RBRACKET        reduce using rule 93 (array_elements -> array_elements COMMA expression .)
    COMMA           reduce using rule 93 (array_elements -> array_elements COMMA expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 158

    (69) hash_pairs -> hash_pairs COMMA hash_pair .

    RBRACE          reduce using rule 69 (hash_pairs -> hash_pairs COMMA hash_pair .)
    COMMA           reduce using rule 69 (hash_pairs -> hash_pairs COMMA hash_pair .)


state 159

    (71) hash_pair -> expression HASH_ROCKET expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RBRACE          reduce using rule 71 (hash_pair -> expression HASH_ROCKET expression .)
    COMMA           reduce using rule 71 (hash_pair -> expression HASH_ROCKET expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 160

    (72) hash_pair -> SYMBOL HASH_ROCKET expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RBRACE          reduce using rule 72 (hash_pair -> SYMBOL HASH_ROCKET expression .)
    COMMA           reduce using rule 72 (hash_pair -> SYMBOL HASH_ROCKET expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 161

    (73) hash_pair -> STRING HASH_ROCKET expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    RBRACE          reduce using rule 73 (hash_pair -> STRING HASH_ROCKET expression .)
    COMMA           reduce using rule 73 (hash_pair -> STRING HASH_ROCKET expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56


state 162

    (97) control_statement -> FOR for_setup statements optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 188
    empty                          shift and go to state 189

state 163

    (98) for_setup -> IDENTIFIER IN expression . enter_loop_scope
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (3) enter_loop_scope -> . empty
    (1) empty -> .

  ! shift/reduce conflict for MINUS resolved as shift
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

  ! MINUS           [ reduce using rule 1 (empty -> .) ]

    enter_loop_scope               shift and go to state 190
    empty                          shift and go to state 145

state 164

    (99) control_statement -> IF condition enter_scope statements . optional_newlines exit_scope END
    (100) control_statement -> IF condition enter_scope statements . optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> IF condition enter_scope statements . elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> IF condition enter_scope statements . elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (103) elsif_clauses -> . elsif_clauses ELSIF condition statements optional_newlines
    (104) elsif_clauses -> . ELSIF condition statements optional_newlines
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    ELSIF           shift and go to state 193
    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 191
    elsif_clauses                  shift and go to state 192
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 165

    (84) condition -> condition LOGICAL_AND condition .
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition

    LOGICAL_AND     reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    AND             reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    LOGICAL_OR      reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    OR              reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    BREAK           reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    NEXT            reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    INTEGER         reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    FLOAT           reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    STRING          reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    SYMBOL          reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    REGEXP          reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    TRUE            reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    FALSE           reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    NIL             reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    IDENTIFIER      reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    INSTANCE_VARIABLE reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    CLASS_VARIABLE  reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    GLOBAL_VARIABLE reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    CONSTANT        reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    LPAREN          reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    MINUS           reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    LBRACE          reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    LBRACKET        reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    PUTS            reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    FOR             reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    IF              reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    WHILE           reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    DEF             reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    CLASS           reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    RETURN          reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    ELSIF           reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    NEWLINE         reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    SEMICOLON       reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    END             reduce using rule 84 (condition -> condition LOGICAL_AND condition .)
    ELSE            reduce using rule 84 (condition -> condition LOGICAL_AND condition .)

  ! LOGICAL_AND     [ shift and go to state 129 ]
  ! AND             [ shift and go to state 130 ]
  ! LOGICAL_OR      [ shift and go to state 131 ]
  ! OR              [ shift and go to state 132 ]


state 166

    (85) condition -> condition AND condition .
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition

    AND             reduce using rule 85 (condition -> condition AND condition .)
    OR              reduce using rule 85 (condition -> condition AND condition .)
    BREAK           reduce using rule 85 (condition -> condition AND condition .)
    NEXT            reduce using rule 85 (condition -> condition AND condition .)
    INTEGER         reduce using rule 85 (condition -> condition AND condition .)
    FLOAT           reduce using rule 85 (condition -> condition AND condition .)
    STRING          reduce using rule 85 (condition -> condition AND condition .)
    SYMBOL          reduce using rule 85 (condition -> condition AND condition .)
    REGEXP          reduce using rule 85 (condition -> condition AND condition .)
    TRUE            reduce using rule 85 (condition -> condition AND condition .)
    FALSE           reduce using rule 85 (condition -> condition AND condition .)
    NIL             reduce using rule 85 (condition -> condition AND condition .)
    IDENTIFIER      reduce using rule 85 (condition -> condition AND condition .)
    INSTANCE_VARIABLE reduce using rule 85 (condition -> condition AND condition .)
    CLASS_VARIABLE  reduce using rule 85 (condition -> condition AND condition .)
    GLOBAL_VARIABLE reduce using rule 85 (condition -> condition AND condition .)
    CONSTANT        reduce using rule 85 (condition -> condition AND condition .)
    LPAREN          reduce using rule 85 (condition -> condition AND condition .)
    MINUS           reduce using rule 85 (condition -> condition AND condition .)
    LBRACE          reduce using rule 85 (condition -> condition AND condition .)
    LBRACKET        reduce using rule 85 (condition -> condition AND condition .)
    PUTS            reduce using rule 85 (condition -> condition AND condition .)
    FOR             reduce using rule 85 (condition -> condition AND condition .)
    IF              reduce using rule 85 (condition -> condition AND condition .)
    WHILE           reduce using rule 85 (condition -> condition AND condition .)
    DEF             reduce using rule 85 (condition -> condition AND condition .)
    CLASS           reduce using rule 85 (condition -> condition AND condition .)
    RETURN          reduce using rule 85 (condition -> condition AND condition .)
    ELSIF           reduce using rule 85 (condition -> condition AND condition .)
    NEWLINE         reduce using rule 85 (condition -> condition AND condition .)
    SEMICOLON       reduce using rule 85 (condition -> condition AND condition .)
    END             reduce using rule 85 (condition -> condition AND condition .)
    ELSE            reduce using rule 85 (condition -> condition AND condition .)
    LOGICAL_AND     shift and go to state 129
    LOGICAL_OR      shift and go to state 131

  ! LOGICAL_AND     [ reduce using rule 85 (condition -> condition AND condition .) ]
  ! LOGICAL_OR      [ reduce using rule 85 (condition -> condition AND condition .) ]
  ! AND             [ shift and go to state 130 ]
  ! OR              [ shift and go to state 132 ]


state 167

    (86) condition -> condition LOGICAL_OR condition .
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition

    AND             reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    LOGICAL_OR      reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    OR              reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    BREAK           reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    NEXT            reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    INTEGER         reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    FLOAT           reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    STRING          reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    SYMBOL          reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    REGEXP          reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    TRUE            reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    FALSE           reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    NIL             reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    IDENTIFIER      reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    INSTANCE_VARIABLE reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    CLASS_VARIABLE  reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    GLOBAL_VARIABLE reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    CONSTANT        reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    LPAREN          reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    MINUS           reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    LBRACE          reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    LBRACKET        reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    PUTS            reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    FOR             reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    IF              reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    WHILE           reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    DEF             reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    CLASS           reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    RETURN          reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    ELSIF           reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    NEWLINE         reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    SEMICOLON       reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    END             reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    ELSE            reduce using rule 86 (condition -> condition LOGICAL_OR condition .)
    LOGICAL_AND     shift and go to state 129

  ! LOGICAL_AND     [ reduce using rule 86 (condition -> condition LOGICAL_OR condition .) ]
  ! AND             [ shift and go to state 130 ]
  ! LOGICAL_OR      [ shift and go to state 131 ]
  ! OR              [ shift and go to state 132 ]


state 168

    (87) condition -> condition OR condition .
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition

    AND             reduce using rule 87 (condition -> condition OR condition .)
    OR              reduce using rule 87 (condition -> condition OR condition .)
    BREAK           reduce using rule 87 (condition -> condition OR condition .)
    NEXT            reduce using rule 87 (condition -> condition OR condition .)
    INTEGER         reduce using rule 87 (condition -> condition OR condition .)
    FLOAT           reduce using rule 87 (condition -> condition OR condition .)
    STRING          reduce using rule 87 (condition -> condition OR condition .)
    SYMBOL          reduce using rule 87 (condition -> condition OR condition .)
    REGEXP          reduce using rule 87 (condition -> condition OR condition .)
    TRUE            reduce using rule 87 (condition -> condition OR condition .)
    FALSE           reduce using rule 87 (condition -> condition OR condition .)
    NIL             reduce using rule 87 (condition -> condition OR condition .)
    IDENTIFIER      reduce using rule 87 (condition -> condition OR condition .)
    INSTANCE_VARIABLE reduce using rule 87 (condition -> condition OR condition .)
    CLASS_VARIABLE  reduce using rule 87 (condition -> condition OR condition .)
    GLOBAL_VARIABLE reduce using rule 87 (condition -> condition OR condition .)
    CONSTANT        reduce using rule 87 (condition -> condition OR condition .)
    LPAREN          reduce using rule 87 (condition -> condition OR condition .)
    MINUS           reduce using rule 87 (condition -> condition OR condition .)
    LBRACE          reduce using rule 87 (condition -> condition OR condition .)
    LBRACKET        reduce using rule 87 (condition -> condition OR condition .)
    PUTS            reduce using rule 87 (condition -> condition OR condition .)
    FOR             reduce using rule 87 (condition -> condition OR condition .)
    IF              reduce using rule 87 (condition -> condition OR condition .)
    WHILE           reduce using rule 87 (condition -> condition OR condition .)
    DEF             reduce using rule 87 (condition -> condition OR condition .)
    CLASS           reduce using rule 87 (condition -> condition OR condition .)
    RETURN          reduce using rule 87 (condition -> condition OR condition .)
    ELSIF           reduce using rule 87 (condition -> condition OR condition .)
    NEWLINE         reduce using rule 87 (condition -> condition OR condition .)
    SEMICOLON       reduce using rule 87 (condition -> condition OR condition .)
    END             reduce using rule 87 (condition -> condition OR condition .)
    ELSE            reduce using rule 87 (condition -> condition OR condition .)
    LOGICAL_AND     shift and go to state 129
    LOGICAL_OR      shift and go to state 131

  ! LOGICAL_AND     [ reduce using rule 87 (condition -> condition OR condition .) ]
  ! LOGICAL_OR      [ reduce using rule 87 (condition -> condition OR condition .) ]
  ! AND             [ shift and go to state 130 ]
  ! OR              [ shift and go to state 132 ]


state 169

    (76) condition -> expression EQUAL expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 76 (condition -> expression EQUAL expression .)
    AND             reduce using rule 76 (condition -> expression EQUAL expression .)
    LOGICAL_OR      reduce using rule 76 (condition -> expression EQUAL expression .)
    OR              reduce using rule 76 (condition -> expression EQUAL expression .)
    BREAK           reduce using rule 76 (condition -> expression EQUAL expression .)
    NEXT            reduce using rule 76 (condition -> expression EQUAL expression .)
    INTEGER         reduce using rule 76 (condition -> expression EQUAL expression .)
    FLOAT           reduce using rule 76 (condition -> expression EQUAL expression .)
    STRING          reduce using rule 76 (condition -> expression EQUAL expression .)
    SYMBOL          reduce using rule 76 (condition -> expression EQUAL expression .)
    REGEXP          reduce using rule 76 (condition -> expression EQUAL expression .)
    TRUE            reduce using rule 76 (condition -> expression EQUAL expression .)
    FALSE           reduce using rule 76 (condition -> expression EQUAL expression .)
    NIL             reduce using rule 76 (condition -> expression EQUAL expression .)
    IDENTIFIER      reduce using rule 76 (condition -> expression EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 76 (condition -> expression EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 76 (condition -> expression EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 76 (condition -> expression EQUAL expression .)
    CONSTANT        reduce using rule 76 (condition -> expression EQUAL expression .)
    LPAREN          reduce using rule 76 (condition -> expression EQUAL expression .)
    LBRACE          reduce using rule 76 (condition -> expression EQUAL expression .)
    LBRACKET        reduce using rule 76 (condition -> expression EQUAL expression .)
    PUTS            reduce using rule 76 (condition -> expression EQUAL expression .)
    FOR             reduce using rule 76 (condition -> expression EQUAL expression .)
    IF              reduce using rule 76 (condition -> expression EQUAL expression .)
    WHILE           reduce using rule 76 (condition -> expression EQUAL expression .)
    DEF             reduce using rule 76 (condition -> expression EQUAL expression .)
    CLASS           reduce using rule 76 (condition -> expression EQUAL expression .)
    RETURN          reduce using rule 76 (condition -> expression EQUAL expression .)
    ELSIF           reduce using rule 76 (condition -> expression EQUAL expression .)
    NEWLINE         reduce using rule 76 (condition -> expression EQUAL expression .)
    SEMICOLON       reduce using rule 76 (condition -> expression EQUAL expression .)
    END             reduce using rule 76 (condition -> expression EQUAL expression .)
    ELSE            reduce using rule 76 (condition -> expression EQUAL expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 76 (condition -> expression EQUAL expression .) ]


state 170

    (77) condition -> expression NOT_EQUAL expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    AND             reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    LOGICAL_OR      reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    OR              reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    BREAK           reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    NEXT            reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    INTEGER         reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    FLOAT           reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    STRING          reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    SYMBOL          reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    REGEXP          reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    TRUE            reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    FALSE           reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    NIL             reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    IDENTIFIER      reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    CONSTANT        reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    LPAREN          reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    LBRACE          reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    LBRACKET        reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    PUTS            reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    FOR             reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    IF              reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    WHILE           reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    DEF             reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    CLASS           reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    RETURN          reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    ELSIF           reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    NEWLINE         reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    SEMICOLON       reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    END             reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    ELSE            reduce using rule 77 (condition -> expression NOT_EQUAL expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 77 (condition -> expression NOT_EQUAL expression .) ]


state 171

    (78) condition -> expression GREATER expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 78 (condition -> expression GREATER expression .)
    AND             reduce using rule 78 (condition -> expression GREATER expression .)
    LOGICAL_OR      reduce using rule 78 (condition -> expression GREATER expression .)
    OR              reduce using rule 78 (condition -> expression GREATER expression .)
    BREAK           reduce using rule 78 (condition -> expression GREATER expression .)
    NEXT            reduce using rule 78 (condition -> expression GREATER expression .)
    INTEGER         reduce using rule 78 (condition -> expression GREATER expression .)
    FLOAT           reduce using rule 78 (condition -> expression GREATER expression .)
    STRING          reduce using rule 78 (condition -> expression GREATER expression .)
    SYMBOL          reduce using rule 78 (condition -> expression GREATER expression .)
    REGEXP          reduce using rule 78 (condition -> expression GREATER expression .)
    TRUE            reduce using rule 78 (condition -> expression GREATER expression .)
    FALSE           reduce using rule 78 (condition -> expression GREATER expression .)
    NIL             reduce using rule 78 (condition -> expression GREATER expression .)
    IDENTIFIER      reduce using rule 78 (condition -> expression GREATER expression .)
    INSTANCE_VARIABLE reduce using rule 78 (condition -> expression GREATER expression .)
    CLASS_VARIABLE  reduce using rule 78 (condition -> expression GREATER expression .)
    GLOBAL_VARIABLE reduce using rule 78 (condition -> expression GREATER expression .)
    CONSTANT        reduce using rule 78 (condition -> expression GREATER expression .)
    LPAREN          reduce using rule 78 (condition -> expression GREATER expression .)
    LBRACE          reduce using rule 78 (condition -> expression GREATER expression .)
    LBRACKET        reduce using rule 78 (condition -> expression GREATER expression .)
    PUTS            reduce using rule 78 (condition -> expression GREATER expression .)
    FOR             reduce using rule 78 (condition -> expression GREATER expression .)
    IF              reduce using rule 78 (condition -> expression GREATER expression .)
    WHILE           reduce using rule 78 (condition -> expression GREATER expression .)
    DEF             reduce using rule 78 (condition -> expression GREATER expression .)
    CLASS           reduce using rule 78 (condition -> expression GREATER expression .)
    RETURN          reduce using rule 78 (condition -> expression GREATER expression .)
    ELSIF           reduce using rule 78 (condition -> expression GREATER expression .)
    NEWLINE         reduce using rule 78 (condition -> expression GREATER expression .)
    SEMICOLON       reduce using rule 78 (condition -> expression GREATER expression .)
    END             reduce using rule 78 (condition -> expression GREATER expression .)
    ELSE            reduce using rule 78 (condition -> expression GREATER expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 78 (condition -> expression GREATER expression .) ]


state 172

    (79) condition -> expression LESS expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 79 (condition -> expression LESS expression .)
    AND             reduce using rule 79 (condition -> expression LESS expression .)
    LOGICAL_OR      reduce using rule 79 (condition -> expression LESS expression .)
    OR              reduce using rule 79 (condition -> expression LESS expression .)
    BREAK           reduce using rule 79 (condition -> expression LESS expression .)
    NEXT            reduce using rule 79 (condition -> expression LESS expression .)
    INTEGER         reduce using rule 79 (condition -> expression LESS expression .)
    FLOAT           reduce using rule 79 (condition -> expression LESS expression .)
    STRING          reduce using rule 79 (condition -> expression LESS expression .)
    SYMBOL          reduce using rule 79 (condition -> expression LESS expression .)
    REGEXP          reduce using rule 79 (condition -> expression LESS expression .)
    TRUE            reduce using rule 79 (condition -> expression LESS expression .)
    FALSE           reduce using rule 79 (condition -> expression LESS expression .)
    NIL             reduce using rule 79 (condition -> expression LESS expression .)
    IDENTIFIER      reduce using rule 79 (condition -> expression LESS expression .)
    INSTANCE_VARIABLE reduce using rule 79 (condition -> expression LESS expression .)
    CLASS_VARIABLE  reduce using rule 79 (condition -> expression LESS expression .)
    GLOBAL_VARIABLE reduce using rule 79 (condition -> expression LESS expression .)
    CONSTANT        reduce using rule 79 (condition -> expression LESS expression .)
    LPAREN          reduce using rule 79 (condition -> expression LESS expression .)
    LBRACE          reduce using rule 79 (condition -> expression LESS expression .)
    LBRACKET        reduce using rule 79 (condition -> expression LESS expression .)
    PUTS            reduce using rule 79 (condition -> expression LESS expression .)
    FOR             reduce using rule 79 (condition -> expression LESS expression .)
    IF              reduce using rule 79 (condition -> expression LESS expression .)
    WHILE           reduce using rule 79 (condition -> expression LESS expression .)
    DEF             reduce using rule 79 (condition -> expression LESS expression .)
    CLASS           reduce using rule 79 (condition -> expression LESS expression .)
    RETURN          reduce using rule 79 (condition -> expression LESS expression .)
    ELSIF           reduce using rule 79 (condition -> expression LESS expression .)
    NEWLINE         reduce using rule 79 (condition -> expression LESS expression .)
    SEMICOLON       reduce using rule 79 (condition -> expression LESS expression .)
    END             reduce using rule 79 (condition -> expression LESS expression .)
    ELSE            reduce using rule 79 (condition -> expression LESS expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 79 (condition -> expression LESS expression .) ]


state 173

    (80) condition -> expression GREATER_EQUAL expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    AND             reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    LOGICAL_OR      reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    OR              reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    BREAK           reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    NEXT            reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    INTEGER         reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    FLOAT           reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    STRING          reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    SYMBOL          reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    REGEXP          reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    TRUE            reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    FALSE           reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    NIL             reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    IDENTIFIER      reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    CONSTANT        reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    LPAREN          reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    LBRACE          reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    LBRACKET        reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    PUTS            reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    FOR             reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    IF              reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    WHILE           reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    DEF             reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    CLASS           reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    RETURN          reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    ELSIF           reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    NEWLINE         reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    SEMICOLON       reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    END             reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    ELSE            reduce using rule 80 (condition -> expression GREATER_EQUAL expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 80 (condition -> expression GREATER_EQUAL expression .) ]


state 174

    (81) condition -> expression LESS_EQUAL expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    AND             reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    LOGICAL_OR      reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    OR              reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    BREAK           reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    NEXT            reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    INTEGER         reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    FLOAT           reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    STRING          reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    SYMBOL          reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    REGEXP          reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    TRUE            reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    FALSE           reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    NIL             reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    IDENTIFIER      reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    CONSTANT        reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    LPAREN          reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    LBRACE          reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    LBRACKET        reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    PUTS            reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    FOR             reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    IF              reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    WHILE           reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    DEF             reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    CLASS           reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    RETURN          reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    ELSIF           reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    NEWLINE         reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    SEMICOLON       reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    END             reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    ELSE            reduce using rule 81 (condition -> expression LESS_EQUAL expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 81 (condition -> expression LESS_EQUAL expression .) ]


state 175

    (82) condition -> expression SPACESHIP expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 82 (condition -> expression SPACESHIP expression .)
    AND             reduce using rule 82 (condition -> expression SPACESHIP expression .)
    LOGICAL_OR      reduce using rule 82 (condition -> expression SPACESHIP expression .)
    OR              reduce using rule 82 (condition -> expression SPACESHIP expression .)
    BREAK           reduce using rule 82 (condition -> expression SPACESHIP expression .)
    NEXT            reduce using rule 82 (condition -> expression SPACESHIP expression .)
    INTEGER         reduce using rule 82 (condition -> expression SPACESHIP expression .)
    FLOAT           reduce using rule 82 (condition -> expression SPACESHIP expression .)
    STRING          reduce using rule 82 (condition -> expression SPACESHIP expression .)
    SYMBOL          reduce using rule 82 (condition -> expression SPACESHIP expression .)
    REGEXP          reduce using rule 82 (condition -> expression SPACESHIP expression .)
    TRUE            reduce using rule 82 (condition -> expression SPACESHIP expression .)
    FALSE           reduce using rule 82 (condition -> expression SPACESHIP expression .)
    NIL             reduce using rule 82 (condition -> expression SPACESHIP expression .)
    IDENTIFIER      reduce using rule 82 (condition -> expression SPACESHIP expression .)
    INSTANCE_VARIABLE reduce using rule 82 (condition -> expression SPACESHIP expression .)
    CLASS_VARIABLE  reduce using rule 82 (condition -> expression SPACESHIP expression .)
    GLOBAL_VARIABLE reduce using rule 82 (condition -> expression SPACESHIP expression .)
    CONSTANT        reduce using rule 82 (condition -> expression SPACESHIP expression .)
    LPAREN          reduce using rule 82 (condition -> expression SPACESHIP expression .)
    LBRACE          reduce using rule 82 (condition -> expression SPACESHIP expression .)
    LBRACKET        reduce using rule 82 (condition -> expression SPACESHIP expression .)
    PUTS            reduce using rule 82 (condition -> expression SPACESHIP expression .)
    FOR             reduce using rule 82 (condition -> expression SPACESHIP expression .)
    IF              reduce using rule 82 (condition -> expression SPACESHIP expression .)
    WHILE           reduce using rule 82 (condition -> expression SPACESHIP expression .)
    DEF             reduce using rule 82 (condition -> expression SPACESHIP expression .)
    CLASS           reduce using rule 82 (condition -> expression SPACESHIP expression .)
    RETURN          reduce using rule 82 (condition -> expression SPACESHIP expression .)
    ELSIF           reduce using rule 82 (condition -> expression SPACESHIP expression .)
    NEWLINE         reduce using rule 82 (condition -> expression SPACESHIP expression .)
    SEMICOLON       reduce using rule 82 (condition -> expression SPACESHIP expression .)
    END             reduce using rule 82 (condition -> expression SPACESHIP expression .)
    ELSE            reduce using rule 82 (condition -> expression SPACESHIP expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 82 (condition -> expression SPACESHIP expression .) ]


state 176

    (83) condition -> expression CASE_EQUAL expression .
    (35) expression -> expression . RANGE_INCLUSIVE expression
    (36) expression -> expression . RANGE_EXCLUSIVE expression
    (38) expression -> expression . DOT IDENTIFIER
    (39) expression -> expression . DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> expression . DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

    LOGICAL_AND     reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    AND             reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    LOGICAL_OR      reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    OR              reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    BREAK           reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    NEXT            reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    INTEGER         reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    FLOAT           reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    STRING          reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    SYMBOL          reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    REGEXP          reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    TRUE            reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    FALSE           reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    NIL             reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    IDENTIFIER      reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    CONSTANT        reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    LPAREN          reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    LBRACE          reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    LBRACKET        reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    PUTS            reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    FOR             reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    IF              reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    WHILE           reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    DEF             reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    CLASS           reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    RETURN          reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    ELSIF           reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    NEWLINE         reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    SEMICOLON       reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    END             reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    ELSE            reduce using rule 83 (condition -> expression CASE_EQUAL expression .)
    RANGE_INCLUSIVE shift and go to state 48
    RANGE_EXCLUSIVE shift and go to state 49
    DOT             shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MODULE_OP       shift and go to state 55
    POWER           shift and go to state 56

  ! MINUS           [ reduce using rule 83 (condition -> expression CASE_EQUAL expression .) ]


state 177

    (105) control_statement -> WHILE condition enter_loop_scope statements . optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 194
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 178

    (62) function_definition -> DEF func_name_hook func_header statements . optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 195
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 179

    (64) func_header -> LPAREN param_list . RPAREN

    RPAREN          shift and go to state 196


state 180

    (65) func_header -> LPAREN RPAREN .

    BREAK           reduce using rule 65 (func_header -> LPAREN RPAREN .)
    NEXT            reduce using rule 65 (func_header -> LPAREN RPAREN .)
    INTEGER         reduce using rule 65 (func_header -> LPAREN RPAREN .)
    FLOAT           reduce using rule 65 (func_header -> LPAREN RPAREN .)
    STRING          reduce using rule 65 (func_header -> LPAREN RPAREN .)
    SYMBOL          reduce using rule 65 (func_header -> LPAREN RPAREN .)
    REGEXP          reduce using rule 65 (func_header -> LPAREN RPAREN .)
    TRUE            reduce using rule 65 (func_header -> LPAREN RPAREN .)
    FALSE           reduce using rule 65 (func_header -> LPAREN RPAREN .)
    NIL             reduce using rule 65 (func_header -> LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 65 (func_header -> LPAREN RPAREN .)
    INSTANCE_VARIABLE reduce using rule 65 (func_header -> LPAREN RPAREN .)
    CLASS_VARIABLE  reduce using rule 65 (func_header -> LPAREN RPAREN .)
    GLOBAL_VARIABLE reduce using rule 65 (func_header -> LPAREN RPAREN .)
    CONSTANT        reduce using rule 65 (func_header -> LPAREN RPAREN .)
    LPAREN          reduce using rule 65 (func_header -> LPAREN RPAREN .)
    MINUS           reduce using rule 65 (func_header -> LPAREN RPAREN .)
    LBRACE          reduce using rule 65 (func_header -> LPAREN RPAREN .)
    LBRACKET        reduce using rule 65 (func_header -> LPAREN RPAREN .)
    PUTS            reduce using rule 65 (func_header -> LPAREN RPAREN .)
    FOR             reduce using rule 65 (func_header -> LPAREN RPAREN .)
    IF              reduce using rule 65 (func_header -> LPAREN RPAREN .)
    WHILE           reduce using rule 65 (func_header -> LPAREN RPAREN .)
    DEF             reduce using rule 65 (func_header -> LPAREN RPAREN .)
    CLASS           reduce using rule 65 (func_header -> LPAREN RPAREN .)
    RETURN          reduce using rule 65 (func_header -> LPAREN RPAREN .)
    NEWLINE         reduce using rule 65 (func_header -> LPAREN RPAREN .)
    SEMICOLON       reduce using rule 65 (func_header -> LPAREN RPAREN .)
    END             reduce using rule 65 (func_header -> LPAREN RPAREN .)


state 181

    (58) param_list -> IDENTIFIER . COMMA param_list
    (59) param_list -> IDENTIFIER .

    COMMA           shift and go to state 197
    RPAREN          reduce using rule 59 (param_list -> IDENTIFIER .)


state 182

    (56) class_definition -> CLASS CONSTANT enter_scope statements . optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 198
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 183

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT . enter_scope statements optional_newlines exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 199
    empty                          shift and go to state 133

state 184

    (39) expression -> expression DOT IDENTIFIER LPAREN arguments . RPAREN
    (109) arguments -> arguments . COMMA expression

    RPAREN          shift and go to state 200
    COMMA           shift and go to state 110


state 185

    (40) expression -> expression DOT IDENTIFIER LPAREN RPAREN .

    RANGE_INCLUSIVE reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    MODULE_OP       reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    POWER           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    NEWLINE         reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    SEMICOLON       reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    END             reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    ELSIF           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    ELSE            reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    HASH_ROCKET     reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    EQUAL           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    GREATER         reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    LESS            reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    GREATER_EQUAL   reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    LESS_EQUAL      reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    SPACESHIP       reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    CASE_EQUAL      reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    LOGICAL_AND     reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    LOGICAL_OR      reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    BREAK           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    NEXT            reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    INTEGER         reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    FLOAT           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    STRING          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    SYMBOL          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    REGEXP          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    TRUE            reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    FALSE           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    NIL             reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    INSTANCE_VARIABLE reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    CLASS_VARIABLE  reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    GLOBAL_VARIABLE reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    CONSTANT        reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    LPAREN          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    LBRACKET        reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    PUTS            reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    DEF             reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    CLASS           reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 40 (expression -> expression DOT IDENTIFIER LPAREN RPAREN .)


state 186

    (37) expression -> IDENTIFIER LBRACKET expression RBRACKET .

    COMMA           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DOT             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MODULE_OP       reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    POWER           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NEWLINE         reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    $end            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    END             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    ELSIF           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    HASH_ROCKET     reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    EQUAL           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NOT_EQUAL       reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER         reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_EQUAL   reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_EQUAL      reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    SPACESHIP       reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    CASE_EQUAL      reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LOGICAL_AND     reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    AND             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LOGICAL_OR      reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    OR              reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    BREAK           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NEXT            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    INTEGER         reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    FLOAT           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    STRING          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    SYMBOL          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    REGEXP          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    TRUE            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    FALSE           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NIL             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    IDENTIFIER      reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    INSTANCE_VARIABLE reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    CLASS_VARIABLE  reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GLOBAL_VARIABLE reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    CONSTANT        reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    PUTS            reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    FOR             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    IF              reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    WHILE           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DEF             reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    CLASS           reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RETURN          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 37 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)


state 187

    (74) io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .

    NEWLINE         reduce using rule 74 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 74 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    $end            reduce using rule 74 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    END             reduce using rule 74 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    ELSIF           reduce using rule 74 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    ELSE            reduce using rule 74 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)


state 188

    (97) control_statement -> FOR for_setup statements optional_newlines exit_scope . END

    END             shift and go to state 201


state 189

    (4) exit_scope -> empty .

    END             reduce using rule 4 (exit_scope -> empty .)
    ELSE            reduce using rule 4 (exit_scope -> empty .)


state 190

    (98) for_setup -> IDENTIFIER IN expression enter_loop_scope .

    BREAK           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    NEXT            reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    INTEGER         reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    FLOAT           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    STRING          reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    SYMBOL          reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    REGEXP          reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    TRUE            reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    FALSE           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    NIL             reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    IDENTIFIER      reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    INSTANCE_VARIABLE reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    CLASS_VARIABLE  reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    GLOBAL_VARIABLE reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    CONSTANT        reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    LPAREN          reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    MINUS           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    LBRACE          reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    LBRACKET        reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    PUTS            reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    FOR             reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    IF              reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    WHILE           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    DEF             reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    CLASS           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    RETURN          reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    NEWLINE         reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    SEMICOLON       reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    END             reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)


state 191

    (99) control_statement -> IF condition enter_scope statements optional_newlines . exit_scope END
    (100) control_statement -> IF condition enter_scope statements optional_newlines . exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 202
    empty                          shift and go to state 189

state 192

    (101) control_statement -> IF condition enter_scope statements elsif_clauses . optional_newlines exit_scope END
    (102) control_statement -> IF condition enter_scope statements elsif_clauses . ELSE enter_scope statements optional_newlines exit_scope END
    (103) elsif_clauses -> elsif_clauses . ELSIF condition statements optional_newlines
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    ELSE            shift and go to state 204
    ELSIF           shift and go to state 205
    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 203
    statement_separator            shift and go to state 3
    empty                          shift and go to state 4

state 193

    (104) elsif_clauses -> ELSIF . condition statements optional_newlines
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 206
    expression                     shift and go to state 87

state 194

    (105) control_statement -> WHILE condition enter_loop_scope statements optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 207
    empty                          shift and go to state 189

state 195

    (62) function_definition -> DEF func_name_hook func_header statements optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 208
    empty                          shift and go to state 189

state 196

    (64) func_header -> LPAREN param_list RPAREN .

    BREAK           reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    NEXT            reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    INTEGER         reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    FLOAT           reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    STRING          reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    SYMBOL          reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    REGEXP          reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    TRUE            reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    FALSE           reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    NIL             reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    IDENTIFIER      reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    INSTANCE_VARIABLE reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    CLASS_VARIABLE  reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    GLOBAL_VARIABLE reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    CONSTANT        reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    LPAREN          reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    MINUS           reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    LBRACE          reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    LBRACKET        reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    PUTS            reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    FOR             reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    IF              reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    WHILE           reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    DEF             reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    CLASS           reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    RETURN          reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    NEWLINE         reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    SEMICOLON       reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)
    END             reduce using rule 64 (func_header -> LPAREN param_list RPAREN .)


state 197

    (58) param_list -> IDENTIFIER COMMA . param_list
    (58) param_list -> . IDENTIFIER COMMA param_list
    (59) param_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 181

    param_list                     shift and go to state 209

state 198

    (56) class_definition -> CLASS CONSTANT enter_scope statements optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 210
    empty                          shift and go to state 189

state 199

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope . statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 211
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 200

    (39) expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .

    RANGE_INCLUSIVE reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    DOT             reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    PLUS            reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    MINUS           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    TIMES           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    MODULE_OP       reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    POWER           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    NEWLINE         reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    $end            reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    COMMA           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    END             reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    ELSIF           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    ELSE            reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    RBRACKET        reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    HASH_ROCKET     reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    NOT_EQUAL       reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    GREATER         reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    LESS            reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    GREATER_EQUAL   reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    LESS_EQUAL      reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    SPACESHIP       reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    CASE_EQUAL      reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    LOGICAL_AND     reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    AND             reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    LOGICAL_OR      reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    OR              reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    BREAK           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    NEXT            reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    INTEGER         reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    FLOAT           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    STRING          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    SYMBOL          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    REGEXP          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    TRUE            reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    FALSE           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    NIL             reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    IDENTIFIER      reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    INSTANCE_VARIABLE reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    CLASS_VARIABLE  reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    GLOBAL_VARIABLE reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    CONSTANT        reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    LPAREN          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    LBRACE          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    LBRACKET        reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    PUTS            reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    FOR             reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    IF              reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    WHILE           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    DEF             reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    CLASS           reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    RETURN          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 39 (expression -> expression DOT IDENTIFIER LPAREN arguments RPAREN .)


state 201

    (97) control_statement -> FOR for_setup statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 97 (control_statement -> FOR for_setup statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 97 (control_statement -> FOR for_setup statements optional_newlines exit_scope END .)
    $end            reduce using rule 97 (control_statement -> FOR for_setup statements optional_newlines exit_scope END .)
    END             reduce using rule 97 (control_statement -> FOR for_setup statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 97 (control_statement -> FOR for_setup statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 97 (control_statement -> FOR for_setup statements optional_newlines exit_scope END .)


state 202

    (99) control_statement -> IF condition enter_scope statements optional_newlines exit_scope . END
    (100) control_statement -> IF condition enter_scope statements optional_newlines exit_scope . ELSE enter_scope statements optional_newlines exit_scope END

    END             shift and go to state 212
    ELSE            shift and go to state 213


state 203

    (101) control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 214
    empty                          shift and go to state 189

state 204

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE . enter_scope statements optional_newlines exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 215
    empty                          shift and go to state 133

state 205

    (103) elsif_clauses -> elsif_clauses ELSIF . condition statements optional_newlines
    (76) condition -> . expression EQUAL expression
    (77) condition -> . expression NOT_EQUAL expression
    (78) condition -> . expression GREATER expression
    (79) condition -> . expression LESS expression
    (80) condition -> . expression GREATER_EQUAL expression
    (81) condition -> . expression LESS_EQUAL expression
    (82) condition -> . expression SPACESHIP expression
    (83) condition -> . expression CASE_EQUAL expression
    (84) condition -> . condition LOGICAL_AND condition
    (85) condition -> . condition AND condition
    (86) condition -> . condition LOGICAL_OR condition
    (87) condition -> . condition OR condition
    (88) condition -> . LOGICAL_NOT condition
    (89) condition -> . NOT condition
    (90) condition -> . expression
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 88
    NOT             shift and go to state 89
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    INSTANCE_VARIABLE shift and go to state 63
    CLASS_VARIABLE  shift and go to state 64
    GLOBAL_VARIABLE shift and go to state 65
    CONSTANT        shift and go to state 66
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32

    condition                      shift and go to state 216
    expression                     shift and go to state 87

state 206

    (104) elsif_clauses -> ELSIF condition . statements optional_newlines
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    LOGICAL_AND     shift and go to state 129
    AND             shift and go to state 130
    LOGICAL_OR      shift and go to state 131
    OR              shift and go to state 132
    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 217
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 207

    (105) control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope . END

    END             shift and go to state 218


state 208

    (62) function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope . END

    END             shift and go to state 219


state 209

    (58) param_list -> IDENTIFIER COMMA param_list .

    RPAREN          reduce using rule 58 (param_list -> IDENTIFIER COMMA param_list .)


state 210

    (56) class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope . END

    END             shift and go to state 220


state 211

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements . optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 221
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 212

    (99) control_statement -> IF condition enter_scope statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 99 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 99 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope END .)
    $end            reduce using rule 99 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope END .)
    END             reduce using rule 99 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 99 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 99 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope END .)


state 213

    (100) control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE . enter_scope statements optional_newlines exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    INTEGER         reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    STRING          reduce using rule 1 (empty -> .)
    SYMBOL          reduce using rule 1 (empty -> .)
    REGEXP          reduce using rule 1 (empty -> .)
    TRUE            reduce using rule 1 (empty -> .)
    FALSE           reduce using rule 1 (empty -> .)
    NIL             reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    LBRACE          reduce using rule 1 (empty -> .)
    LBRACKET        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 222
    empty                          shift and go to state 133

state 214

    (101) control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope . END

    END             shift and go to state 223


state 215

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope . statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 224
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 216

    (103) elsif_clauses -> elsif_clauses ELSIF condition . statements optional_newlines
    (84) condition -> condition . LOGICAL_AND condition
    (85) condition -> condition . AND condition
    (86) condition -> condition . LOGICAL_OR condition
    (87) condition -> condition . OR condition
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    LOGICAL_AND     shift and go to state 129
    AND             shift and go to state 130
    LOGICAL_OR      shift and go to state 131
    OR              shift and go to state 132
    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 225
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 217

    (104) elsif_clauses -> ELSIF condition statements . optional_newlines
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

  ! NEWLINE         [ reduce using rule 1 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 1 (empty -> .) ]

    optional_newlines              shift and go to state 226
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 218

    (105) control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END .)
    $end            reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END .)
    END             reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements optional_newlines exit_scope END .)


state 219

    (62) function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 62 (function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 62 (function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END .)
    $end            reduce using rule 62 (function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END .)
    END             reduce using rule 62 (function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 62 (function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 62 (function_definition -> DEF func_name_hook func_header statements optional_newlines exit_scope END .)


state 220

    (56) class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    $end            reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    END             reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements optional_newlines exit_scope END .)


state 221

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 227
    empty                          shift and go to state 189

state 222

    (100) control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope . statements optional_newlines exit_scope END
    (6) statements -> . statements statement_separator statement
    (7) statements -> . statement
    (8) statements -> . empty
    (15) statement -> . expression
    (16) statement -> . assignment
    (17) statement -> . io_statement
    (18) statement -> . control_statement
    (19) statement -> . function_definition
    (20) statement -> . class_definition
    (21) statement -> . return_statement
    (111) statement -> . BREAK
    (112) statement -> . NEXT
    (1) empty -> .
    (22) expression -> . INTEGER
    (23) expression -> . FLOAT
    (24) expression -> . STRING
    (25) expression -> . SYMBOL
    (26) expression -> . REGEXP
    (27) expression -> . TRUE
    (28) expression -> . FALSE
    (29) expression -> . NIL
    (30) expression -> . IDENTIFIER
    (31) expression -> . INSTANCE_VARIABLE
    (32) expression -> . CLASS_VARIABLE
    (33) expression -> . GLOBAL_VARIABLE
    (34) expression -> . CONSTANT
    (35) expression -> . expression RANGE_INCLUSIVE expression
    (36) expression -> . expression RANGE_EXCLUSIVE expression
    (37) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (38) expression -> . expression DOT IDENTIFIER
    (39) expression -> . expression DOT IDENTIFIER LPAREN arguments RPAREN
    (40) expression -> . expression DOT IDENTIFIER LPAREN RPAREN
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (91) expression -> . LBRACKET array_elements RBRACKET
    (92) expression -> . LBRACKET RBRACKET
    (106) expression -> . IDENTIFIER LPAREN arguments RPAREN
    (107) expression -> . IDENTIFIER LPAREN RPAREN
    (108) expression -> . IDENTIFIER arguments
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . assignment_array ASSIGN expression
    (74) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (75) io_statement -> . IDENTIFIER ASSIGN GETS
    (95) io_statement -> . PUTS expression
    (96) io_statement -> . PUTS
    (97) control_statement -> . FOR for_setup statements optional_newlines exit_scope END
    (99) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope END
    (100) control_statement -> . IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements optional_newlines exit_scope END
    (62) function_definition -> . DEF func_name_hook func_header statements optional_newlines exit_scope END
    (56) class_definition -> . CLASS CONSTANT enter_scope statements optional_newlines exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END
    (60) return_statement -> . RETURN expression
    (61) return_statement -> . RETURN
    (47) assignment_array -> . IDENTIFIER LBRACKET expression RBRACKET

    BREAK           shift and go to state 17
    NEXT            shift and go to state 18
    NEWLINE         reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    SYMBOL          shift and go to state 22
    REGEXP          shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    NIL             shift and go to state 26
    IDENTIFIER      shift and go to state 27
    INSTANCE_VARIABLE shift and go to state 28
    CLASS_VARIABLE  shift and go to state 29
    GLOBAL_VARIABLE shift and go to state 30
    CONSTANT        shift and go to state 31
    LPAREN          shift and go to state 33
    MINUS           shift and go to state 34
    LBRACE          shift and go to state 35
    LBRACKET        shift and go to state 32
    PUTS            shift and go to state 37
    FOR             shift and go to state 38
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    DEF             shift and go to state 41
    CLASS           shift and go to state 42
    RETURN          shift and go to state 43

    statements                     shift and go to state 228
    statement                      shift and go to state 8
    empty                          shift and go to state 9
    expression                     shift and go to state 10
    assignment                     shift and go to state 11
    io_statement                   shift and go to state 12
    control_statement              shift and go to state 13
    function_definition            shift and go to state 14
    class_definition               shift and go to state 15
    return_statement               shift and go to state 16
    assignment_array               shift and go to state 36

state 223

    (101) control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END .

    NEWLINE         reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END .)
    $end            reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END .)
    END             reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END .)
    ELSIF           reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END .)
    ELSE            reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses optional_newlines exit_scope END .)


state 224

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements . optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 229
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 225

    (103) elsif_clauses -> elsif_clauses ELSIF condition statements . optional_newlines
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

  ! NEWLINE         [ reduce using rule 1 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 1 (empty -> .) ]

    optional_newlines              shift and go to state 230
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 226

    (104) elsif_clauses -> ELSIF condition statements optional_newlines .

    ELSE            reduce using rule 104 (elsif_clauses -> ELSIF condition statements optional_newlines .)
    ELSIF           reduce using rule 104 (elsif_clauses -> ELSIF condition statements optional_newlines .)
    NEWLINE         reduce using rule 104 (elsif_clauses -> ELSIF condition statements optional_newlines .)
    SEMICOLON       reduce using rule 104 (elsif_clauses -> ELSIF condition statements optional_newlines .)
    END             reduce using rule 104 (elsif_clauses -> ELSIF condition statements optional_newlines .)


state 227

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope . END

    END             shift and go to state 231


state 228

    (100) control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements . optional_newlines exit_scope END
    (6) statements -> statements . statement_separator statement
    (13) optional_newlines -> . statement_separator
    (14) optional_newlines -> . empty
    (9) statement_separator -> . NEWLINE
    (10) statement_separator -> . SEMICOLON
    (11) statement_separator -> . statement_separator NEWLINE
    (12) statement_separator -> . statement_separator SEMICOLON
    (1) empty -> .

    NEWLINE         shift and go to state 5
    SEMICOLON       shift and go to state 6
    END             reduce using rule 1 (empty -> .)

    optional_newlines              shift and go to state 232
    statement_separator            shift and go to state 47
    empty                          shift and go to state 4

state 229

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 233
    empty                          shift and go to state 189

state 230

    (103) elsif_clauses -> elsif_clauses ELSIF condition statements optional_newlines .

    ELSE            reduce using rule 103 (elsif_clauses -> elsif_clauses ELSIF condition statements optional_newlines .)
    ELSIF           reduce using rule 103 (elsif_clauses -> elsif_clauses ELSIF condition statements optional_newlines .)
    NEWLINE         reduce using rule 103 (elsif_clauses -> elsif_clauses ELSIF condition statements optional_newlines .)
    SEMICOLON       reduce using rule 103 (elsif_clauses -> elsif_clauses ELSIF condition statements optional_newlines .)
    END             reduce using rule 103 (elsif_clauses -> elsif_clauses ELSIF condition statements optional_newlines .)


state 231

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    $end            reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    END             reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements optional_newlines exit_scope END .)


state 232

    (100) control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines . exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 234
    empty                          shift and go to state 189

state 233

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope . END

    END             shift and go to state 235


state 234

    (100) control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope . END

    END             shift and go to state 236


state 235

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END .)
    $end            reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END .)
    END             reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements optional_newlines exit_scope END .)


state 236

    (100) control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END .

    NEWLINE         reduce using rule 100 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END .)
    SEMICOLON       reduce using rule 100 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END .)
    $end            reduce using rule 100 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END .)
    END             reduce using rule 100 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END .)
    ELSIF           reduce using rule 100 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END .)
    ELSE            reduce using rule 100 (control_statement -> IF condition enter_scope statements optional_newlines exit_scope ELSE enter_scope statements optional_newlines exit_scope END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 0 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 0 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 3 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 3 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 27 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 47 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 47 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 57 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 57 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 57 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 57 resolved as shift
WARNING: shift/reduce conflict for STRING in state 57 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 57 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 57 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 57 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 57 resolved as shift
WARNING: shift/reduce conflict for NIL in state 57 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 57 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VARIABLE in state 57 resolved as shift
WARNING: shift/reduce conflict for CLASS_VARIABLE in state 57 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VARIABLE in state 57 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 57 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 57 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 59 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 59 resolved as shift
WARNING: shift/reduce conflict for DOT in state 59 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 59 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 59 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 59 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 59 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 59 resolved as shift
WARNING: shift/reduce conflict for POWER in state 59 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 61 resolved as shift
WARNING: shift/reduce conflict for HASH_ROCKET in state 80 resolved as shift
WARNING: shift/reduce conflict for HASH_ROCKET in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 87 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 91 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 96 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 96 resolved as shift
WARNING: shift/reduce conflict for DOT in state 96 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 96 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 96 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 96 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 96 resolved as shift
WARNING: shift/reduce conflict for POWER in state 96 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 97 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 97 resolved as shift
WARNING: shift/reduce conflict for DOT in state 97 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 97 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 97 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 97 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 97 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 97 resolved as shift
WARNING: shift/reduce conflict for POWER in state 97 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 98 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 106 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 109 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 143 resolved as shift
WARNING: shift/reduce conflict for OR in state 143 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 152 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 155 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 155 resolved as shift
WARNING: shift/reduce conflict for DOT in state 155 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 155 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 155 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 155 resolved as shift
WARNING: shift/reduce conflict for POWER in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 217 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 217 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 225 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 225 resolved as shift
