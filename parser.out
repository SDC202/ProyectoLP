Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    BEGIN
    CASE
    DO
    ENSURE
    MODULE
    NEWLINE
    RESCUE
    RETRY
    SCOPE
    SELF
    SUPER
    THEN
    UNLESS
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     enter_scope -> empty
Rule 3     enter_loop_scope -> empty
Rule 4     exit_scope -> empty
Rule 5     program -> statements
Rule 6     statements -> statements statement
Rule 7     statements -> empty
Rule 8     statement -> assignment
Rule 9     statement -> special_assignment
Rule 10    statement -> io_statement
Rule 11    statement -> control_statement
Rule 12    statement -> function_definition
Rule 13    statement -> return_statement
Rule 14    statement -> class_definition
Rule 15    statement -> SEMICOLON
Rule 16    expression -> INTEGER
Rule 17    expression -> FLOAT
Rule 18    expression -> STRING
Rule 19    expression -> SYMBOL
Rule 20    expression -> REGEXP
Rule 21    expression -> TRUE
Rule 22    expression -> FALSE
Rule 23    expression -> NIL
Rule 24    expression -> condition
Rule 25    expression -> IDENTIFIER
Rule 26    expression -> INSTANCE_VARIABLE
Rule 27    expression -> CLASS_VARIABLE
Rule 28    expression -> GLOBAL_VARIABLE
Rule 29    expression -> CONSTANT
Rule 30    expression -> array_access
Rule 31    expression -> expression RANGE_EXCLUSIVE expression
Rule 32    expression -> expression RANGE_INCLUSIVE expression
Rule 33    expression -> IDENTIFIER DOT IDENTIFIER
Rule 34    expression -> IDENTIFIER DOT function_call
Rule 35    special_assignment -> IDENTIFIER PLUS_ASSIGN expression
Rule 36    special_assignment -> IDENTIFIER MINUS_ASSIGN expression
Rule 37    special_assignment -> IDENTIFIER TIMES_ASSIGN expression
Rule 38    special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression
Rule 39    special_assignment -> IDENTIFIER MOD_ASSIGN expression
Rule 40    special_assignment -> IDENTIFIER POWER_ASSIGN expression
Rule 41    assignment -> IDENTIFIER ASSIGN expression
Rule 42    assignment -> INSTANCE_VARIABLE ASSIGN expression
Rule 43    assignment -> CLASS_VARIABLE ASSIGN expression
Rule 44    assignment -> GLOBAL_VARIABLE ASSIGN expression
Rule 45    assignment -> CONSTANT ASSIGN expression
Rule 46    assignment -> array_access ASSIGN expression
Rule 47    array_access -> IDENTIFIER LBRACKET expression RBRACKET
Rule 48    expression -> expression PLUS expression
Rule 49    expression -> expression MINUS expression
Rule 50    expression -> expression TIMES expression
Rule 51    expression -> expression DIVIDE expression
Rule 52    expression -> expression MODULE_OP expression
Rule 53    expression -> expression POWER expression
Rule 54    expression -> LPAREN expression RPAREN
Rule 55    expression -> MINUS expression
Rule 56    class_definition -> CLASS CONSTANT enter_scope statements exit_scope END
Rule 57    class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
Rule 58    param_list -> IDENTIFIER COMMA param_list
Rule 59    param_list -> IDENTIFIER
Rule 60    function_definition -> DEF func_name_hook func_header statements exit_scope END
Rule 61    func_name_hook -> IDENTIFIER
Rule 62    func_header -> LPAREN param_list RPAREN
Rule 63    func_header -> LPAREN RPAREN
Rule 64    func_header -> empty
Rule 65    return_statement -> RETURN expression
Rule 66    return_statement -> RETURN
Rule 67    expression -> LBRACE hash_pairs RBRACE
Rule 68    expression -> LBRACE RBRACE
Rule 69    hash_pairs -> hash_pairs COMMA hash_pair
Rule 70    hash_pairs -> hash_pair
Rule 71    hash_pair -> expression HASH_ROCKET expression
Rule 72    hash_pair -> SYMBOL HASH_ROCKET expression
Rule 73    hash_pair -> STRING HASH_ROCKET expression
Rule 74    io_statement -> PUTS expression
Rule 75    io_statement -> PUTS
Rule 76    io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER
Rule 77    io_statement -> IDENTIFIER ASSIGN GETS
Rule 78    condition -> expression EQUAL expression
Rule 79    condition -> expression NOT_EQUAL expression
Rule 80    condition -> expression GREATER expression
Rule 81    condition -> expression LESS expression
Rule 82    condition -> expression GREATER_EQUAL expression
Rule 83    condition -> expression LESS_EQUAL expression
Rule 84    condition -> expression SPACESHIP expression
Rule 85    condition -> expression CASE_EQUAL expression
Rule 86    condition -> condition LOGICAL_AND condition
Rule 87    condition -> condition AND condition
Rule 88    condition -> condition LOGICAL_OR condition
Rule 89    condition -> condition OR condition
Rule 90    condition -> LOGICAL_NOT condition
Rule 91    condition -> NOT condition
Rule 92    condition -> expression
Rule 93    expression -> LBRACKET array_elements RBRACKET
Rule 94    expression -> LBRACKET RBRACKET
Rule 95    array_elements -> array_elements COMMA expression
Rule 96    array_elements -> expression
Rule 97    control_statement -> FOR for_setup statements exit_scope END
Rule 98    for_setup -> IDENTIFIER IN expression enter_loop_scope
Rule 99    control_statement -> IF condition enter_scope statements exit_scope END
Rule 100   control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
Rule 101   control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END
Rule 102   control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
Rule 103   elsif_clauses -> ELSIF condition statements elsif_clauses
Rule 104   elsif_clauses -> ELSIF condition statements
Rule 105   control_statement -> WHILE condition enter_loop_scope statements exit_scope END
Rule 106   expression -> function_call
Rule 107   function_call -> IDENTIFIER LPAREN arguments RPAREN
Rule 108   function_call -> IDENTIFIER LPAREN RPAREN
Rule 109   function_call -> IDENTIFIER arguments
Rule 110   arguments -> arguments COMMA expression
Rule 111   arguments -> expression
Rule 112   statement -> BREAK
Rule 113   statement -> NEXT

Terminals, with rules where they appear

ALIAS                : 
AND                  : 87
ASSIGN               : 41 42 43 44 45 46 76 77
BEGIN                : 
BREAK                : 112
CASE                 : 
CASE_EQUAL           : 85
CLASS                : 56 57
CLASS_VARIABLE       : 27 43
COMMA                : 58 69 95 110
CONSTANT             : 29 45 56 57 57
DEF                  : 60
DIVIDE               : 51
DIVIDE_ASSIGN        : 38
DO                   : 
DOT                  : 33 34 76
ELSE                 : 100 102
ELSIF                : 103 104
END                  : 56 57 60 97 99 100 101 102 105
ENSURE               : 
EQUAL                : 78
FALSE                : 22
FLOAT                : 17
FOR                  : 97
GETS                 : 76 77
GLOBAL_VARIABLE      : 28 44
GREATER              : 80
GREATER_EQUAL        : 82
HASH_ROCKET          : 71 72 73
IDENTIFIER           : 25 33 33 34 35 36 37 38 39 40 41 47 58 59 61 76 76 77 98 107 108 109
IF                   : 99 100 101 102
IN                   : 98
INSTANCE_VARIABLE    : 26 42
INTEGER              : 16
LBRACE               : 67 68
LBRACKET             : 47 93 94
LESS                 : 57 81
LESS_EQUAL           : 83
LOGICAL_AND          : 86
LOGICAL_NOT          : 90
LOGICAL_OR           : 88
LPAREN               : 54 62 63 107 108
MINUS                : 49 55
MINUS_ASSIGN         : 36
MODULE               : 
MODULE_OP            : 52
MOD_ASSIGN           : 39
NEWLINE              : 
NEXT                 : 113
NIL                  : 23
NOT                  : 91
NOT_EQUAL            : 79
OR                   : 89
PLUS                 : 48
PLUS_ASSIGN          : 35
POWER                : 53
POWER_ASSIGN         : 40
PUTS                 : 74 75
RANGE_EXCLUSIVE      : 31
RANGE_INCLUSIVE      : 32
RBRACE               : 67 68
RBRACKET             : 47 93 94
REGEXP               : 20
RESCUE               : 
RETRY                : 
RETURN               : 65 66
RPAREN               : 54 62 63 107 108
SCOPE                : 
SELF                 : 
SEMICOLON            : 15
SPACESHIP            : 84
STRING               : 18 73
SUPER                : 
SYMBOL               : 19 72
THEN                 : 
TIMES                : 50
TIMES_ASSIGN         : 37
TRUE                 : 21
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 105
YIELD                : 
error                : 

Nonterminals, with rules where they appear

arguments            : 107 109 110
array_access         : 30 46
array_elements       : 93 95
assignment           : 8
class_definition     : 14
condition            : 24 86 86 87 87 88 88 89 89 90 91 99 100 101 102 103 104 105
control_statement    : 11
elsif_clauses        : 101 102 103
empty                : 2 3 4 7 64
enter_loop_scope     : 98 105
enter_scope          : 56 57 99 100 100 101 102 102
exit_scope           : 56 57 60 97 99 100 100 101 102 105
expression           : 31 31 32 32 35 36 37 38 39 40 41 42 43 44 45 46 47 48 48 49 49 50 50 51 51 52 52 53 53 54 55 65 71 71 72 73 74 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85 92 95 96 98 110 111
for_setup            : 97
func_header          : 60
func_name_hook       : 60
function_call        : 34 106
function_definition  : 12
hash_pair            : 69 70
hash_pairs           : 67 69
io_statement         : 10
param_list           : 58 62
program              : 0
return_statement     : 13
special_assignment   : 9
statement            : 6
statements           : 5 6 56 57 60 97 99 100 100 101 102 102 103 104 105

Parsing method: LALR

state 0

    (0) S' -> . program
    (5) program -> . statements
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    statements                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (5) program -> statements .
    (6) statements -> statements . statement
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    $end            reduce using rule 5 (program -> statements .)
    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    statement                      shift and go to state 4
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 3

    (7) statements -> empty .

    SEMICOLON       reduce using rule 7 (statements -> empty .)
    BREAK           reduce using rule 7 (statements -> empty .)
    NEXT            reduce using rule 7 (statements -> empty .)
    IDENTIFIER      reduce using rule 7 (statements -> empty .)
    INSTANCE_VARIABLE reduce using rule 7 (statements -> empty .)
    CLASS_VARIABLE  reduce using rule 7 (statements -> empty .)
    GLOBAL_VARIABLE reduce using rule 7 (statements -> empty .)
    CONSTANT        reduce using rule 7 (statements -> empty .)
    PUTS            reduce using rule 7 (statements -> empty .)
    FOR             reduce using rule 7 (statements -> empty .)
    IF              reduce using rule 7 (statements -> empty .)
    WHILE           reduce using rule 7 (statements -> empty .)
    DEF             reduce using rule 7 (statements -> empty .)
    RETURN          reduce using rule 7 (statements -> empty .)
    CLASS           reduce using rule 7 (statements -> empty .)
    $end            reduce using rule 7 (statements -> empty .)
    END             reduce using rule 7 (statements -> empty .)
    ELSIF           reduce using rule 7 (statements -> empty .)
    ELSE            reduce using rule 7 (statements -> empty .)


state 4

    (6) statements -> statements statement .

    SEMICOLON       reduce using rule 6 (statements -> statements statement .)
    BREAK           reduce using rule 6 (statements -> statements statement .)
    NEXT            reduce using rule 6 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 6 (statements -> statements statement .)
    INSTANCE_VARIABLE reduce using rule 6 (statements -> statements statement .)
    CLASS_VARIABLE  reduce using rule 6 (statements -> statements statement .)
    GLOBAL_VARIABLE reduce using rule 6 (statements -> statements statement .)
    CONSTANT        reduce using rule 6 (statements -> statements statement .)
    PUTS            reduce using rule 6 (statements -> statements statement .)
    FOR             reduce using rule 6 (statements -> statements statement .)
    IF              reduce using rule 6 (statements -> statements statement .)
    WHILE           reduce using rule 6 (statements -> statements statement .)
    DEF             reduce using rule 6 (statements -> statements statement .)
    RETURN          reduce using rule 6 (statements -> statements statement .)
    CLASS           reduce using rule 6 (statements -> statements statement .)
    $end            reduce using rule 6 (statements -> statements statement .)
    END             reduce using rule 6 (statements -> statements statement .)
    ELSIF           reduce using rule 6 (statements -> statements statement .)
    ELSE            reduce using rule 6 (statements -> statements statement .)


state 5

    (8) statement -> assignment .

    SEMICOLON       reduce using rule 8 (statement -> assignment .)
    BREAK           reduce using rule 8 (statement -> assignment .)
    NEXT            reduce using rule 8 (statement -> assignment .)
    IDENTIFIER      reduce using rule 8 (statement -> assignment .)
    INSTANCE_VARIABLE reduce using rule 8 (statement -> assignment .)
    CLASS_VARIABLE  reduce using rule 8 (statement -> assignment .)
    GLOBAL_VARIABLE reduce using rule 8 (statement -> assignment .)
    CONSTANT        reduce using rule 8 (statement -> assignment .)
    PUTS            reduce using rule 8 (statement -> assignment .)
    FOR             reduce using rule 8 (statement -> assignment .)
    IF              reduce using rule 8 (statement -> assignment .)
    WHILE           reduce using rule 8 (statement -> assignment .)
    DEF             reduce using rule 8 (statement -> assignment .)
    RETURN          reduce using rule 8 (statement -> assignment .)
    CLASS           reduce using rule 8 (statement -> assignment .)
    $end            reduce using rule 8 (statement -> assignment .)
    END             reduce using rule 8 (statement -> assignment .)
    ELSIF           reduce using rule 8 (statement -> assignment .)
    ELSE            reduce using rule 8 (statement -> assignment .)


state 6

    (9) statement -> special_assignment .

    SEMICOLON       reduce using rule 9 (statement -> special_assignment .)
    BREAK           reduce using rule 9 (statement -> special_assignment .)
    NEXT            reduce using rule 9 (statement -> special_assignment .)
    IDENTIFIER      reduce using rule 9 (statement -> special_assignment .)
    INSTANCE_VARIABLE reduce using rule 9 (statement -> special_assignment .)
    CLASS_VARIABLE  reduce using rule 9 (statement -> special_assignment .)
    GLOBAL_VARIABLE reduce using rule 9 (statement -> special_assignment .)
    CONSTANT        reduce using rule 9 (statement -> special_assignment .)
    PUTS            reduce using rule 9 (statement -> special_assignment .)
    FOR             reduce using rule 9 (statement -> special_assignment .)
    IF              reduce using rule 9 (statement -> special_assignment .)
    WHILE           reduce using rule 9 (statement -> special_assignment .)
    DEF             reduce using rule 9 (statement -> special_assignment .)
    RETURN          reduce using rule 9 (statement -> special_assignment .)
    CLASS           reduce using rule 9 (statement -> special_assignment .)
    $end            reduce using rule 9 (statement -> special_assignment .)
    END             reduce using rule 9 (statement -> special_assignment .)
    ELSIF           reduce using rule 9 (statement -> special_assignment .)
    ELSE            reduce using rule 9 (statement -> special_assignment .)


state 7

    (10) statement -> io_statement .

    SEMICOLON       reduce using rule 10 (statement -> io_statement .)
    BREAK           reduce using rule 10 (statement -> io_statement .)
    NEXT            reduce using rule 10 (statement -> io_statement .)
    IDENTIFIER      reduce using rule 10 (statement -> io_statement .)
    INSTANCE_VARIABLE reduce using rule 10 (statement -> io_statement .)
    CLASS_VARIABLE  reduce using rule 10 (statement -> io_statement .)
    GLOBAL_VARIABLE reduce using rule 10 (statement -> io_statement .)
    CONSTANT        reduce using rule 10 (statement -> io_statement .)
    PUTS            reduce using rule 10 (statement -> io_statement .)
    FOR             reduce using rule 10 (statement -> io_statement .)
    IF              reduce using rule 10 (statement -> io_statement .)
    WHILE           reduce using rule 10 (statement -> io_statement .)
    DEF             reduce using rule 10 (statement -> io_statement .)
    RETURN          reduce using rule 10 (statement -> io_statement .)
    CLASS           reduce using rule 10 (statement -> io_statement .)
    $end            reduce using rule 10 (statement -> io_statement .)
    END             reduce using rule 10 (statement -> io_statement .)
    ELSIF           reduce using rule 10 (statement -> io_statement .)
    ELSE            reduce using rule 10 (statement -> io_statement .)


state 8

    (11) statement -> control_statement .

    SEMICOLON       reduce using rule 11 (statement -> control_statement .)
    BREAK           reduce using rule 11 (statement -> control_statement .)
    NEXT            reduce using rule 11 (statement -> control_statement .)
    IDENTIFIER      reduce using rule 11 (statement -> control_statement .)
    INSTANCE_VARIABLE reduce using rule 11 (statement -> control_statement .)
    CLASS_VARIABLE  reduce using rule 11 (statement -> control_statement .)
    GLOBAL_VARIABLE reduce using rule 11 (statement -> control_statement .)
    CONSTANT        reduce using rule 11 (statement -> control_statement .)
    PUTS            reduce using rule 11 (statement -> control_statement .)
    FOR             reduce using rule 11 (statement -> control_statement .)
    IF              reduce using rule 11 (statement -> control_statement .)
    WHILE           reduce using rule 11 (statement -> control_statement .)
    DEF             reduce using rule 11 (statement -> control_statement .)
    RETURN          reduce using rule 11 (statement -> control_statement .)
    CLASS           reduce using rule 11 (statement -> control_statement .)
    $end            reduce using rule 11 (statement -> control_statement .)
    END             reduce using rule 11 (statement -> control_statement .)
    ELSIF           reduce using rule 11 (statement -> control_statement .)
    ELSE            reduce using rule 11 (statement -> control_statement .)


state 9

    (12) statement -> function_definition .

    SEMICOLON       reduce using rule 12 (statement -> function_definition .)
    BREAK           reduce using rule 12 (statement -> function_definition .)
    NEXT            reduce using rule 12 (statement -> function_definition .)
    IDENTIFIER      reduce using rule 12 (statement -> function_definition .)
    INSTANCE_VARIABLE reduce using rule 12 (statement -> function_definition .)
    CLASS_VARIABLE  reduce using rule 12 (statement -> function_definition .)
    GLOBAL_VARIABLE reduce using rule 12 (statement -> function_definition .)
    CONSTANT        reduce using rule 12 (statement -> function_definition .)
    PUTS            reduce using rule 12 (statement -> function_definition .)
    FOR             reduce using rule 12 (statement -> function_definition .)
    IF              reduce using rule 12 (statement -> function_definition .)
    WHILE           reduce using rule 12 (statement -> function_definition .)
    DEF             reduce using rule 12 (statement -> function_definition .)
    RETURN          reduce using rule 12 (statement -> function_definition .)
    CLASS           reduce using rule 12 (statement -> function_definition .)
    $end            reduce using rule 12 (statement -> function_definition .)
    END             reduce using rule 12 (statement -> function_definition .)
    ELSIF           reduce using rule 12 (statement -> function_definition .)
    ELSE            reduce using rule 12 (statement -> function_definition .)


state 10

    (13) statement -> return_statement .

    SEMICOLON       reduce using rule 13 (statement -> return_statement .)
    BREAK           reduce using rule 13 (statement -> return_statement .)
    NEXT            reduce using rule 13 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 13 (statement -> return_statement .)
    INSTANCE_VARIABLE reduce using rule 13 (statement -> return_statement .)
    CLASS_VARIABLE  reduce using rule 13 (statement -> return_statement .)
    GLOBAL_VARIABLE reduce using rule 13 (statement -> return_statement .)
    CONSTANT        reduce using rule 13 (statement -> return_statement .)
    PUTS            reduce using rule 13 (statement -> return_statement .)
    FOR             reduce using rule 13 (statement -> return_statement .)
    IF              reduce using rule 13 (statement -> return_statement .)
    WHILE           reduce using rule 13 (statement -> return_statement .)
    DEF             reduce using rule 13 (statement -> return_statement .)
    RETURN          reduce using rule 13 (statement -> return_statement .)
    CLASS           reduce using rule 13 (statement -> return_statement .)
    $end            reduce using rule 13 (statement -> return_statement .)
    END             reduce using rule 13 (statement -> return_statement .)
    ELSIF           reduce using rule 13 (statement -> return_statement .)
    ELSE            reduce using rule 13 (statement -> return_statement .)


state 11

    (14) statement -> class_definition .

    SEMICOLON       reduce using rule 14 (statement -> class_definition .)
    BREAK           reduce using rule 14 (statement -> class_definition .)
    NEXT            reduce using rule 14 (statement -> class_definition .)
    IDENTIFIER      reduce using rule 14 (statement -> class_definition .)
    INSTANCE_VARIABLE reduce using rule 14 (statement -> class_definition .)
    CLASS_VARIABLE  reduce using rule 14 (statement -> class_definition .)
    GLOBAL_VARIABLE reduce using rule 14 (statement -> class_definition .)
    CONSTANT        reduce using rule 14 (statement -> class_definition .)
    PUTS            reduce using rule 14 (statement -> class_definition .)
    FOR             reduce using rule 14 (statement -> class_definition .)
    IF              reduce using rule 14 (statement -> class_definition .)
    WHILE           reduce using rule 14 (statement -> class_definition .)
    DEF             reduce using rule 14 (statement -> class_definition .)
    RETURN          reduce using rule 14 (statement -> class_definition .)
    CLASS           reduce using rule 14 (statement -> class_definition .)
    $end            reduce using rule 14 (statement -> class_definition .)
    END             reduce using rule 14 (statement -> class_definition .)
    ELSIF           reduce using rule 14 (statement -> class_definition .)
    ELSE            reduce using rule 14 (statement -> class_definition .)


state 12

    (15) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 15 (statement -> SEMICOLON .)
    BREAK           reduce using rule 15 (statement -> SEMICOLON .)
    NEXT            reduce using rule 15 (statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (statement -> SEMICOLON .)
    INSTANCE_VARIABLE reduce using rule 15 (statement -> SEMICOLON .)
    CLASS_VARIABLE  reduce using rule 15 (statement -> SEMICOLON .)
    GLOBAL_VARIABLE reduce using rule 15 (statement -> SEMICOLON .)
    CONSTANT        reduce using rule 15 (statement -> SEMICOLON .)
    PUTS            reduce using rule 15 (statement -> SEMICOLON .)
    FOR             reduce using rule 15 (statement -> SEMICOLON .)
    IF              reduce using rule 15 (statement -> SEMICOLON .)
    WHILE           reduce using rule 15 (statement -> SEMICOLON .)
    DEF             reduce using rule 15 (statement -> SEMICOLON .)
    RETURN          reduce using rule 15 (statement -> SEMICOLON .)
    CLASS           reduce using rule 15 (statement -> SEMICOLON .)
    $end            reduce using rule 15 (statement -> SEMICOLON .)
    END             reduce using rule 15 (statement -> SEMICOLON .)
    ELSIF           reduce using rule 15 (statement -> SEMICOLON .)
    ELSE            reduce using rule 15 (statement -> SEMICOLON .)


state 13

    (112) statement -> BREAK .

    SEMICOLON       reduce using rule 112 (statement -> BREAK .)
    BREAK           reduce using rule 112 (statement -> BREAK .)
    NEXT            reduce using rule 112 (statement -> BREAK .)
    IDENTIFIER      reduce using rule 112 (statement -> BREAK .)
    INSTANCE_VARIABLE reduce using rule 112 (statement -> BREAK .)
    CLASS_VARIABLE  reduce using rule 112 (statement -> BREAK .)
    GLOBAL_VARIABLE reduce using rule 112 (statement -> BREAK .)
    CONSTANT        reduce using rule 112 (statement -> BREAK .)
    PUTS            reduce using rule 112 (statement -> BREAK .)
    FOR             reduce using rule 112 (statement -> BREAK .)
    IF              reduce using rule 112 (statement -> BREAK .)
    WHILE           reduce using rule 112 (statement -> BREAK .)
    DEF             reduce using rule 112 (statement -> BREAK .)
    RETURN          reduce using rule 112 (statement -> BREAK .)
    CLASS           reduce using rule 112 (statement -> BREAK .)
    $end            reduce using rule 112 (statement -> BREAK .)
    END             reduce using rule 112 (statement -> BREAK .)
    ELSIF           reduce using rule 112 (statement -> BREAK .)
    ELSE            reduce using rule 112 (statement -> BREAK .)


state 14

    (113) statement -> NEXT .

    SEMICOLON       reduce using rule 113 (statement -> NEXT .)
    BREAK           reduce using rule 113 (statement -> NEXT .)
    NEXT            reduce using rule 113 (statement -> NEXT .)
    IDENTIFIER      reduce using rule 113 (statement -> NEXT .)
    INSTANCE_VARIABLE reduce using rule 113 (statement -> NEXT .)
    CLASS_VARIABLE  reduce using rule 113 (statement -> NEXT .)
    GLOBAL_VARIABLE reduce using rule 113 (statement -> NEXT .)
    CONSTANT        reduce using rule 113 (statement -> NEXT .)
    PUTS            reduce using rule 113 (statement -> NEXT .)
    FOR             reduce using rule 113 (statement -> NEXT .)
    IF              reduce using rule 113 (statement -> NEXT .)
    WHILE           reduce using rule 113 (statement -> NEXT .)
    DEF             reduce using rule 113 (statement -> NEXT .)
    RETURN          reduce using rule 113 (statement -> NEXT .)
    CLASS           reduce using rule 113 (statement -> NEXT .)
    $end            reduce using rule 113 (statement -> NEXT .)
    END             reduce using rule 113 (statement -> NEXT .)
    ELSIF           reduce using rule 113 (statement -> NEXT .)
    ELSE            reduce using rule 113 (statement -> NEXT .)


state 15

    (41) assignment -> IDENTIFIER . ASSIGN expression
    (35) special_assignment -> IDENTIFIER . PLUS_ASSIGN expression
    (36) special_assignment -> IDENTIFIER . MINUS_ASSIGN expression
    (37) special_assignment -> IDENTIFIER . TIMES_ASSIGN expression
    (38) special_assignment -> IDENTIFIER . DIVIDE_ASSIGN expression
    (39) special_assignment -> IDENTIFIER . MOD_ASSIGN expression
    (40) special_assignment -> IDENTIFIER . POWER_ASSIGN expression
    (76) io_statement -> IDENTIFIER . ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> IDENTIFIER . ASSIGN GETS
    (47) array_access -> IDENTIFIER . LBRACKET expression RBRACKET

    ASSIGN          shift and go to state 28
    PLUS_ASSIGN     shift and go to state 29
    MINUS_ASSIGN    shift and go to state 30
    TIMES_ASSIGN    shift and go to state 31
    DIVIDE_ASSIGN   shift and go to state 32
    MOD_ASSIGN      shift and go to state 33
    POWER_ASSIGN    shift and go to state 34
    LBRACKET        shift and go to state 35


state 16

    (42) assignment -> INSTANCE_VARIABLE . ASSIGN expression

    ASSIGN          shift and go to state 36


state 17

    (43) assignment -> CLASS_VARIABLE . ASSIGN expression

    ASSIGN          shift and go to state 37


state 18

    (44) assignment -> GLOBAL_VARIABLE . ASSIGN expression

    ASSIGN          shift and go to state 38


state 19

    (45) assignment -> CONSTANT . ASSIGN expression

    ASSIGN          shift and go to state 39


state 20

    (46) assignment -> array_access . ASSIGN expression

    ASSIGN          shift and go to state 40


state 21

    (74) io_statement -> PUTS . expression
    (75) io_statement -> PUTS .
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INSTANCE_VARIABLE resolved as shift
  ! shift/reduce conflict for CLASS_VARIABLE resolved as shift
  ! shift/reduce conflict for GLOBAL_VARIABLE resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
    SEMICOLON       reduce using rule 75 (io_statement -> PUTS .)
    BREAK           reduce using rule 75 (io_statement -> PUTS .)
    NEXT            reduce using rule 75 (io_statement -> PUTS .)
    PUTS            reduce using rule 75 (io_statement -> PUTS .)
    FOR             reduce using rule 75 (io_statement -> PUTS .)
    IF              reduce using rule 75 (io_statement -> PUTS .)
    WHILE           reduce using rule 75 (io_statement -> PUTS .)
    DEF             reduce using rule 75 (io_statement -> PUTS .)
    RETURN          reduce using rule 75 (io_statement -> PUTS .)
    CLASS           reduce using rule 75 (io_statement -> PUTS .)
    $end            reduce using rule 75 (io_statement -> PUTS .)
    END             reduce using rule 75 (io_statement -> PUTS .)
    ELSIF           reduce using rule 75 (io_statement -> PUTS .)
    ELSE            reduce using rule 75 (io_statement -> PUTS .)
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

  ! IDENTIFIER      [ reduce using rule 75 (io_statement -> PUTS .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 75 (io_statement -> PUTS .) ]
  ! CLASS_VARIABLE  [ reduce using rule 75 (io_statement -> PUTS .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 75 (io_statement -> PUTS .) ]
  ! CONSTANT        [ reduce using rule 75 (io_statement -> PUTS .) ]

    expression                     shift and go to state 41
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 22

    (97) control_statement -> FOR . for_setup statements exit_scope END
    (98) for_setup -> . IDENTIFIER IN expression enter_loop_scope

    IDENTIFIER      shift and go to state 65

    for_setup                      shift and go to state 64

state 23

    (99) control_statement -> IF . condition enter_scope statements exit_scope END
    (100) control_statement -> IF . condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> IF . condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> IF . condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 66
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 24

    (105) control_statement -> WHILE . condition enter_loop_scope statements exit_scope END
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 68
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 25

    (60) function_definition -> DEF . func_name_hook func_header statements exit_scope END
    (61) func_name_hook -> . IDENTIFIER

    IDENTIFIER      shift and go to state 70

    func_name_hook                 shift and go to state 69

state 26

    (65) return_statement -> RETURN . expression
    (66) return_statement -> RETURN .
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INSTANCE_VARIABLE resolved as shift
  ! shift/reduce conflict for CLASS_VARIABLE resolved as shift
  ! shift/reduce conflict for GLOBAL_VARIABLE resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
    SEMICOLON       reduce using rule 66 (return_statement -> RETURN .)
    BREAK           reduce using rule 66 (return_statement -> RETURN .)
    NEXT            reduce using rule 66 (return_statement -> RETURN .)
    PUTS            reduce using rule 66 (return_statement -> RETURN .)
    FOR             reduce using rule 66 (return_statement -> RETURN .)
    IF              reduce using rule 66 (return_statement -> RETURN .)
    WHILE           reduce using rule 66 (return_statement -> RETURN .)
    DEF             reduce using rule 66 (return_statement -> RETURN .)
    RETURN          reduce using rule 66 (return_statement -> RETURN .)
    CLASS           reduce using rule 66 (return_statement -> RETURN .)
    $end            reduce using rule 66 (return_statement -> RETURN .)
    END             reduce using rule 66 (return_statement -> RETURN .)
    ELSIF           reduce using rule 66 (return_statement -> RETURN .)
    ELSE            reduce using rule 66 (return_statement -> RETURN .)
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

  ! IDENTIFIER      [ reduce using rule 66 (return_statement -> RETURN .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 66 (return_statement -> RETURN .) ]
  ! CLASS_VARIABLE  [ reduce using rule 66 (return_statement -> RETURN .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 66 (return_statement -> RETURN .) ]
  ! CONSTANT        [ reduce using rule 66 (return_statement -> RETURN .) ]

    expression                     shift and go to state 71
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 27

    (56) class_definition -> CLASS . CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> CLASS . CONSTANT LESS CONSTANT enter_scope statements exit_scope END

    CONSTANT        shift and go to state 72


state 28

    (41) assignment -> IDENTIFIER ASSIGN . expression
    (76) io_statement -> IDENTIFIER ASSIGN . GETS DOT IDENTIFIER
    (77) io_statement -> IDENTIFIER ASSIGN . GETS
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    GETS            shift and go to state 74
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 73
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 29

    (35) special_assignment -> IDENTIFIER PLUS_ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 75
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 30

    (36) special_assignment -> IDENTIFIER MINUS_ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 76
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 31

    (37) special_assignment -> IDENTIFIER TIMES_ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 77
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 32

    (38) special_assignment -> IDENTIFIER DIVIDE_ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 78
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 33

    (39) special_assignment -> IDENTIFIER MOD_ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 79
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 34

    (40) special_assignment -> IDENTIFIER POWER_ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 80
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 35

    (47) array_access -> IDENTIFIER LBRACKET . expression RBRACKET
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 81
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 36

    (42) assignment -> INSTANCE_VARIABLE ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 82
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 37

    (43) assignment -> CLASS_VARIABLE ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 83
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 38

    (44) assignment -> GLOBAL_VARIABLE ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 84
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 39

    (45) assignment -> CONSTANT ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 85
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 40

    (46) assignment -> array_access ASSIGN . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    array_access                   shift and go to state 56
    expression                     shift and go to state 86
    condition                      shift and go to state 50
    function_call                  shift and go to state 57

state 41

    (74) io_statement -> PUTS expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for FOR resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for IF resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for DEF resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for $end resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for END resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 74 (io_statement -> PUTS expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 74 (io_statement -> PUTS expression .)
    SEMICOLON       reduce using rule 74 (io_statement -> PUTS expression .)
    BREAK           reduce using rule 74 (io_statement -> PUTS expression .)
    NEXT            reduce using rule 74 (io_statement -> PUTS expression .)
    IDENTIFIER      reduce using rule 74 (io_statement -> PUTS expression .)
    INSTANCE_VARIABLE reduce using rule 74 (io_statement -> PUTS expression .)
    CLASS_VARIABLE  reduce using rule 74 (io_statement -> PUTS expression .)
    GLOBAL_VARIABLE reduce using rule 74 (io_statement -> PUTS expression .)
    CONSTANT        reduce using rule 74 (io_statement -> PUTS expression .)
    PUTS            reduce using rule 74 (io_statement -> PUTS expression .)
    FOR             reduce using rule 74 (io_statement -> PUTS expression .)
    IF              reduce using rule 74 (io_statement -> PUTS expression .)
    WHILE           reduce using rule 74 (io_statement -> PUTS expression .)
    DEF             reduce using rule 74 (io_statement -> PUTS expression .)
    RETURN          reduce using rule 74 (io_statement -> PUTS expression .)
    CLASS           reduce using rule 74 (io_statement -> PUTS expression .)
    $end            reduce using rule 74 (io_statement -> PUTS expression .)
    END             reduce using rule 74 (io_statement -> PUTS expression .)
    ELSIF           reduce using rule 74 (io_statement -> PUTS expression .)
    ELSE            reduce using rule 74 (io_statement -> PUTS expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 42

    (16) expression -> INTEGER .

    RANGE_EXCLUSIVE reduce using rule 16 (expression -> INTEGER .)
    RANGE_INCLUSIVE reduce using rule 16 (expression -> INTEGER .)
    PLUS            reduce using rule 16 (expression -> INTEGER .)
    MINUS           reduce using rule 16 (expression -> INTEGER .)
    TIMES           reduce using rule 16 (expression -> INTEGER .)
    DIVIDE          reduce using rule 16 (expression -> INTEGER .)
    MODULE_OP       reduce using rule 16 (expression -> INTEGER .)
    POWER           reduce using rule 16 (expression -> INTEGER .)
    EQUAL           reduce using rule 16 (expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 16 (expression -> INTEGER .)
    GREATER         reduce using rule 16 (expression -> INTEGER .)
    LESS            reduce using rule 16 (expression -> INTEGER .)
    GREATER_EQUAL   reduce using rule 16 (expression -> INTEGER .)
    LESS_EQUAL      reduce using rule 16 (expression -> INTEGER .)
    SPACESHIP       reduce using rule 16 (expression -> INTEGER .)
    CASE_EQUAL      reduce using rule 16 (expression -> INTEGER .)
    SEMICOLON       reduce using rule 16 (expression -> INTEGER .)
    BREAK           reduce using rule 16 (expression -> INTEGER .)
    NEXT            reduce using rule 16 (expression -> INTEGER .)
    IDENTIFIER      reduce using rule 16 (expression -> INTEGER .)
    INSTANCE_VARIABLE reduce using rule 16 (expression -> INTEGER .)
    CLASS_VARIABLE  reduce using rule 16 (expression -> INTEGER .)
    GLOBAL_VARIABLE reduce using rule 16 (expression -> INTEGER .)
    CONSTANT        reduce using rule 16 (expression -> INTEGER .)
    PUTS            reduce using rule 16 (expression -> INTEGER .)
    FOR             reduce using rule 16 (expression -> INTEGER .)
    IF              reduce using rule 16 (expression -> INTEGER .)
    WHILE           reduce using rule 16 (expression -> INTEGER .)
    DEF             reduce using rule 16 (expression -> INTEGER .)
    RETURN          reduce using rule 16 (expression -> INTEGER .)
    CLASS           reduce using rule 16 (expression -> INTEGER .)
    $end            reduce using rule 16 (expression -> INTEGER .)
    LOGICAL_AND     reduce using rule 16 (expression -> INTEGER .)
    AND             reduce using rule 16 (expression -> INTEGER .)
    LOGICAL_OR      reduce using rule 16 (expression -> INTEGER .)
    OR              reduce using rule 16 (expression -> INTEGER .)
    END             reduce using rule 16 (expression -> INTEGER .)
    ELSIF           reduce using rule 16 (expression -> INTEGER .)
    ELSE            reduce using rule 16 (expression -> INTEGER .)
    RBRACKET        reduce using rule 16 (expression -> INTEGER .)
    COMMA           reduce using rule 16 (expression -> INTEGER .)
    RPAREN          reduce using rule 16 (expression -> INTEGER .)
    HASH_ROCKET     reduce using rule 16 (expression -> INTEGER .)
    RBRACE          reduce using rule 16 (expression -> INTEGER .)


state 43

    (17) expression -> FLOAT .

    RANGE_EXCLUSIVE reduce using rule 17 (expression -> FLOAT .)
    RANGE_INCLUSIVE reduce using rule 17 (expression -> FLOAT .)
    PLUS            reduce using rule 17 (expression -> FLOAT .)
    MINUS           reduce using rule 17 (expression -> FLOAT .)
    TIMES           reduce using rule 17 (expression -> FLOAT .)
    DIVIDE          reduce using rule 17 (expression -> FLOAT .)
    MODULE_OP       reduce using rule 17 (expression -> FLOAT .)
    POWER           reduce using rule 17 (expression -> FLOAT .)
    EQUAL           reduce using rule 17 (expression -> FLOAT .)
    NOT_EQUAL       reduce using rule 17 (expression -> FLOAT .)
    GREATER         reduce using rule 17 (expression -> FLOAT .)
    LESS            reduce using rule 17 (expression -> FLOAT .)
    GREATER_EQUAL   reduce using rule 17 (expression -> FLOAT .)
    LESS_EQUAL      reduce using rule 17 (expression -> FLOAT .)
    SPACESHIP       reduce using rule 17 (expression -> FLOAT .)
    CASE_EQUAL      reduce using rule 17 (expression -> FLOAT .)
    SEMICOLON       reduce using rule 17 (expression -> FLOAT .)
    BREAK           reduce using rule 17 (expression -> FLOAT .)
    NEXT            reduce using rule 17 (expression -> FLOAT .)
    IDENTIFIER      reduce using rule 17 (expression -> FLOAT .)
    INSTANCE_VARIABLE reduce using rule 17 (expression -> FLOAT .)
    CLASS_VARIABLE  reduce using rule 17 (expression -> FLOAT .)
    GLOBAL_VARIABLE reduce using rule 17 (expression -> FLOAT .)
    CONSTANT        reduce using rule 17 (expression -> FLOAT .)
    PUTS            reduce using rule 17 (expression -> FLOAT .)
    FOR             reduce using rule 17 (expression -> FLOAT .)
    IF              reduce using rule 17 (expression -> FLOAT .)
    WHILE           reduce using rule 17 (expression -> FLOAT .)
    DEF             reduce using rule 17 (expression -> FLOAT .)
    RETURN          reduce using rule 17 (expression -> FLOAT .)
    CLASS           reduce using rule 17 (expression -> FLOAT .)
    $end            reduce using rule 17 (expression -> FLOAT .)
    LOGICAL_AND     reduce using rule 17 (expression -> FLOAT .)
    AND             reduce using rule 17 (expression -> FLOAT .)
    LOGICAL_OR      reduce using rule 17 (expression -> FLOAT .)
    OR              reduce using rule 17 (expression -> FLOAT .)
    END             reduce using rule 17 (expression -> FLOAT .)
    ELSIF           reduce using rule 17 (expression -> FLOAT .)
    ELSE            reduce using rule 17 (expression -> FLOAT .)
    RBRACKET        reduce using rule 17 (expression -> FLOAT .)
    COMMA           reduce using rule 17 (expression -> FLOAT .)
    RPAREN          reduce using rule 17 (expression -> FLOAT .)
    HASH_ROCKET     reduce using rule 17 (expression -> FLOAT .)
    RBRACE          reduce using rule 17 (expression -> FLOAT .)


state 44

    (18) expression -> STRING .

    RANGE_EXCLUSIVE reduce using rule 18 (expression -> STRING .)
    RANGE_INCLUSIVE reduce using rule 18 (expression -> STRING .)
    PLUS            reduce using rule 18 (expression -> STRING .)
    MINUS           reduce using rule 18 (expression -> STRING .)
    TIMES           reduce using rule 18 (expression -> STRING .)
    DIVIDE          reduce using rule 18 (expression -> STRING .)
    MODULE_OP       reduce using rule 18 (expression -> STRING .)
    POWER           reduce using rule 18 (expression -> STRING .)
    EQUAL           reduce using rule 18 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 18 (expression -> STRING .)
    GREATER         reduce using rule 18 (expression -> STRING .)
    LESS            reduce using rule 18 (expression -> STRING .)
    GREATER_EQUAL   reduce using rule 18 (expression -> STRING .)
    LESS_EQUAL      reduce using rule 18 (expression -> STRING .)
    SPACESHIP       reduce using rule 18 (expression -> STRING .)
    CASE_EQUAL      reduce using rule 18 (expression -> STRING .)
    SEMICOLON       reduce using rule 18 (expression -> STRING .)
    BREAK           reduce using rule 18 (expression -> STRING .)
    NEXT            reduce using rule 18 (expression -> STRING .)
    IDENTIFIER      reduce using rule 18 (expression -> STRING .)
    INSTANCE_VARIABLE reduce using rule 18 (expression -> STRING .)
    CLASS_VARIABLE  reduce using rule 18 (expression -> STRING .)
    GLOBAL_VARIABLE reduce using rule 18 (expression -> STRING .)
    CONSTANT        reduce using rule 18 (expression -> STRING .)
    PUTS            reduce using rule 18 (expression -> STRING .)
    FOR             reduce using rule 18 (expression -> STRING .)
    IF              reduce using rule 18 (expression -> STRING .)
    WHILE           reduce using rule 18 (expression -> STRING .)
    DEF             reduce using rule 18 (expression -> STRING .)
    RETURN          reduce using rule 18 (expression -> STRING .)
    CLASS           reduce using rule 18 (expression -> STRING .)
    $end            reduce using rule 18 (expression -> STRING .)
    LOGICAL_AND     reduce using rule 18 (expression -> STRING .)
    AND             reduce using rule 18 (expression -> STRING .)
    LOGICAL_OR      reduce using rule 18 (expression -> STRING .)
    OR              reduce using rule 18 (expression -> STRING .)
    END             reduce using rule 18 (expression -> STRING .)
    ELSIF           reduce using rule 18 (expression -> STRING .)
    ELSE            reduce using rule 18 (expression -> STRING .)
    RBRACKET        reduce using rule 18 (expression -> STRING .)
    COMMA           reduce using rule 18 (expression -> STRING .)
    RPAREN          reduce using rule 18 (expression -> STRING .)
    HASH_ROCKET     reduce using rule 18 (expression -> STRING .)
    RBRACE          reduce using rule 18 (expression -> STRING .)


state 45

    (19) expression -> SYMBOL .

    RANGE_EXCLUSIVE reduce using rule 19 (expression -> SYMBOL .)
    RANGE_INCLUSIVE reduce using rule 19 (expression -> SYMBOL .)
    PLUS            reduce using rule 19 (expression -> SYMBOL .)
    MINUS           reduce using rule 19 (expression -> SYMBOL .)
    TIMES           reduce using rule 19 (expression -> SYMBOL .)
    DIVIDE          reduce using rule 19 (expression -> SYMBOL .)
    MODULE_OP       reduce using rule 19 (expression -> SYMBOL .)
    POWER           reduce using rule 19 (expression -> SYMBOL .)
    EQUAL           reduce using rule 19 (expression -> SYMBOL .)
    NOT_EQUAL       reduce using rule 19 (expression -> SYMBOL .)
    GREATER         reduce using rule 19 (expression -> SYMBOL .)
    LESS            reduce using rule 19 (expression -> SYMBOL .)
    GREATER_EQUAL   reduce using rule 19 (expression -> SYMBOL .)
    LESS_EQUAL      reduce using rule 19 (expression -> SYMBOL .)
    SPACESHIP       reduce using rule 19 (expression -> SYMBOL .)
    CASE_EQUAL      reduce using rule 19 (expression -> SYMBOL .)
    SEMICOLON       reduce using rule 19 (expression -> SYMBOL .)
    BREAK           reduce using rule 19 (expression -> SYMBOL .)
    NEXT            reduce using rule 19 (expression -> SYMBOL .)
    IDENTIFIER      reduce using rule 19 (expression -> SYMBOL .)
    INSTANCE_VARIABLE reduce using rule 19 (expression -> SYMBOL .)
    CLASS_VARIABLE  reduce using rule 19 (expression -> SYMBOL .)
    GLOBAL_VARIABLE reduce using rule 19 (expression -> SYMBOL .)
    CONSTANT        reduce using rule 19 (expression -> SYMBOL .)
    PUTS            reduce using rule 19 (expression -> SYMBOL .)
    FOR             reduce using rule 19 (expression -> SYMBOL .)
    IF              reduce using rule 19 (expression -> SYMBOL .)
    WHILE           reduce using rule 19 (expression -> SYMBOL .)
    DEF             reduce using rule 19 (expression -> SYMBOL .)
    RETURN          reduce using rule 19 (expression -> SYMBOL .)
    CLASS           reduce using rule 19 (expression -> SYMBOL .)
    $end            reduce using rule 19 (expression -> SYMBOL .)
    LOGICAL_AND     reduce using rule 19 (expression -> SYMBOL .)
    AND             reduce using rule 19 (expression -> SYMBOL .)
    LOGICAL_OR      reduce using rule 19 (expression -> SYMBOL .)
    OR              reduce using rule 19 (expression -> SYMBOL .)
    END             reduce using rule 19 (expression -> SYMBOL .)
    ELSIF           reduce using rule 19 (expression -> SYMBOL .)
    ELSE            reduce using rule 19 (expression -> SYMBOL .)
    RBRACKET        reduce using rule 19 (expression -> SYMBOL .)
    COMMA           reduce using rule 19 (expression -> SYMBOL .)
    RPAREN          reduce using rule 19 (expression -> SYMBOL .)
    HASH_ROCKET     reduce using rule 19 (expression -> SYMBOL .)
    RBRACE          reduce using rule 19 (expression -> SYMBOL .)


state 46

    (20) expression -> REGEXP .

    RANGE_EXCLUSIVE reduce using rule 20 (expression -> REGEXP .)
    RANGE_INCLUSIVE reduce using rule 20 (expression -> REGEXP .)
    PLUS            reduce using rule 20 (expression -> REGEXP .)
    MINUS           reduce using rule 20 (expression -> REGEXP .)
    TIMES           reduce using rule 20 (expression -> REGEXP .)
    DIVIDE          reduce using rule 20 (expression -> REGEXP .)
    MODULE_OP       reduce using rule 20 (expression -> REGEXP .)
    POWER           reduce using rule 20 (expression -> REGEXP .)
    EQUAL           reduce using rule 20 (expression -> REGEXP .)
    NOT_EQUAL       reduce using rule 20 (expression -> REGEXP .)
    GREATER         reduce using rule 20 (expression -> REGEXP .)
    LESS            reduce using rule 20 (expression -> REGEXP .)
    GREATER_EQUAL   reduce using rule 20 (expression -> REGEXP .)
    LESS_EQUAL      reduce using rule 20 (expression -> REGEXP .)
    SPACESHIP       reduce using rule 20 (expression -> REGEXP .)
    CASE_EQUAL      reduce using rule 20 (expression -> REGEXP .)
    SEMICOLON       reduce using rule 20 (expression -> REGEXP .)
    BREAK           reduce using rule 20 (expression -> REGEXP .)
    NEXT            reduce using rule 20 (expression -> REGEXP .)
    IDENTIFIER      reduce using rule 20 (expression -> REGEXP .)
    INSTANCE_VARIABLE reduce using rule 20 (expression -> REGEXP .)
    CLASS_VARIABLE  reduce using rule 20 (expression -> REGEXP .)
    GLOBAL_VARIABLE reduce using rule 20 (expression -> REGEXP .)
    CONSTANT        reduce using rule 20 (expression -> REGEXP .)
    PUTS            reduce using rule 20 (expression -> REGEXP .)
    FOR             reduce using rule 20 (expression -> REGEXP .)
    IF              reduce using rule 20 (expression -> REGEXP .)
    WHILE           reduce using rule 20 (expression -> REGEXP .)
    DEF             reduce using rule 20 (expression -> REGEXP .)
    RETURN          reduce using rule 20 (expression -> REGEXP .)
    CLASS           reduce using rule 20 (expression -> REGEXP .)
    $end            reduce using rule 20 (expression -> REGEXP .)
    LOGICAL_AND     reduce using rule 20 (expression -> REGEXP .)
    AND             reduce using rule 20 (expression -> REGEXP .)
    LOGICAL_OR      reduce using rule 20 (expression -> REGEXP .)
    OR              reduce using rule 20 (expression -> REGEXP .)
    END             reduce using rule 20 (expression -> REGEXP .)
    ELSIF           reduce using rule 20 (expression -> REGEXP .)
    ELSE            reduce using rule 20 (expression -> REGEXP .)
    RBRACKET        reduce using rule 20 (expression -> REGEXP .)
    COMMA           reduce using rule 20 (expression -> REGEXP .)
    RPAREN          reduce using rule 20 (expression -> REGEXP .)
    HASH_ROCKET     reduce using rule 20 (expression -> REGEXP .)
    RBRACE          reduce using rule 20 (expression -> REGEXP .)


state 47

    (21) expression -> TRUE .

    RANGE_EXCLUSIVE reduce using rule 21 (expression -> TRUE .)
    RANGE_INCLUSIVE reduce using rule 21 (expression -> TRUE .)
    PLUS            reduce using rule 21 (expression -> TRUE .)
    MINUS           reduce using rule 21 (expression -> TRUE .)
    TIMES           reduce using rule 21 (expression -> TRUE .)
    DIVIDE          reduce using rule 21 (expression -> TRUE .)
    MODULE_OP       reduce using rule 21 (expression -> TRUE .)
    POWER           reduce using rule 21 (expression -> TRUE .)
    EQUAL           reduce using rule 21 (expression -> TRUE .)
    NOT_EQUAL       reduce using rule 21 (expression -> TRUE .)
    GREATER         reduce using rule 21 (expression -> TRUE .)
    LESS            reduce using rule 21 (expression -> TRUE .)
    GREATER_EQUAL   reduce using rule 21 (expression -> TRUE .)
    LESS_EQUAL      reduce using rule 21 (expression -> TRUE .)
    SPACESHIP       reduce using rule 21 (expression -> TRUE .)
    CASE_EQUAL      reduce using rule 21 (expression -> TRUE .)
    SEMICOLON       reduce using rule 21 (expression -> TRUE .)
    BREAK           reduce using rule 21 (expression -> TRUE .)
    NEXT            reduce using rule 21 (expression -> TRUE .)
    IDENTIFIER      reduce using rule 21 (expression -> TRUE .)
    INSTANCE_VARIABLE reduce using rule 21 (expression -> TRUE .)
    CLASS_VARIABLE  reduce using rule 21 (expression -> TRUE .)
    GLOBAL_VARIABLE reduce using rule 21 (expression -> TRUE .)
    CONSTANT        reduce using rule 21 (expression -> TRUE .)
    PUTS            reduce using rule 21 (expression -> TRUE .)
    FOR             reduce using rule 21 (expression -> TRUE .)
    IF              reduce using rule 21 (expression -> TRUE .)
    WHILE           reduce using rule 21 (expression -> TRUE .)
    DEF             reduce using rule 21 (expression -> TRUE .)
    RETURN          reduce using rule 21 (expression -> TRUE .)
    CLASS           reduce using rule 21 (expression -> TRUE .)
    $end            reduce using rule 21 (expression -> TRUE .)
    LOGICAL_AND     reduce using rule 21 (expression -> TRUE .)
    AND             reduce using rule 21 (expression -> TRUE .)
    LOGICAL_OR      reduce using rule 21 (expression -> TRUE .)
    OR              reduce using rule 21 (expression -> TRUE .)
    END             reduce using rule 21 (expression -> TRUE .)
    ELSIF           reduce using rule 21 (expression -> TRUE .)
    ELSE            reduce using rule 21 (expression -> TRUE .)
    RBRACKET        reduce using rule 21 (expression -> TRUE .)
    COMMA           reduce using rule 21 (expression -> TRUE .)
    RPAREN          reduce using rule 21 (expression -> TRUE .)
    HASH_ROCKET     reduce using rule 21 (expression -> TRUE .)
    RBRACE          reduce using rule 21 (expression -> TRUE .)


state 48

    (22) expression -> FALSE .

    RANGE_EXCLUSIVE reduce using rule 22 (expression -> FALSE .)
    RANGE_INCLUSIVE reduce using rule 22 (expression -> FALSE .)
    PLUS            reduce using rule 22 (expression -> FALSE .)
    MINUS           reduce using rule 22 (expression -> FALSE .)
    TIMES           reduce using rule 22 (expression -> FALSE .)
    DIVIDE          reduce using rule 22 (expression -> FALSE .)
    MODULE_OP       reduce using rule 22 (expression -> FALSE .)
    POWER           reduce using rule 22 (expression -> FALSE .)
    EQUAL           reduce using rule 22 (expression -> FALSE .)
    NOT_EQUAL       reduce using rule 22 (expression -> FALSE .)
    GREATER         reduce using rule 22 (expression -> FALSE .)
    LESS            reduce using rule 22 (expression -> FALSE .)
    GREATER_EQUAL   reduce using rule 22 (expression -> FALSE .)
    LESS_EQUAL      reduce using rule 22 (expression -> FALSE .)
    SPACESHIP       reduce using rule 22 (expression -> FALSE .)
    CASE_EQUAL      reduce using rule 22 (expression -> FALSE .)
    SEMICOLON       reduce using rule 22 (expression -> FALSE .)
    BREAK           reduce using rule 22 (expression -> FALSE .)
    NEXT            reduce using rule 22 (expression -> FALSE .)
    IDENTIFIER      reduce using rule 22 (expression -> FALSE .)
    INSTANCE_VARIABLE reduce using rule 22 (expression -> FALSE .)
    CLASS_VARIABLE  reduce using rule 22 (expression -> FALSE .)
    GLOBAL_VARIABLE reduce using rule 22 (expression -> FALSE .)
    CONSTANT        reduce using rule 22 (expression -> FALSE .)
    PUTS            reduce using rule 22 (expression -> FALSE .)
    FOR             reduce using rule 22 (expression -> FALSE .)
    IF              reduce using rule 22 (expression -> FALSE .)
    WHILE           reduce using rule 22 (expression -> FALSE .)
    DEF             reduce using rule 22 (expression -> FALSE .)
    RETURN          reduce using rule 22 (expression -> FALSE .)
    CLASS           reduce using rule 22 (expression -> FALSE .)
    $end            reduce using rule 22 (expression -> FALSE .)
    LOGICAL_AND     reduce using rule 22 (expression -> FALSE .)
    AND             reduce using rule 22 (expression -> FALSE .)
    LOGICAL_OR      reduce using rule 22 (expression -> FALSE .)
    OR              reduce using rule 22 (expression -> FALSE .)
    END             reduce using rule 22 (expression -> FALSE .)
    ELSIF           reduce using rule 22 (expression -> FALSE .)
    ELSE            reduce using rule 22 (expression -> FALSE .)
    RBRACKET        reduce using rule 22 (expression -> FALSE .)
    COMMA           reduce using rule 22 (expression -> FALSE .)
    RPAREN          reduce using rule 22 (expression -> FALSE .)
    HASH_ROCKET     reduce using rule 22 (expression -> FALSE .)
    RBRACE          reduce using rule 22 (expression -> FALSE .)


state 49

    (23) expression -> NIL .

    RANGE_EXCLUSIVE reduce using rule 23 (expression -> NIL .)
    RANGE_INCLUSIVE reduce using rule 23 (expression -> NIL .)
    PLUS            reduce using rule 23 (expression -> NIL .)
    MINUS           reduce using rule 23 (expression -> NIL .)
    TIMES           reduce using rule 23 (expression -> NIL .)
    DIVIDE          reduce using rule 23 (expression -> NIL .)
    MODULE_OP       reduce using rule 23 (expression -> NIL .)
    POWER           reduce using rule 23 (expression -> NIL .)
    EQUAL           reduce using rule 23 (expression -> NIL .)
    NOT_EQUAL       reduce using rule 23 (expression -> NIL .)
    GREATER         reduce using rule 23 (expression -> NIL .)
    LESS            reduce using rule 23 (expression -> NIL .)
    GREATER_EQUAL   reduce using rule 23 (expression -> NIL .)
    LESS_EQUAL      reduce using rule 23 (expression -> NIL .)
    SPACESHIP       reduce using rule 23 (expression -> NIL .)
    CASE_EQUAL      reduce using rule 23 (expression -> NIL .)
    SEMICOLON       reduce using rule 23 (expression -> NIL .)
    BREAK           reduce using rule 23 (expression -> NIL .)
    NEXT            reduce using rule 23 (expression -> NIL .)
    IDENTIFIER      reduce using rule 23 (expression -> NIL .)
    INSTANCE_VARIABLE reduce using rule 23 (expression -> NIL .)
    CLASS_VARIABLE  reduce using rule 23 (expression -> NIL .)
    GLOBAL_VARIABLE reduce using rule 23 (expression -> NIL .)
    CONSTANT        reduce using rule 23 (expression -> NIL .)
    PUTS            reduce using rule 23 (expression -> NIL .)
    FOR             reduce using rule 23 (expression -> NIL .)
    IF              reduce using rule 23 (expression -> NIL .)
    WHILE           reduce using rule 23 (expression -> NIL .)
    DEF             reduce using rule 23 (expression -> NIL .)
    RETURN          reduce using rule 23 (expression -> NIL .)
    CLASS           reduce using rule 23 (expression -> NIL .)
    $end            reduce using rule 23 (expression -> NIL .)
    LOGICAL_AND     reduce using rule 23 (expression -> NIL .)
    AND             reduce using rule 23 (expression -> NIL .)
    LOGICAL_OR      reduce using rule 23 (expression -> NIL .)
    OR              reduce using rule 23 (expression -> NIL .)
    END             reduce using rule 23 (expression -> NIL .)
    ELSIF           reduce using rule 23 (expression -> NIL .)
    ELSE            reduce using rule 23 (expression -> NIL .)
    RBRACKET        reduce using rule 23 (expression -> NIL .)
    COMMA           reduce using rule 23 (expression -> NIL .)
    RPAREN          reduce using rule 23 (expression -> NIL .)
    HASH_ROCKET     reduce using rule 23 (expression -> NIL .)
    RBRACE          reduce using rule 23 (expression -> NIL .)


state 50

    (24) expression -> condition .
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 24 (expression -> condition .)
    BREAK           reduce using rule 24 (expression -> condition .)
    NEXT            reduce using rule 24 (expression -> condition .)
    IDENTIFIER      reduce using rule 24 (expression -> condition .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> condition .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> condition .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> condition .)
    CONSTANT        reduce using rule 24 (expression -> condition .)
    PUTS            reduce using rule 24 (expression -> condition .)
    FOR             reduce using rule 24 (expression -> condition .)
    IF              reduce using rule 24 (expression -> condition .)
    WHILE           reduce using rule 24 (expression -> condition .)
    DEF             reduce using rule 24 (expression -> condition .)
    RETURN          reduce using rule 24 (expression -> condition .)
    CLASS           reduce using rule 24 (expression -> condition .)
    $end            reduce using rule 24 (expression -> condition .)
    END             reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 24 (expression -> condition .)
    ELSE            reduce using rule 24 (expression -> condition .)
    RBRACKET        reduce using rule 24 (expression -> condition .)
    COMMA           reduce using rule 24 (expression -> condition .)
    RPAREN          reduce using rule 24 (expression -> condition .)
    HASH_ROCKET     reduce using rule 24 (expression -> condition .)
    RBRACE          reduce using rule 24 (expression -> condition .)
    LOGICAL_AND     shift and go to state 103
    AND             shift and go to state 104
    LOGICAL_OR      shift and go to state 105
    OR              shift and go to state 106

  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]
  ! AND             [ reduce using rule 24 (expression -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 24 (expression -> condition .) ]
  ! OR              [ reduce using rule 24 (expression -> condition .) ]


state 51

    (25) expression -> IDENTIFIER .
    (33) expression -> IDENTIFIER . DOT IDENTIFIER
    (34) expression -> IDENTIFIER . DOT function_call
    (47) array_access -> IDENTIFIER . LBRACKET expression RBRACKET
    (107) function_call -> IDENTIFIER . LPAREN arguments RPAREN
    (108) function_call -> IDENTIFIER . LPAREN RPAREN
    (109) function_call -> IDENTIFIER . arguments
    (110) arguments -> . arguments COMMA expression
    (111) arguments -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INSTANCE_VARIABLE resolved as shift
  ! shift/reduce conflict for CLASS_VARIABLE resolved as shift
  ! shift/reduce conflict for GLOBAL_VARIABLE resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RANGE_EXCLUSIVE reduce using rule 25 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 25 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 25 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 25 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 25 (expression -> IDENTIFIER .)
    MODULE_OP       reduce using rule 25 (expression -> IDENTIFIER .)
    POWER           reduce using rule 25 (expression -> IDENTIFIER .)
    EQUAL           reduce using rule 25 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 25 (expression -> IDENTIFIER .)
    GREATER         reduce using rule 25 (expression -> IDENTIFIER .)
    LESS            reduce using rule 25 (expression -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 25 (expression -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 25 (expression -> IDENTIFIER .)
    SPACESHIP       reduce using rule 25 (expression -> IDENTIFIER .)
    CASE_EQUAL      reduce using rule 25 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 25 (expression -> IDENTIFIER .)
    BREAK           reduce using rule 25 (expression -> IDENTIFIER .)
    NEXT            reduce using rule 25 (expression -> IDENTIFIER .)
    PUTS            reduce using rule 25 (expression -> IDENTIFIER .)
    FOR             reduce using rule 25 (expression -> IDENTIFIER .)
    IF              reduce using rule 25 (expression -> IDENTIFIER .)
    WHILE           reduce using rule 25 (expression -> IDENTIFIER .)
    DEF             reduce using rule 25 (expression -> IDENTIFIER .)
    RETURN          reduce using rule 25 (expression -> IDENTIFIER .)
    CLASS           reduce using rule 25 (expression -> IDENTIFIER .)
    $end            reduce using rule 25 (expression -> IDENTIFIER .)
    LOGICAL_AND     reduce using rule 25 (expression -> IDENTIFIER .)
    AND             reduce using rule 25 (expression -> IDENTIFIER .)
    LOGICAL_OR      reduce using rule 25 (expression -> IDENTIFIER .)
    OR              reduce using rule 25 (expression -> IDENTIFIER .)
    END             reduce using rule 25 (expression -> IDENTIFIER .)
    ELSIF           reduce using rule 25 (expression -> IDENTIFIER .)
    ELSE            reduce using rule 25 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 25 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 25 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 25 (expression -> IDENTIFIER .)
    HASH_ROCKET     reduce using rule 25 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 25 (expression -> IDENTIFIER .)
    DOT             shift and go to state 107
    LBRACKET        shift and go to state 108
    LPAREN          shift and go to state 110
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

  ! MINUS           [ reduce using rule 25 (expression -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 25 (expression -> IDENTIFIER .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 25 (expression -> IDENTIFIER .) ]
  ! CLASS_VARIABLE  [ reduce using rule 25 (expression -> IDENTIFIER .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 25 (expression -> IDENTIFIER .) ]
  ! CONSTANT        [ reduce using rule 25 (expression -> IDENTIFIER .) ]

    function_call                  shift and go to state 57
    expression                     shift and go to state 109
    arguments                      shift and go to state 111
    condition                      shift and go to state 50
    array_access                   shift and go to state 56

state 52

    (26) expression -> INSTANCE_VARIABLE .

    RANGE_EXCLUSIVE reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    RANGE_INCLUSIVE reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    PLUS            reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    MINUS           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    TIMES           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    DIVIDE          reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    MODULE_OP       reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    POWER           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    EQUAL           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    NOT_EQUAL       reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    GREATER         reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    LESS            reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    GREATER_EQUAL   reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    LESS_EQUAL      reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    SPACESHIP       reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    CASE_EQUAL      reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    SEMICOLON       reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    BREAK           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    NEXT            reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    IDENTIFIER      reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    INSTANCE_VARIABLE reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    CLASS_VARIABLE  reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    GLOBAL_VARIABLE reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    CONSTANT        reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    PUTS            reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    FOR             reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    IF              reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    WHILE           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    DEF             reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    RETURN          reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    CLASS           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    $end            reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    LOGICAL_AND     reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    AND             reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    LOGICAL_OR      reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    OR              reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    END             reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    ELSIF           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    ELSE            reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    RBRACKET        reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    COMMA           reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    RPAREN          reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    HASH_ROCKET     reduce using rule 26 (expression -> INSTANCE_VARIABLE .)
    RBRACE          reduce using rule 26 (expression -> INSTANCE_VARIABLE .)


state 53

    (27) expression -> CLASS_VARIABLE .

    RANGE_EXCLUSIVE reduce using rule 27 (expression -> CLASS_VARIABLE .)
    RANGE_INCLUSIVE reduce using rule 27 (expression -> CLASS_VARIABLE .)
    PLUS            reduce using rule 27 (expression -> CLASS_VARIABLE .)
    MINUS           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    TIMES           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    DIVIDE          reduce using rule 27 (expression -> CLASS_VARIABLE .)
    MODULE_OP       reduce using rule 27 (expression -> CLASS_VARIABLE .)
    POWER           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    EQUAL           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    NOT_EQUAL       reduce using rule 27 (expression -> CLASS_VARIABLE .)
    GREATER         reduce using rule 27 (expression -> CLASS_VARIABLE .)
    LESS            reduce using rule 27 (expression -> CLASS_VARIABLE .)
    GREATER_EQUAL   reduce using rule 27 (expression -> CLASS_VARIABLE .)
    LESS_EQUAL      reduce using rule 27 (expression -> CLASS_VARIABLE .)
    SPACESHIP       reduce using rule 27 (expression -> CLASS_VARIABLE .)
    CASE_EQUAL      reduce using rule 27 (expression -> CLASS_VARIABLE .)
    SEMICOLON       reduce using rule 27 (expression -> CLASS_VARIABLE .)
    BREAK           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    NEXT            reduce using rule 27 (expression -> CLASS_VARIABLE .)
    IDENTIFIER      reduce using rule 27 (expression -> CLASS_VARIABLE .)
    INSTANCE_VARIABLE reduce using rule 27 (expression -> CLASS_VARIABLE .)
    CLASS_VARIABLE  reduce using rule 27 (expression -> CLASS_VARIABLE .)
    GLOBAL_VARIABLE reduce using rule 27 (expression -> CLASS_VARIABLE .)
    CONSTANT        reduce using rule 27 (expression -> CLASS_VARIABLE .)
    PUTS            reduce using rule 27 (expression -> CLASS_VARIABLE .)
    FOR             reduce using rule 27 (expression -> CLASS_VARIABLE .)
    IF              reduce using rule 27 (expression -> CLASS_VARIABLE .)
    WHILE           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    DEF             reduce using rule 27 (expression -> CLASS_VARIABLE .)
    RETURN          reduce using rule 27 (expression -> CLASS_VARIABLE .)
    CLASS           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    $end            reduce using rule 27 (expression -> CLASS_VARIABLE .)
    LOGICAL_AND     reduce using rule 27 (expression -> CLASS_VARIABLE .)
    AND             reduce using rule 27 (expression -> CLASS_VARIABLE .)
    LOGICAL_OR      reduce using rule 27 (expression -> CLASS_VARIABLE .)
    OR              reduce using rule 27 (expression -> CLASS_VARIABLE .)
    END             reduce using rule 27 (expression -> CLASS_VARIABLE .)
    ELSIF           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    ELSE            reduce using rule 27 (expression -> CLASS_VARIABLE .)
    RBRACKET        reduce using rule 27 (expression -> CLASS_VARIABLE .)
    COMMA           reduce using rule 27 (expression -> CLASS_VARIABLE .)
    RPAREN          reduce using rule 27 (expression -> CLASS_VARIABLE .)
    HASH_ROCKET     reduce using rule 27 (expression -> CLASS_VARIABLE .)
    RBRACE          reduce using rule 27 (expression -> CLASS_VARIABLE .)


state 54

    (28) expression -> GLOBAL_VARIABLE .

    RANGE_EXCLUSIVE reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    RANGE_INCLUSIVE reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    PLUS            reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    MINUS           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    TIMES           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    DIVIDE          reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    MODULE_OP       reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    POWER           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    EQUAL           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    NOT_EQUAL       reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    GREATER         reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    LESS            reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    GREATER_EQUAL   reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    LESS_EQUAL      reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    SPACESHIP       reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    CASE_EQUAL      reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    SEMICOLON       reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    BREAK           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    NEXT            reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    IDENTIFIER      reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    INSTANCE_VARIABLE reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    CLASS_VARIABLE  reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    GLOBAL_VARIABLE reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    CONSTANT        reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    PUTS            reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    FOR             reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    IF              reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    WHILE           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    DEF             reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    RETURN          reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    CLASS           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    $end            reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    LOGICAL_AND     reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    AND             reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    LOGICAL_OR      reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    OR              reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    END             reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    ELSIF           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    ELSE            reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    RBRACKET        reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    COMMA           reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    RPAREN          reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    HASH_ROCKET     reduce using rule 28 (expression -> GLOBAL_VARIABLE .)
    RBRACE          reduce using rule 28 (expression -> GLOBAL_VARIABLE .)


state 55

    (29) expression -> CONSTANT .

    RANGE_EXCLUSIVE reduce using rule 29 (expression -> CONSTANT .)
    RANGE_INCLUSIVE reduce using rule 29 (expression -> CONSTANT .)
    PLUS            reduce using rule 29 (expression -> CONSTANT .)
    MINUS           reduce using rule 29 (expression -> CONSTANT .)
    TIMES           reduce using rule 29 (expression -> CONSTANT .)
    DIVIDE          reduce using rule 29 (expression -> CONSTANT .)
    MODULE_OP       reduce using rule 29 (expression -> CONSTANT .)
    POWER           reduce using rule 29 (expression -> CONSTANT .)
    EQUAL           reduce using rule 29 (expression -> CONSTANT .)
    NOT_EQUAL       reduce using rule 29 (expression -> CONSTANT .)
    GREATER         reduce using rule 29 (expression -> CONSTANT .)
    LESS            reduce using rule 29 (expression -> CONSTANT .)
    GREATER_EQUAL   reduce using rule 29 (expression -> CONSTANT .)
    LESS_EQUAL      reduce using rule 29 (expression -> CONSTANT .)
    SPACESHIP       reduce using rule 29 (expression -> CONSTANT .)
    CASE_EQUAL      reduce using rule 29 (expression -> CONSTANT .)
    SEMICOLON       reduce using rule 29 (expression -> CONSTANT .)
    BREAK           reduce using rule 29 (expression -> CONSTANT .)
    NEXT            reduce using rule 29 (expression -> CONSTANT .)
    IDENTIFIER      reduce using rule 29 (expression -> CONSTANT .)
    INSTANCE_VARIABLE reduce using rule 29 (expression -> CONSTANT .)
    CLASS_VARIABLE  reduce using rule 29 (expression -> CONSTANT .)
    GLOBAL_VARIABLE reduce using rule 29 (expression -> CONSTANT .)
    CONSTANT        reduce using rule 29 (expression -> CONSTANT .)
    PUTS            reduce using rule 29 (expression -> CONSTANT .)
    FOR             reduce using rule 29 (expression -> CONSTANT .)
    IF              reduce using rule 29 (expression -> CONSTANT .)
    WHILE           reduce using rule 29 (expression -> CONSTANT .)
    DEF             reduce using rule 29 (expression -> CONSTANT .)
    RETURN          reduce using rule 29 (expression -> CONSTANT .)
    CLASS           reduce using rule 29 (expression -> CONSTANT .)
    $end            reduce using rule 29 (expression -> CONSTANT .)
    LOGICAL_AND     reduce using rule 29 (expression -> CONSTANT .)
    AND             reduce using rule 29 (expression -> CONSTANT .)
    LOGICAL_OR      reduce using rule 29 (expression -> CONSTANT .)
    OR              reduce using rule 29 (expression -> CONSTANT .)
    END             reduce using rule 29 (expression -> CONSTANT .)
    ELSIF           reduce using rule 29 (expression -> CONSTANT .)
    ELSE            reduce using rule 29 (expression -> CONSTANT .)
    RBRACKET        reduce using rule 29 (expression -> CONSTANT .)
    COMMA           reduce using rule 29 (expression -> CONSTANT .)
    RPAREN          reduce using rule 29 (expression -> CONSTANT .)
    HASH_ROCKET     reduce using rule 29 (expression -> CONSTANT .)
    RBRACE          reduce using rule 29 (expression -> CONSTANT .)


state 56

    (30) expression -> array_access .

    RANGE_EXCLUSIVE reduce using rule 30 (expression -> array_access .)
    RANGE_INCLUSIVE reduce using rule 30 (expression -> array_access .)
    PLUS            reduce using rule 30 (expression -> array_access .)
    MINUS           reduce using rule 30 (expression -> array_access .)
    TIMES           reduce using rule 30 (expression -> array_access .)
    DIVIDE          reduce using rule 30 (expression -> array_access .)
    MODULE_OP       reduce using rule 30 (expression -> array_access .)
    POWER           reduce using rule 30 (expression -> array_access .)
    EQUAL           reduce using rule 30 (expression -> array_access .)
    NOT_EQUAL       reduce using rule 30 (expression -> array_access .)
    GREATER         reduce using rule 30 (expression -> array_access .)
    LESS            reduce using rule 30 (expression -> array_access .)
    GREATER_EQUAL   reduce using rule 30 (expression -> array_access .)
    LESS_EQUAL      reduce using rule 30 (expression -> array_access .)
    SPACESHIP       reduce using rule 30 (expression -> array_access .)
    CASE_EQUAL      reduce using rule 30 (expression -> array_access .)
    SEMICOLON       reduce using rule 30 (expression -> array_access .)
    BREAK           reduce using rule 30 (expression -> array_access .)
    NEXT            reduce using rule 30 (expression -> array_access .)
    IDENTIFIER      reduce using rule 30 (expression -> array_access .)
    INSTANCE_VARIABLE reduce using rule 30 (expression -> array_access .)
    CLASS_VARIABLE  reduce using rule 30 (expression -> array_access .)
    GLOBAL_VARIABLE reduce using rule 30 (expression -> array_access .)
    CONSTANT        reduce using rule 30 (expression -> array_access .)
    PUTS            reduce using rule 30 (expression -> array_access .)
    FOR             reduce using rule 30 (expression -> array_access .)
    IF              reduce using rule 30 (expression -> array_access .)
    WHILE           reduce using rule 30 (expression -> array_access .)
    DEF             reduce using rule 30 (expression -> array_access .)
    RETURN          reduce using rule 30 (expression -> array_access .)
    CLASS           reduce using rule 30 (expression -> array_access .)
    $end            reduce using rule 30 (expression -> array_access .)
    LOGICAL_AND     reduce using rule 30 (expression -> array_access .)
    AND             reduce using rule 30 (expression -> array_access .)
    LOGICAL_OR      reduce using rule 30 (expression -> array_access .)
    OR              reduce using rule 30 (expression -> array_access .)
    END             reduce using rule 30 (expression -> array_access .)
    ELSIF           reduce using rule 30 (expression -> array_access .)
    ELSE            reduce using rule 30 (expression -> array_access .)
    RBRACKET        reduce using rule 30 (expression -> array_access .)
    COMMA           reduce using rule 30 (expression -> array_access .)
    RPAREN          reduce using rule 30 (expression -> array_access .)
    HASH_ROCKET     reduce using rule 30 (expression -> array_access .)
    RBRACE          reduce using rule 30 (expression -> array_access .)


state 57

    (106) expression -> function_call .

    RANGE_EXCLUSIVE reduce using rule 106 (expression -> function_call .)
    RANGE_INCLUSIVE reduce using rule 106 (expression -> function_call .)
    PLUS            reduce using rule 106 (expression -> function_call .)
    MINUS           reduce using rule 106 (expression -> function_call .)
    TIMES           reduce using rule 106 (expression -> function_call .)
    DIVIDE          reduce using rule 106 (expression -> function_call .)
    MODULE_OP       reduce using rule 106 (expression -> function_call .)
    POWER           reduce using rule 106 (expression -> function_call .)
    EQUAL           reduce using rule 106 (expression -> function_call .)
    NOT_EQUAL       reduce using rule 106 (expression -> function_call .)
    GREATER         reduce using rule 106 (expression -> function_call .)
    LESS            reduce using rule 106 (expression -> function_call .)
    GREATER_EQUAL   reduce using rule 106 (expression -> function_call .)
    LESS_EQUAL      reduce using rule 106 (expression -> function_call .)
    SPACESHIP       reduce using rule 106 (expression -> function_call .)
    CASE_EQUAL      reduce using rule 106 (expression -> function_call .)
    SEMICOLON       reduce using rule 106 (expression -> function_call .)
    BREAK           reduce using rule 106 (expression -> function_call .)
    NEXT            reduce using rule 106 (expression -> function_call .)
    IDENTIFIER      reduce using rule 106 (expression -> function_call .)
    INSTANCE_VARIABLE reduce using rule 106 (expression -> function_call .)
    CLASS_VARIABLE  reduce using rule 106 (expression -> function_call .)
    GLOBAL_VARIABLE reduce using rule 106 (expression -> function_call .)
    CONSTANT        reduce using rule 106 (expression -> function_call .)
    PUTS            reduce using rule 106 (expression -> function_call .)
    FOR             reduce using rule 106 (expression -> function_call .)
    IF              reduce using rule 106 (expression -> function_call .)
    WHILE           reduce using rule 106 (expression -> function_call .)
    DEF             reduce using rule 106 (expression -> function_call .)
    RETURN          reduce using rule 106 (expression -> function_call .)
    CLASS           reduce using rule 106 (expression -> function_call .)
    $end            reduce using rule 106 (expression -> function_call .)
    LOGICAL_AND     reduce using rule 106 (expression -> function_call .)
    AND             reduce using rule 106 (expression -> function_call .)
    LOGICAL_OR      reduce using rule 106 (expression -> function_call .)
    OR              reduce using rule 106 (expression -> function_call .)
    END             reduce using rule 106 (expression -> function_call .)
    ELSIF           reduce using rule 106 (expression -> function_call .)
    ELSE            reduce using rule 106 (expression -> function_call .)
    RBRACKET        reduce using rule 106 (expression -> function_call .)
    COMMA           reduce using rule 106 (expression -> function_call .)
    RPAREN          reduce using rule 106 (expression -> function_call .)
    HASH_ROCKET     reduce using rule 106 (expression -> function_call .)
    RBRACE          reduce using rule 106 (expression -> function_call .)


state 58

    (55) expression -> MINUS . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 112
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 59

    (54) expression -> LPAREN . expression RPAREN
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 113
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 60

    (67) expression -> LBRACE . hash_pairs RBRACE
    (68) expression -> LBRACE . RBRACE
    (69) hash_pairs -> . hash_pairs COMMA hash_pair
    (70) hash_pairs -> . hash_pair
    (71) hash_pair -> . expression HASH_ROCKET expression
    (72) hash_pair -> . SYMBOL HASH_ROCKET expression
    (73) hash_pair -> . STRING HASH_ROCKET expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    RBRACE          shift and go to state 115
    SYMBOL          shift and go to state 118
    STRING          shift and go to state 119
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    hash_pairs                     shift and go to state 114
    hash_pair                      shift and go to state 116
    expression                     shift and go to state 117
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 61

    (93) expression -> LBRACKET . array_elements RBRACKET
    (94) expression -> LBRACKET . RBRACKET
    (95) array_elements -> . array_elements COMMA expression
    (96) array_elements -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    RBRACKET        shift and go to state 121
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    array_elements                 shift and go to state 120
    expression                     shift and go to state 122
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 62

    (90) condition -> LOGICAL_NOT . condition
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 123
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 63

    (91) condition -> NOT . condition
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 124
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 64

    (97) control_statement -> FOR for_setup . statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    statements                     shift and go to state 125
    empty                          shift and go to state 3

state 65

    (98) for_setup -> IDENTIFIER . IN expression enter_loop_scope

    IN              shift and go to state 126


state 66

    (99) control_statement -> IF condition . enter_scope statements exit_scope END
    (100) control_statement -> IF condition . enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> IF condition . enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> IF condition . enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .
    (2) enter_scope -> . empty
    (1) empty -> .

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for ELSIF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for NEXT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for PUTS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for FOR resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for DEF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for END resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 1 (empty -> .)
    LOGICAL_AND     shift and go to state 103
    AND             shift and go to state 104
    LOGICAL_OR      shift and go to state 105
    OR              shift and go to state 106
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]
  ! AND             [ reduce using rule 24 (expression -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 24 (expression -> condition .) ]
  ! OR              [ reduce using rule 24 (expression -> condition .) ]
  ! ELSIF           [ reduce using rule 24 (expression -> condition .) ]
  ! SEMICOLON       [ reduce using rule 24 (expression -> condition .) ]
  ! BREAK           [ reduce using rule 24 (expression -> condition .) ]
  ! NEXT            [ reduce using rule 24 (expression -> condition .) ]
  ! IDENTIFIER      [ reduce using rule 24 (expression -> condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 24 (expression -> condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 24 (expression -> condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 24 (expression -> condition .) ]
  ! CONSTANT        [ reduce using rule 24 (expression -> condition .) ]
  ! PUTS            [ reduce using rule 24 (expression -> condition .) ]
  ! FOR             [ reduce using rule 24 (expression -> condition .) ]
  ! IF              [ reduce using rule 24 (expression -> condition .) ]
  ! WHILE           [ reduce using rule 24 (expression -> condition .) ]
  ! DEF             [ reduce using rule 24 (expression -> condition .) ]
  ! RETURN          [ reduce using rule 24 (expression -> condition .) ]
  ! CLASS           [ reduce using rule 24 (expression -> condition .) ]
  ! END             [ reduce using rule 24 (expression -> condition .) ]
  ! ELSE            [ reduce using rule 24 (expression -> condition .) ]

    enter_scope                    shift and go to state 127
    empty                          shift and go to state 128

state 67

    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)
    ELSIF           reduce using rule 92 (condition -> expression .)
    SEMICOLON       reduce using rule 92 (condition -> expression .)
    BREAK           reduce using rule 92 (condition -> expression .)
    NEXT            reduce using rule 92 (condition -> expression .)
    IDENTIFIER      reduce using rule 92 (condition -> expression .)
    INSTANCE_VARIABLE reduce using rule 92 (condition -> expression .)
    CLASS_VARIABLE  reduce using rule 92 (condition -> expression .)
    GLOBAL_VARIABLE reduce using rule 92 (condition -> expression .)
    CONSTANT        reduce using rule 92 (condition -> expression .)
    PUTS            reduce using rule 92 (condition -> expression .)
    FOR             reduce using rule 92 (condition -> expression .)
    IF              reduce using rule 92 (condition -> expression .)
    WHILE           reduce using rule 92 (condition -> expression .)
    DEF             reduce using rule 92 (condition -> expression .)
    RETURN          reduce using rule 92 (condition -> expression .)
    CLASS           reduce using rule 92 (condition -> expression .)
    END             reduce using rule 92 (condition -> expression .)
    ELSE            reduce using rule 92 (condition -> expression .)
    COMMA           reduce using rule 92 (condition -> expression .)
    $end            reduce using rule 92 (condition -> expression .)
    RBRACKET        reduce using rule 92 (condition -> expression .)
    RPAREN          reduce using rule 92 (condition -> expression .)
    HASH_ROCKET     reduce using rule 92 (condition -> expression .)
    RBRACE          reduce using rule 92 (condition -> expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94

  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]


state 68

    (105) control_statement -> WHILE condition . enter_loop_scope statements exit_scope END
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .
    (3) enter_loop_scope -> . empty
    (1) empty -> .

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for NEXT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for PUTS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for FOR resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for DEF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for END resolved using rule 1 (empty -> .)
    LOGICAL_AND     shift and go to state 103
    AND             shift and go to state 104
    LOGICAL_OR      shift and go to state 105
    OR              shift and go to state 106
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]
  ! AND             [ reduce using rule 24 (expression -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 24 (expression -> condition .) ]
  ! OR              [ reduce using rule 24 (expression -> condition .) ]
  ! SEMICOLON       [ reduce using rule 24 (expression -> condition .) ]
  ! BREAK           [ reduce using rule 24 (expression -> condition .) ]
  ! NEXT            [ reduce using rule 24 (expression -> condition .) ]
  ! IDENTIFIER      [ reduce using rule 24 (expression -> condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 24 (expression -> condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 24 (expression -> condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 24 (expression -> condition .) ]
  ! CONSTANT        [ reduce using rule 24 (expression -> condition .) ]
  ! PUTS            [ reduce using rule 24 (expression -> condition .) ]
  ! FOR             [ reduce using rule 24 (expression -> condition .) ]
  ! IF              [ reduce using rule 24 (expression -> condition .) ]
  ! WHILE           [ reduce using rule 24 (expression -> condition .) ]
  ! DEF             [ reduce using rule 24 (expression -> condition .) ]
  ! RETURN          [ reduce using rule 24 (expression -> condition .) ]
  ! CLASS           [ reduce using rule 24 (expression -> condition .) ]
  ! END             [ reduce using rule 24 (expression -> condition .) ]

    enter_loop_scope               shift and go to state 129
    empty                          shift and go to state 130

state 69

    (60) function_definition -> DEF func_name_hook . func_header statements exit_scope END
    (62) func_header -> . LPAREN param_list RPAREN
    (63) func_header -> . LPAREN RPAREN
    (64) func_header -> . empty
    (1) empty -> .

    LPAREN          shift and go to state 132
    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    func_header                    shift and go to state 131
    empty                          shift and go to state 133

state 70

    (61) func_name_hook -> IDENTIFIER .

    LPAREN          reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    BREAK           reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    NEXT            reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    INSTANCE_VARIABLE reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    CLASS_VARIABLE  reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    GLOBAL_VARIABLE reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    CONSTANT        reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    PUTS            reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    FOR             reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    IF              reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    WHILE           reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    DEF             reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    RETURN          reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    CLASS           reduce using rule 61 (func_name_hook -> IDENTIFIER .)
    END             reduce using rule 61 (func_name_hook -> IDENTIFIER .)


state 71

    (65) return_statement -> RETURN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for IF resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for $end resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for END resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 65 (return_statement -> RETURN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 65 (return_statement -> RETURN expression .)
    SEMICOLON       reduce using rule 65 (return_statement -> RETURN expression .)
    BREAK           reduce using rule 65 (return_statement -> RETURN expression .)
    NEXT            reduce using rule 65 (return_statement -> RETURN expression .)
    IDENTIFIER      reduce using rule 65 (return_statement -> RETURN expression .)
    INSTANCE_VARIABLE reduce using rule 65 (return_statement -> RETURN expression .)
    CLASS_VARIABLE  reduce using rule 65 (return_statement -> RETURN expression .)
    GLOBAL_VARIABLE reduce using rule 65 (return_statement -> RETURN expression .)
    CONSTANT        reduce using rule 65 (return_statement -> RETURN expression .)
    PUTS            reduce using rule 65 (return_statement -> RETURN expression .)
    FOR             reduce using rule 65 (return_statement -> RETURN expression .)
    IF              reduce using rule 65 (return_statement -> RETURN expression .)
    WHILE           reduce using rule 65 (return_statement -> RETURN expression .)
    DEF             reduce using rule 65 (return_statement -> RETURN expression .)
    RETURN          reduce using rule 65 (return_statement -> RETURN expression .)
    CLASS           reduce using rule 65 (return_statement -> RETURN expression .)
    $end            reduce using rule 65 (return_statement -> RETURN expression .)
    END             reduce using rule 65 (return_statement -> RETURN expression .)
    ELSIF           reduce using rule 65 (return_statement -> RETURN expression .)
    ELSE            reduce using rule 65 (return_statement -> RETURN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 72

    (56) class_definition -> CLASS CONSTANT . enter_scope statements exit_scope END
    (57) class_definition -> CLASS CONSTANT . LESS CONSTANT enter_scope statements exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    LESS            shift and go to state 135
    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 134
    empty                          shift and go to state 128

state 73

    (41) assignment -> IDENTIFIER ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    SEMICOLON       reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    BREAK           reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    NEXT            reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    CONSTANT        reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    PUTS            reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    IF              reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    DEF             reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    RETURN          reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    CLASS           reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    END             reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    ELSIF           reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    ELSE            reduce using rule 41 (assignment -> IDENTIFIER ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 74

    (76) io_statement -> IDENTIFIER ASSIGN GETS . DOT IDENTIFIER
    (77) io_statement -> IDENTIFIER ASSIGN GETS .

    DOT             shift and go to state 136
    SEMICOLON       reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    BREAK           reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    NEXT            reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    IDENTIFIER      reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    INSTANCE_VARIABLE reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    CLASS_VARIABLE  reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    GLOBAL_VARIABLE reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    CONSTANT        reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    PUTS            reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    FOR             reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    IF              reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    WHILE           reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    DEF             reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    RETURN          reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    CLASS           reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    $end            reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    END             reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    ELSIF           reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)
    ELSE            reduce using rule 77 (io_statement -> IDENTIFIER ASSIGN GETS .)


state 75

    (35) special_assignment -> IDENTIFIER PLUS_ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    SEMICOLON       reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    BREAK           reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    NEXT            reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    IDENTIFIER      reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    CONSTANT        reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    PUTS            reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    FOR             reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    IF              reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    WHILE           reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    DEF             reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    RETURN          reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    CLASS           reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    $end            reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    END             reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    ELSIF           reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    ELSE            reduce using rule 35 (special_assignment -> IDENTIFIER PLUS_ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 76

    (36) special_assignment -> IDENTIFIER MINUS_ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    SEMICOLON       reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    BREAK           reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    NEXT            reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    IDENTIFIER      reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    CONSTANT        reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    PUTS            reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    FOR             reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    IF              reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    WHILE           reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    DEF             reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    RETURN          reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    CLASS           reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    $end            reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    END             reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    ELSIF           reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    ELSE            reduce using rule 36 (special_assignment -> IDENTIFIER MINUS_ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 77

    (37) special_assignment -> IDENTIFIER TIMES_ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    SEMICOLON       reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    BREAK           reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    NEXT            reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    IDENTIFIER      reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    CONSTANT        reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    PUTS            reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    FOR             reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    IF              reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    WHILE           reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    DEF             reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    RETURN          reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    CLASS           reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    $end            reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    END             reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    ELSIF           reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    ELSE            reduce using rule 37 (special_assignment -> IDENTIFIER TIMES_ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 78

    (38) special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    SEMICOLON       reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    BREAK           reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    NEXT            reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    IDENTIFIER      reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    CONSTANT        reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    PUTS            reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    FOR             reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    IF              reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    WHILE           reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    DEF             reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    RETURN          reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    CLASS           reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    $end            reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    END             reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    ELSIF           reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    ELSE            reduce using rule 38 (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 79

    (39) special_assignment -> IDENTIFIER MOD_ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    SEMICOLON       reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    BREAK           reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    NEXT            reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    IDENTIFIER      reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    CONSTANT        reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    PUTS            reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    FOR             reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    IF              reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    WHILE           reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    DEF             reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    RETURN          reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    CLASS           reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    $end            reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    END             reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    ELSIF           reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    ELSE            reduce using rule 39 (special_assignment -> IDENTIFIER MOD_ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 80

    (40) special_assignment -> IDENTIFIER POWER_ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    SEMICOLON       reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    BREAK           reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    NEXT            reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    IDENTIFIER      reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    CONSTANT        reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    PUTS            reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    FOR             reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    IF              reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    WHILE           reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    DEF             reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    RETURN          reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    CLASS           reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    $end            reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    END             reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    ELSIF           reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    ELSE            reduce using rule 40 (special_assignment -> IDENTIFIER POWER_ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 81

    (47) array_access -> IDENTIFIER LBRACKET expression . RBRACKET
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RBRACKET resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
    RBRACKET        shift and go to state 137
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 82

    (42) assignment -> INSTANCE_VARIABLE ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    BREAK           reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    NEXT            reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    IDENTIFIER      reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    CONSTANT        reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    PUTS            reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    FOR             reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    IF              reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    WHILE           reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    DEF             reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    RETURN          reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    CLASS           reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    $end            reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    END             reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    ELSIF           reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    ELSE            reduce using rule 42 (assignment -> INSTANCE_VARIABLE ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 83

    (43) assignment -> CLASS_VARIABLE ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    BREAK           reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    NEXT            reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    IDENTIFIER      reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    CONSTANT        reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    PUTS            reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    FOR             reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    IF              reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    WHILE           reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    DEF             reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    RETURN          reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    CLASS           reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    $end            reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    END             reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    ELSIF           reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    ELSE            reduce using rule 43 (assignment -> CLASS_VARIABLE ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 84

    (44) assignment -> GLOBAL_VARIABLE ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    BREAK           reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    NEXT            reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    IDENTIFIER      reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    CONSTANT        reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    PUTS            reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    FOR             reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    IF              reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    WHILE           reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    DEF             reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    RETURN          reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    CLASS           reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    $end            reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    END             reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    ELSIF           reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    ELSE            reduce using rule 44 (assignment -> GLOBAL_VARIABLE ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 85

    (45) assignment -> CONSTANT ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    SEMICOLON       reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    BREAK           reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    NEXT            reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    IDENTIFIER      reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    CONSTANT        reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    PUTS            reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    FOR             reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    IF              reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    WHILE           reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    DEF             reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    RETURN          reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    CLASS           reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    $end            reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    END             reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    ELSIF           reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    ELSE            reduce using rule 45 (assignment -> CONSTANT ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 86

    (46) assignment -> array_access ASSIGN expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for FOR resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for IF resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for DEF resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for $end resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for END resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 46 (assignment -> array_access ASSIGN expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 46 (assignment -> array_access ASSIGN expression .)
    SEMICOLON       reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    BREAK           reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    NEXT            reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    IDENTIFIER      reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    INSTANCE_VARIABLE reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    CLASS_VARIABLE  reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    GLOBAL_VARIABLE reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    CONSTANT        reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    PUTS            reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    FOR             reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    IF              reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    WHILE           reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    DEF             reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    RETURN          reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    CLASS           reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    $end            reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    END             reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    ELSIF           reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    ELSE            reduce using rule 46 (assignment -> array_access ASSIGN expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]


state 87

    (31) expression -> expression RANGE_EXCLUSIVE . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 138
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 88

    (32) expression -> expression RANGE_INCLUSIVE . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 139
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 89

    (48) expression -> expression PLUS . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 140
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 90

    (49) expression -> expression MINUS . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 141
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 91

    (50) expression -> expression TIMES . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 142
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 92

    (51) expression -> expression DIVIDE . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 143
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 93

    (52) expression -> expression MODULE_OP . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 144
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 94

    (53) expression -> expression POWER . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 145
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 95

    (78) condition -> expression EQUAL . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 146
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 96

    (79) condition -> expression NOT_EQUAL . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 147
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 97

    (80) condition -> expression GREATER . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 148
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 98

    (81) condition -> expression LESS . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 149
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 99

    (82) condition -> expression GREATER_EQUAL . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 150
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 100

    (83) condition -> expression LESS_EQUAL . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 151
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 101

    (84) condition -> expression SPACESHIP . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 152
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 102

    (85) condition -> expression CASE_EQUAL . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 153
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 103

    (86) condition -> condition LOGICAL_AND . condition
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 154
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 104

    (87) condition -> condition AND . condition
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 155
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 105

    (88) condition -> condition LOGICAL_OR . condition
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 156
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 106

    (89) condition -> condition OR . condition
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 157
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 107

    (33) expression -> IDENTIFIER DOT . IDENTIFIER
    (34) expression -> IDENTIFIER DOT . function_call
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    IDENTIFIER      shift and go to state 158

    function_call                  shift and go to state 159

state 108

    (47) array_access -> IDENTIFIER LBRACKET . expression RBRACKET
    (93) expression -> LBRACKET . array_elements RBRACKET
    (94) expression -> LBRACKET . RBRACKET
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (95) array_elements -> . array_elements COMMA expression
    (96) array_elements -> . expression
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    RBRACKET        shift and go to state 121
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 160
    array_elements                 shift and go to state 120
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 109

    (111) arguments -> expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 92 (condition -> expression .)
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for FOR resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for IF resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for DEF resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for $end resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for AND resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for OR resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for END resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 92 (condition -> expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    COMMA           reduce using rule 92 (condition -> expression .)
    SEMICOLON       reduce using rule 92 (condition -> expression .)
    BREAK           reduce using rule 92 (condition -> expression .)
    NEXT            reduce using rule 92 (condition -> expression .)
    IDENTIFIER      reduce using rule 92 (condition -> expression .)
    INSTANCE_VARIABLE reduce using rule 92 (condition -> expression .)
    CLASS_VARIABLE  reduce using rule 92 (condition -> expression .)
    GLOBAL_VARIABLE reduce using rule 92 (condition -> expression .)
    CONSTANT        reduce using rule 92 (condition -> expression .)
    PUTS            reduce using rule 92 (condition -> expression .)
    FOR             reduce using rule 92 (condition -> expression .)
    IF              reduce using rule 92 (condition -> expression .)
    WHILE           reduce using rule 92 (condition -> expression .)
    DEF             reduce using rule 92 (condition -> expression .)
    RETURN          reduce using rule 92 (condition -> expression .)
    CLASS           reduce using rule 92 (condition -> expression .)
    $end            reduce using rule 92 (condition -> expression .)
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)
    END             reduce using rule 92 (condition -> expression .)
    ELSIF           reduce using rule 92 (condition -> expression .)
    ELSE            reduce using rule 92 (condition -> expression .)
    RBRACKET        reduce using rule 92 (condition -> expression .)
    RPAREN          reduce using rule 92 (condition -> expression .)
    HASH_ROCKET     reduce using rule 92 (condition -> expression .)
    RBRACE          reduce using rule 92 (condition -> expression .)

  ! COMMA           [ reduce using rule 111 (arguments -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 111 (arguments -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 111 (arguments -> expression .) ]
  ! PLUS            [ reduce using rule 111 (arguments -> expression .) ]
  ! MINUS           [ reduce using rule 111 (arguments -> expression .) ]
  ! TIMES           [ reduce using rule 111 (arguments -> expression .) ]
  ! DIVIDE          [ reduce using rule 111 (arguments -> expression .) ]
  ! MODULE_OP       [ reduce using rule 111 (arguments -> expression .) ]
  ! POWER           [ reduce using rule 111 (arguments -> expression .) ]
  ! EQUAL           [ reduce using rule 111 (arguments -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 111 (arguments -> expression .) ]
  ! GREATER         [ reduce using rule 111 (arguments -> expression .) ]
  ! LESS            [ reduce using rule 111 (arguments -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 111 (arguments -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 111 (arguments -> expression .) ]
  ! SPACESHIP       [ reduce using rule 111 (arguments -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 111 (arguments -> expression .) ]
  ! SEMICOLON       [ reduce using rule 111 (arguments -> expression .) ]
  ! BREAK           [ reduce using rule 111 (arguments -> expression .) ]
  ! NEXT            [ reduce using rule 111 (arguments -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 111 (arguments -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 111 (arguments -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 111 (arguments -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 111 (arguments -> expression .) ]
  ! CONSTANT        [ reduce using rule 111 (arguments -> expression .) ]
  ! PUTS            [ reduce using rule 111 (arguments -> expression .) ]
  ! FOR             [ reduce using rule 111 (arguments -> expression .) ]
  ! IF              [ reduce using rule 111 (arguments -> expression .) ]
  ! WHILE           [ reduce using rule 111 (arguments -> expression .) ]
  ! DEF             [ reduce using rule 111 (arguments -> expression .) ]
  ! RETURN          [ reduce using rule 111 (arguments -> expression .) ]
  ! CLASS           [ reduce using rule 111 (arguments -> expression .) ]
  ! $end            [ reduce using rule 111 (arguments -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 111 (arguments -> expression .) ]
  ! AND             [ reduce using rule 111 (arguments -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 111 (arguments -> expression .) ]
  ! OR              [ reduce using rule 111 (arguments -> expression .) ]
  ! END             [ reduce using rule 111 (arguments -> expression .) ]
  ! ELSIF           [ reduce using rule 111 (arguments -> expression .) ]
  ! ELSE            [ reduce using rule 111 (arguments -> expression .) ]
  ! RBRACKET        [ reduce using rule 111 (arguments -> expression .) ]
  ! RPAREN          [ reduce using rule 111 (arguments -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 111 (arguments -> expression .) ]
  ! RBRACE          [ reduce using rule 111 (arguments -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 110

    (107) function_call -> IDENTIFIER LPAREN . arguments RPAREN
    (108) function_call -> IDENTIFIER LPAREN . RPAREN
    (54) expression -> LPAREN . expression RPAREN
    (110) arguments -> . arguments COMMA expression
    (111) arguments -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    RPAREN          shift and go to state 162
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    arguments                      shift and go to state 161
    expression                     shift and go to state 163
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 111

    (109) function_call -> IDENTIFIER arguments .
    (110) arguments -> arguments . COMMA expression

  ! shift/reduce conflict for COMMA resolved as shift
    RANGE_EXCLUSIVE reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    RANGE_INCLUSIVE reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    PLUS            reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    MINUS           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    TIMES           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    DIVIDE          reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    MODULE_OP       reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    POWER           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    EQUAL           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    NOT_EQUAL       reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    GREATER         reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    LESS            reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    GREATER_EQUAL   reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    LESS_EQUAL      reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    SPACESHIP       reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    CASE_EQUAL      reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    SEMICOLON       reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    BREAK           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    NEXT            reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    IDENTIFIER      reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    INSTANCE_VARIABLE reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    CLASS_VARIABLE  reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    GLOBAL_VARIABLE reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    CONSTANT        reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    PUTS            reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    FOR             reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    IF              reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    WHILE           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    DEF             reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    RETURN          reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    CLASS           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    $end            reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    LOGICAL_AND     reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    AND             reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    LOGICAL_OR      reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    OR              reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    END             reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    ELSIF           reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    ELSE            reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    RBRACKET        reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    RPAREN          reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    HASH_ROCKET     reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    RBRACE          reduce using rule 109 (function_call -> IDENTIFIER arguments .)
    COMMA           shift and go to state 164

  ! COMMA           [ reduce using rule 109 (function_call -> IDENTIFIER arguments .) ]


state 112

    (55) expression -> MINUS expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for POWER resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for EQUAL resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for LESS resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for FOR resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for IF resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for DEF resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for $end resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for AND resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for OR resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for END resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 55 (expression -> MINUS expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 55 (expression -> MINUS expression .)
    RANGE_EXCLUSIVE reduce using rule 55 (expression -> MINUS expression .)
    RANGE_INCLUSIVE reduce using rule 55 (expression -> MINUS expression .)
    PLUS            reduce using rule 55 (expression -> MINUS expression .)
    MINUS           reduce using rule 55 (expression -> MINUS expression .)
    TIMES           reduce using rule 55 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 55 (expression -> MINUS expression .)
    MODULE_OP       reduce using rule 55 (expression -> MINUS expression .)
    POWER           reduce using rule 55 (expression -> MINUS expression .)
    EQUAL           reduce using rule 55 (expression -> MINUS expression .)
    NOT_EQUAL       reduce using rule 55 (expression -> MINUS expression .)
    GREATER         reduce using rule 55 (expression -> MINUS expression .)
    LESS            reduce using rule 55 (expression -> MINUS expression .)
    GREATER_EQUAL   reduce using rule 55 (expression -> MINUS expression .)
    LESS_EQUAL      reduce using rule 55 (expression -> MINUS expression .)
    SPACESHIP       reduce using rule 55 (expression -> MINUS expression .)
    CASE_EQUAL      reduce using rule 55 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 55 (expression -> MINUS expression .)
    BREAK           reduce using rule 55 (expression -> MINUS expression .)
    NEXT            reduce using rule 55 (expression -> MINUS expression .)
    IDENTIFIER      reduce using rule 55 (expression -> MINUS expression .)
    INSTANCE_VARIABLE reduce using rule 55 (expression -> MINUS expression .)
    CLASS_VARIABLE  reduce using rule 55 (expression -> MINUS expression .)
    GLOBAL_VARIABLE reduce using rule 55 (expression -> MINUS expression .)
    CONSTANT        reduce using rule 55 (expression -> MINUS expression .)
    PUTS            reduce using rule 55 (expression -> MINUS expression .)
    FOR             reduce using rule 55 (expression -> MINUS expression .)
    IF              reduce using rule 55 (expression -> MINUS expression .)
    WHILE           reduce using rule 55 (expression -> MINUS expression .)
    DEF             reduce using rule 55 (expression -> MINUS expression .)
    RETURN          reduce using rule 55 (expression -> MINUS expression .)
    CLASS           reduce using rule 55 (expression -> MINUS expression .)
    $end            reduce using rule 55 (expression -> MINUS expression .)
    LOGICAL_AND     reduce using rule 55 (expression -> MINUS expression .)
    AND             reduce using rule 55 (expression -> MINUS expression .)
    LOGICAL_OR      reduce using rule 55 (expression -> MINUS expression .)
    OR              reduce using rule 55 (expression -> MINUS expression .)
    END             reduce using rule 55 (expression -> MINUS expression .)
    ELSIF           reduce using rule 55 (expression -> MINUS expression .)
    ELSE            reduce using rule 55 (expression -> MINUS expression .)
    RBRACKET        reduce using rule 55 (expression -> MINUS expression .)
    COMMA           reduce using rule 55 (expression -> MINUS expression .)
    RPAREN          reduce using rule 55 (expression -> MINUS expression .)
    HASH_ROCKET     reduce using rule 55 (expression -> MINUS expression .)
    RBRACE          reduce using rule 55 (expression -> MINUS expression .)

  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! PLUS            [ shift and go to state 89 ]
  ! MINUS           [ shift and go to state 90 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 92 ]
  ! MODULE_OP       [ shift and go to state 93 ]
  ! POWER           [ shift and go to state 94 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 113

    (54) expression -> LPAREN expression . RPAREN
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
    RPAREN          shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 114

    (67) expression -> LBRACE hash_pairs . RBRACE
    (69) hash_pairs -> hash_pairs . COMMA hash_pair

    RBRACE          shift and go to state 166
    COMMA           shift and go to state 167


state 115

    (68) expression -> LBRACE RBRACE .

    RANGE_EXCLUSIVE reduce using rule 68 (expression -> LBRACE RBRACE .)
    RANGE_INCLUSIVE reduce using rule 68 (expression -> LBRACE RBRACE .)
    PLUS            reduce using rule 68 (expression -> LBRACE RBRACE .)
    MINUS           reduce using rule 68 (expression -> LBRACE RBRACE .)
    TIMES           reduce using rule 68 (expression -> LBRACE RBRACE .)
    DIVIDE          reduce using rule 68 (expression -> LBRACE RBRACE .)
    MODULE_OP       reduce using rule 68 (expression -> LBRACE RBRACE .)
    POWER           reduce using rule 68 (expression -> LBRACE RBRACE .)
    EQUAL           reduce using rule 68 (expression -> LBRACE RBRACE .)
    NOT_EQUAL       reduce using rule 68 (expression -> LBRACE RBRACE .)
    GREATER         reduce using rule 68 (expression -> LBRACE RBRACE .)
    LESS            reduce using rule 68 (expression -> LBRACE RBRACE .)
    GREATER_EQUAL   reduce using rule 68 (expression -> LBRACE RBRACE .)
    LESS_EQUAL      reduce using rule 68 (expression -> LBRACE RBRACE .)
    SPACESHIP       reduce using rule 68 (expression -> LBRACE RBRACE .)
    CASE_EQUAL      reduce using rule 68 (expression -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 68 (expression -> LBRACE RBRACE .)
    BREAK           reduce using rule 68 (expression -> LBRACE RBRACE .)
    NEXT            reduce using rule 68 (expression -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 68 (expression -> LBRACE RBRACE .)
    INSTANCE_VARIABLE reduce using rule 68 (expression -> LBRACE RBRACE .)
    CLASS_VARIABLE  reduce using rule 68 (expression -> LBRACE RBRACE .)
    GLOBAL_VARIABLE reduce using rule 68 (expression -> LBRACE RBRACE .)
    CONSTANT        reduce using rule 68 (expression -> LBRACE RBRACE .)
    PUTS            reduce using rule 68 (expression -> LBRACE RBRACE .)
    FOR             reduce using rule 68 (expression -> LBRACE RBRACE .)
    IF              reduce using rule 68 (expression -> LBRACE RBRACE .)
    WHILE           reduce using rule 68 (expression -> LBRACE RBRACE .)
    DEF             reduce using rule 68 (expression -> LBRACE RBRACE .)
    RETURN          reduce using rule 68 (expression -> LBRACE RBRACE .)
    CLASS           reduce using rule 68 (expression -> LBRACE RBRACE .)
    $end            reduce using rule 68 (expression -> LBRACE RBRACE .)
    LOGICAL_AND     reduce using rule 68 (expression -> LBRACE RBRACE .)
    AND             reduce using rule 68 (expression -> LBRACE RBRACE .)
    LOGICAL_OR      reduce using rule 68 (expression -> LBRACE RBRACE .)
    OR              reduce using rule 68 (expression -> LBRACE RBRACE .)
    END             reduce using rule 68 (expression -> LBRACE RBRACE .)
    ELSIF           reduce using rule 68 (expression -> LBRACE RBRACE .)
    ELSE            reduce using rule 68 (expression -> LBRACE RBRACE .)
    RBRACKET        reduce using rule 68 (expression -> LBRACE RBRACE .)
    COMMA           reduce using rule 68 (expression -> LBRACE RBRACE .)
    RPAREN          reduce using rule 68 (expression -> LBRACE RBRACE .)
    HASH_ROCKET     reduce using rule 68 (expression -> LBRACE RBRACE .)
    RBRACE          reduce using rule 68 (expression -> LBRACE RBRACE .)


state 116

    (70) hash_pairs -> hash_pair .

    RBRACE          reduce using rule 70 (hash_pairs -> hash_pair .)
    COMMA           reduce using rule 70 (hash_pairs -> hash_pair .)


state 117

    (71) hash_pair -> expression . HASH_ROCKET expression
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for HASH_ROCKET resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
    HASH_ROCKET     shift and go to state 168
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 118

    (72) hash_pair -> SYMBOL . HASH_ROCKET expression
    (19) expression -> SYMBOL .

  ! shift/reduce conflict for HASH_ROCKET resolved as shift
    HASH_ROCKET     shift and go to state 169
    RANGE_EXCLUSIVE reduce using rule 19 (expression -> SYMBOL .)
    RANGE_INCLUSIVE reduce using rule 19 (expression -> SYMBOL .)
    PLUS            reduce using rule 19 (expression -> SYMBOL .)
    MINUS           reduce using rule 19 (expression -> SYMBOL .)
    TIMES           reduce using rule 19 (expression -> SYMBOL .)
    DIVIDE          reduce using rule 19 (expression -> SYMBOL .)
    MODULE_OP       reduce using rule 19 (expression -> SYMBOL .)
    POWER           reduce using rule 19 (expression -> SYMBOL .)
    EQUAL           reduce using rule 19 (expression -> SYMBOL .)
    NOT_EQUAL       reduce using rule 19 (expression -> SYMBOL .)
    GREATER         reduce using rule 19 (expression -> SYMBOL .)
    LESS            reduce using rule 19 (expression -> SYMBOL .)
    GREATER_EQUAL   reduce using rule 19 (expression -> SYMBOL .)
    LESS_EQUAL      reduce using rule 19 (expression -> SYMBOL .)
    SPACESHIP       reduce using rule 19 (expression -> SYMBOL .)
    CASE_EQUAL      reduce using rule 19 (expression -> SYMBOL .)
    LOGICAL_AND     reduce using rule 19 (expression -> SYMBOL .)
    AND             reduce using rule 19 (expression -> SYMBOL .)
    LOGICAL_OR      reduce using rule 19 (expression -> SYMBOL .)
    OR              reduce using rule 19 (expression -> SYMBOL .)

  ! HASH_ROCKET     [ reduce using rule 19 (expression -> SYMBOL .) ]


state 119

    (73) hash_pair -> STRING . HASH_ROCKET expression
    (18) expression -> STRING .

  ! shift/reduce conflict for HASH_ROCKET resolved as shift
    HASH_ROCKET     shift and go to state 170
    RANGE_EXCLUSIVE reduce using rule 18 (expression -> STRING .)
    RANGE_INCLUSIVE reduce using rule 18 (expression -> STRING .)
    PLUS            reduce using rule 18 (expression -> STRING .)
    MINUS           reduce using rule 18 (expression -> STRING .)
    TIMES           reduce using rule 18 (expression -> STRING .)
    DIVIDE          reduce using rule 18 (expression -> STRING .)
    MODULE_OP       reduce using rule 18 (expression -> STRING .)
    POWER           reduce using rule 18 (expression -> STRING .)
    EQUAL           reduce using rule 18 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 18 (expression -> STRING .)
    GREATER         reduce using rule 18 (expression -> STRING .)
    LESS            reduce using rule 18 (expression -> STRING .)
    GREATER_EQUAL   reduce using rule 18 (expression -> STRING .)
    LESS_EQUAL      reduce using rule 18 (expression -> STRING .)
    SPACESHIP       reduce using rule 18 (expression -> STRING .)
    CASE_EQUAL      reduce using rule 18 (expression -> STRING .)
    LOGICAL_AND     reduce using rule 18 (expression -> STRING .)
    AND             reduce using rule 18 (expression -> STRING .)
    LOGICAL_OR      reduce using rule 18 (expression -> STRING .)
    OR              reduce using rule 18 (expression -> STRING .)

  ! HASH_ROCKET     [ reduce using rule 18 (expression -> STRING .) ]


state 120

    (93) expression -> LBRACKET array_elements . RBRACKET
    (95) array_elements -> array_elements . COMMA expression

    RBRACKET        shift and go to state 171
    COMMA           shift and go to state 172


state 121

    (94) expression -> LBRACKET RBRACKET .

    RANGE_EXCLUSIVE reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    PLUS            reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    TIMES           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    MODULE_OP       reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    POWER           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    EQUAL           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    NOT_EQUAL       reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    GREATER         reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    LESS            reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    GREATER_EQUAL   reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    LESS_EQUAL      reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    SPACESHIP       reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    CASE_EQUAL      reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    BREAK           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    NEXT            reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    INSTANCE_VARIABLE reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    CLASS_VARIABLE  reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    GLOBAL_VARIABLE reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    CONSTANT        reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    PUTS            reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    FOR             reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    IF              reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    DEF             reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    RETURN          reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    CLASS           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    $end            reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    LOGICAL_AND     reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    AND             reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    LOGICAL_OR      reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    OR              reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    END             reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    ELSIF           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    ELSE            reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    HASH_ROCKET     reduce using rule 94 (expression -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 94 (expression -> LBRACKET RBRACKET .)


state 122

    (96) array_elements -> expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 92 (condition -> expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    RBRACKET        reduce using rule 92 (condition -> expression .)
    COMMA           reduce using rule 92 (condition -> expression .)
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RBRACKET        [ reduce using rule 96 (array_elements -> expression .) ]
  ! COMMA           [ reduce using rule 96 (array_elements -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 123

    (90) condition -> LOGICAL_NOT condition .
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .

  ! reduce/reduce conflict for COMMA resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NEXT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PUTS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for WHILE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DEF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RETURN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for $end resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for AND resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for END resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSIF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACE resolved using rule 24 (expression -> condition .)
    COMMA           reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 24 (expression -> condition .)
    BREAK           reduce using rule 24 (expression -> condition .)
    NEXT            reduce using rule 24 (expression -> condition .)
    IDENTIFIER      reduce using rule 24 (expression -> condition .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> condition .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> condition .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> condition .)
    CONSTANT        reduce using rule 24 (expression -> condition .)
    PUTS            reduce using rule 24 (expression -> condition .)
    FOR             reduce using rule 24 (expression -> condition .)
    IF              reduce using rule 24 (expression -> condition .)
    WHILE           reduce using rule 24 (expression -> condition .)
    DEF             reduce using rule 24 (expression -> condition .)
    RETURN          reduce using rule 24 (expression -> condition .)
    CLASS           reduce using rule 24 (expression -> condition .)
    $end            reduce using rule 24 (expression -> condition .)
    LOGICAL_AND     reduce using rule 24 (expression -> condition .)
    AND             reduce using rule 24 (expression -> condition .)
    LOGICAL_OR      reduce using rule 24 (expression -> condition .)
    OR              reduce using rule 24 (expression -> condition .)
    END             reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 24 (expression -> condition .)
    ELSE            reduce using rule 24 (expression -> condition .)
    RBRACKET        reduce using rule 24 (expression -> condition .)
    RPAREN          reduce using rule 24 (expression -> condition .)
    HASH_ROCKET     reduce using rule 24 (expression -> condition .)
    RBRACE          reduce using rule 24 (expression -> condition .)

  ! RANGE_EXCLUSIVE [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! PLUS            [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! MINUS           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! TIMES           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! DIVIDE          [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! MODULE_OP       [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! POWER           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! EQUAL           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! NOT_EQUAL       [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! GREATER         [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! LESS            [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! LESS_EQUAL      [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! SPACESHIP       [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! CASE_EQUAL      [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! SEMICOLON       [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! BREAK           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! NEXT            [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! IDENTIFIER      [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! CONSTANT        [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! PUTS            [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! FOR             [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! IF              [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! WHILE           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! DEF             [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! RETURN          [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! CLASS           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! $end            [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_AND     [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! AND             [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! OR              [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! END             [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! ELSIF           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! ELSE            [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! RBRACKET        [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! COMMA           [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! RPAREN          [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! HASH_ROCKET     [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! RBRACE          [ reduce using rule 90 (condition -> LOGICAL_NOT condition .) ]
  ! LOGICAL_AND     [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! LOGICAL_OR      [ shift and go to state 105 ]
  ! OR              [ shift and go to state 106 ]


state 124

    (91) condition -> NOT condition .
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NEXT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PUTS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for WHILE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DEF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RETURN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for $end resolved using rule 24 (expression -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for END resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSIF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACE resolved using rule 24 (expression -> condition .)
    LOGICAL_AND     shift and go to state 103
    AND             shift and go to state 104
    LOGICAL_OR      shift and go to state 105
    OR              shift and go to state 106
    COMMA           reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 24 (expression -> condition .)
    BREAK           reduce using rule 24 (expression -> condition .)
    NEXT            reduce using rule 24 (expression -> condition .)
    IDENTIFIER      reduce using rule 24 (expression -> condition .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> condition .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> condition .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> condition .)
    CONSTANT        reduce using rule 24 (expression -> condition .)
    PUTS            reduce using rule 24 (expression -> condition .)
    FOR             reduce using rule 24 (expression -> condition .)
    IF              reduce using rule 24 (expression -> condition .)
    WHILE           reduce using rule 24 (expression -> condition .)
    DEF             reduce using rule 24 (expression -> condition .)
    RETURN          reduce using rule 24 (expression -> condition .)
    CLASS           reduce using rule 24 (expression -> condition .)
    $end            reduce using rule 24 (expression -> condition .)
    END             reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 24 (expression -> condition .)
    ELSE            reduce using rule 24 (expression -> condition .)
    RBRACKET        reduce using rule 24 (expression -> condition .)
    RPAREN          reduce using rule 24 (expression -> condition .)
    HASH_ROCKET     reduce using rule 24 (expression -> condition .)
    RBRACE          reduce using rule 24 (expression -> condition .)

  ! RANGE_EXCLUSIVE [ reduce using rule 91 (condition -> NOT condition .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 91 (condition -> NOT condition .) ]
  ! PLUS            [ reduce using rule 91 (condition -> NOT condition .) ]
  ! MINUS           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! TIMES           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! DIVIDE          [ reduce using rule 91 (condition -> NOT condition .) ]
  ! MODULE_OP       [ reduce using rule 91 (condition -> NOT condition .) ]
  ! POWER           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! EQUAL           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! NOT_EQUAL       [ reduce using rule 91 (condition -> NOT condition .) ]
  ! GREATER         [ reduce using rule 91 (condition -> NOT condition .) ]
  ! LESS            [ reduce using rule 91 (condition -> NOT condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 91 (condition -> NOT condition .) ]
  ! LESS_EQUAL      [ reduce using rule 91 (condition -> NOT condition .) ]
  ! SPACESHIP       [ reduce using rule 91 (condition -> NOT condition .) ]
  ! CASE_EQUAL      [ reduce using rule 91 (condition -> NOT condition .) ]
  ! SEMICOLON       [ reduce using rule 91 (condition -> NOT condition .) ]
  ! BREAK           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! NEXT            [ reduce using rule 91 (condition -> NOT condition .) ]
  ! IDENTIFIER      [ reduce using rule 91 (condition -> NOT condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 91 (condition -> NOT condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 91 (condition -> NOT condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 91 (condition -> NOT condition .) ]
  ! CONSTANT        [ reduce using rule 91 (condition -> NOT condition .) ]
  ! PUTS            [ reduce using rule 91 (condition -> NOT condition .) ]
  ! FOR             [ reduce using rule 91 (condition -> NOT condition .) ]
  ! IF              [ reduce using rule 91 (condition -> NOT condition .) ]
  ! WHILE           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! DEF             [ reduce using rule 91 (condition -> NOT condition .) ]
  ! RETURN          [ reduce using rule 91 (condition -> NOT condition .) ]
  ! CLASS           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! $end            [ reduce using rule 91 (condition -> NOT condition .) ]
  ! LOGICAL_AND     [ reduce using rule 91 (condition -> NOT condition .) ]
  ! AND             [ reduce using rule 91 (condition -> NOT condition .) ]
  ! LOGICAL_OR      [ reduce using rule 91 (condition -> NOT condition .) ]
  ! OR              [ reduce using rule 91 (condition -> NOT condition .) ]
  ! END             [ reduce using rule 91 (condition -> NOT condition .) ]
  ! ELSIF           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! ELSE            [ reduce using rule 91 (condition -> NOT condition .) ]
  ! RBRACKET        [ reduce using rule 91 (condition -> NOT condition .) ]
  ! COMMA           [ reduce using rule 91 (condition -> NOT condition .) ]
  ! RPAREN          [ reduce using rule 91 (condition -> NOT condition .) ]
  ! HASH_ROCKET     [ reduce using rule 91 (condition -> NOT condition .) ]
  ! RBRACE          [ reduce using rule 91 (condition -> NOT condition .) ]
  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]
  ! AND             [ reduce using rule 24 (expression -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 24 (expression -> condition .) ]
  ! OR              [ reduce using rule 24 (expression -> condition .) ]


state 125

    (97) control_statement -> FOR for_setup statements . exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 173
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 126

    (98) for_setup -> IDENTIFIER IN . expression enter_loop_scope
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 175
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 127

    (99) control_statement -> IF condition enter_scope . statements exit_scope END
    (100) control_statement -> IF condition enter_scope . statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> IF condition enter_scope . statements elsif_clauses exit_scope END
    (102) control_statement -> IF condition enter_scope . statements elsif_clauses ELSE enter_scope statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    ELSIF           reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)

    statements                     shift and go to state 176
    empty                          shift and go to state 3

state 128

    (2) enter_scope -> empty .

    ELSIF           reduce using rule 2 (enter_scope -> empty .)
    SEMICOLON       reduce using rule 2 (enter_scope -> empty .)
    BREAK           reduce using rule 2 (enter_scope -> empty .)
    NEXT            reduce using rule 2 (enter_scope -> empty .)
    IDENTIFIER      reduce using rule 2 (enter_scope -> empty .)
    INSTANCE_VARIABLE reduce using rule 2 (enter_scope -> empty .)
    CLASS_VARIABLE  reduce using rule 2 (enter_scope -> empty .)
    GLOBAL_VARIABLE reduce using rule 2 (enter_scope -> empty .)
    CONSTANT        reduce using rule 2 (enter_scope -> empty .)
    PUTS            reduce using rule 2 (enter_scope -> empty .)
    FOR             reduce using rule 2 (enter_scope -> empty .)
    IF              reduce using rule 2 (enter_scope -> empty .)
    WHILE           reduce using rule 2 (enter_scope -> empty .)
    DEF             reduce using rule 2 (enter_scope -> empty .)
    RETURN          reduce using rule 2 (enter_scope -> empty .)
    CLASS           reduce using rule 2 (enter_scope -> empty .)
    END             reduce using rule 2 (enter_scope -> empty .)
    ELSE            reduce using rule 2 (enter_scope -> empty .)


state 129

    (105) control_statement -> WHILE condition enter_loop_scope . statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    statements                     shift and go to state 177
    empty                          shift and go to state 3

state 130

    (3) enter_loop_scope -> empty .

    SEMICOLON       reduce using rule 3 (enter_loop_scope -> empty .)
    BREAK           reduce using rule 3 (enter_loop_scope -> empty .)
    NEXT            reduce using rule 3 (enter_loop_scope -> empty .)
    IDENTIFIER      reduce using rule 3 (enter_loop_scope -> empty .)
    INSTANCE_VARIABLE reduce using rule 3 (enter_loop_scope -> empty .)
    CLASS_VARIABLE  reduce using rule 3 (enter_loop_scope -> empty .)
    GLOBAL_VARIABLE reduce using rule 3 (enter_loop_scope -> empty .)
    CONSTANT        reduce using rule 3 (enter_loop_scope -> empty .)
    PUTS            reduce using rule 3 (enter_loop_scope -> empty .)
    FOR             reduce using rule 3 (enter_loop_scope -> empty .)
    IF              reduce using rule 3 (enter_loop_scope -> empty .)
    WHILE           reduce using rule 3 (enter_loop_scope -> empty .)
    DEF             reduce using rule 3 (enter_loop_scope -> empty .)
    RETURN          reduce using rule 3 (enter_loop_scope -> empty .)
    CLASS           reduce using rule 3 (enter_loop_scope -> empty .)
    END             reduce using rule 3 (enter_loop_scope -> empty .)


state 131

    (60) function_definition -> DEF func_name_hook func_header . statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    statements                     shift and go to state 178
    empty                          shift and go to state 3

state 132

    (62) func_header -> LPAREN . param_list RPAREN
    (63) func_header -> LPAREN . RPAREN
    (58) param_list -> . IDENTIFIER COMMA param_list
    (59) param_list -> . IDENTIFIER

    RPAREN          shift and go to state 180
    IDENTIFIER      shift and go to state 181

    param_list                     shift and go to state 179

state 133

    (64) func_header -> empty .

    SEMICOLON       reduce using rule 64 (func_header -> empty .)
    BREAK           reduce using rule 64 (func_header -> empty .)
    NEXT            reduce using rule 64 (func_header -> empty .)
    IDENTIFIER      reduce using rule 64 (func_header -> empty .)
    INSTANCE_VARIABLE reduce using rule 64 (func_header -> empty .)
    CLASS_VARIABLE  reduce using rule 64 (func_header -> empty .)
    GLOBAL_VARIABLE reduce using rule 64 (func_header -> empty .)
    CONSTANT        reduce using rule 64 (func_header -> empty .)
    PUTS            reduce using rule 64 (func_header -> empty .)
    FOR             reduce using rule 64 (func_header -> empty .)
    IF              reduce using rule 64 (func_header -> empty .)
    WHILE           reduce using rule 64 (func_header -> empty .)
    DEF             reduce using rule 64 (func_header -> empty .)
    RETURN          reduce using rule 64 (func_header -> empty .)
    CLASS           reduce using rule 64 (func_header -> empty .)
    END             reduce using rule 64 (func_header -> empty .)


state 134

    (56) class_definition -> CLASS CONSTANT enter_scope . statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    statements                     shift and go to state 182
    empty                          shift and go to state 3

state 135

    (57) class_definition -> CLASS CONSTANT LESS . CONSTANT enter_scope statements exit_scope END

    CONSTANT        shift and go to state 183


state 136

    (76) io_statement -> IDENTIFIER ASSIGN GETS DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 184


state 137

    (47) array_access -> IDENTIFIER LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    MODULE_OP       reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    POWER           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    EQUAL           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    NOT_EQUAL       reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER         reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS            reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_EQUAL   reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_EQUAL      reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    SPACESHIP       reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    CASE_EQUAL      reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    BREAK           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    NEXT            reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    IDENTIFIER      reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    INSTANCE_VARIABLE reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    CLASS_VARIABLE  reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    GLOBAL_VARIABLE reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    CONSTANT        reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    PUTS            reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    FOR             reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    IF              reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    WHILE           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    DEF             reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RETURN          reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    CLASS           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    $end            reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LOGICAL_AND     reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    AND             reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    LOGICAL_OR      reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    OR              reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    END             reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    ELSIF           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    HASH_ROCKET     reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 47 (array_access -> IDENTIFIER LBRACKET expression RBRACKET .)


state 138

    (31) expression -> expression RANGE_EXCLUSIVE expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for FOR resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for IF resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for DEF resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for $end resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for AND resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for OR resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for END resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    SEMICOLON       reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    BREAK           reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    NEXT            reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    IDENTIFIER      reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    INSTANCE_VARIABLE reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    CLASS_VARIABLE  reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    GLOBAL_VARIABLE reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    CONSTANT        reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    PUTS            reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    FOR             reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    IF              reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    WHILE           reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    DEF             reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    RETURN          reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    CLASS           reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    $end            reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    LOGICAL_AND     reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    AND             reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    LOGICAL_OR      reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    OR              reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    END             reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    ELSIF           reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    ELSE            reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    RBRACKET        reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    COMMA           reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    RPAREN          reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    HASH_ROCKET     reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    RBRACE          reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102

  ! RANGE_EXCLUSIVE [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! PLUS            [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! MINUS           [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! TIMES           [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! DIVIDE          [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! MODULE_OP       [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! POWER           [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! EQUAL           [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! GREATER         [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! LESS            [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! SPACESHIP       [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! CASE_EQUAL      [ reduce using rule 31 (expression -> expression RANGE_EXCLUSIVE expression .) ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 139

    (32) expression -> expression RANGE_INCLUSIVE expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for FOR resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for IF resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for DEF resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for $end resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for END resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    SEMICOLON       reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    BREAK           reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    NEXT            reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    IDENTIFIER      reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    INSTANCE_VARIABLE reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    CLASS_VARIABLE  reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    GLOBAL_VARIABLE reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    CONSTANT        reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    PUTS            reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    FOR             reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    IF              reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    WHILE           reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    DEF             reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    RETURN          reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    CLASS           reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    $end            reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    LOGICAL_AND     reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    AND             reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    LOGICAL_OR      reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    OR              reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    END             reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    ELSIF           reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    ELSE            reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACKET        reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    COMMA           reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    RPAREN          reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    HASH_ROCKET     reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACE          reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102

  ! RANGE_EXCLUSIVE [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! PLUS            [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MINUS           [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! TIMES           [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MODULE_OP       [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! POWER           [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! EQUAL           [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! NOT_EQUAL       [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! GREATER         [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! LESS            [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! LESS_EQUAL      [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! SPACESHIP       [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! CASE_EQUAL      [ reduce using rule 32 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 140

    (48) expression -> expression PLUS expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (expression -> expression PLUS expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for LESS resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for IF resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for $end resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for AND resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for OR resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for END resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 48 (expression -> expression PLUS expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 48 (expression -> expression PLUS expression .)
    RANGE_EXCLUSIVE reduce using rule 48 (expression -> expression PLUS expression .)
    RANGE_INCLUSIVE reduce using rule 48 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 48 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 48 (expression -> expression PLUS expression .)
    EQUAL           reduce using rule 48 (expression -> expression PLUS expression .)
    NOT_EQUAL       reduce using rule 48 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 48 (expression -> expression PLUS expression .)
    LESS            reduce using rule 48 (expression -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 48 (expression -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 48 (expression -> expression PLUS expression .)
    SPACESHIP       reduce using rule 48 (expression -> expression PLUS expression .)
    CASE_EQUAL      reduce using rule 48 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 48 (expression -> expression PLUS expression .)
    BREAK           reduce using rule 48 (expression -> expression PLUS expression .)
    NEXT            reduce using rule 48 (expression -> expression PLUS expression .)
    IDENTIFIER      reduce using rule 48 (expression -> expression PLUS expression .)
    INSTANCE_VARIABLE reduce using rule 48 (expression -> expression PLUS expression .)
    CLASS_VARIABLE  reduce using rule 48 (expression -> expression PLUS expression .)
    GLOBAL_VARIABLE reduce using rule 48 (expression -> expression PLUS expression .)
    CONSTANT        reduce using rule 48 (expression -> expression PLUS expression .)
    PUTS            reduce using rule 48 (expression -> expression PLUS expression .)
    FOR             reduce using rule 48 (expression -> expression PLUS expression .)
    IF              reduce using rule 48 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 48 (expression -> expression PLUS expression .)
    DEF             reduce using rule 48 (expression -> expression PLUS expression .)
    RETURN          reduce using rule 48 (expression -> expression PLUS expression .)
    CLASS           reduce using rule 48 (expression -> expression PLUS expression .)
    $end            reduce using rule 48 (expression -> expression PLUS expression .)
    LOGICAL_AND     reduce using rule 48 (expression -> expression PLUS expression .)
    AND             reduce using rule 48 (expression -> expression PLUS expression .)
    LOGICAL_OR      reduce using rule 48 (expression -> expression PLUS expression .)
    OR              reduce using rule 48 (expression -> expression PLUS expression .)
    END             reduce using rule 48 (expression -> expression PLUS expression .)
    ELSIF           reduce using rule 48 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 48 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 48 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 48 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 48 (expression -> expression PLUS expression .)
    HASH_ROCKET     reduce using rule 48 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 48 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94

  ! TIMES           [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! MODULE_OP       [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! POWER           [ reduce using rule 48 (expression -> expression PLUS expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! PLUS            [ shift and go to state 89 ]
  ! MINUS           [ shift and go to state 90 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 141

    (49) expression -> expression MINUS expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 49 (expression -> expression MINUS expression .)
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for LESS resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for FOR resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for IF resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for DEF resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for $end resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for AND resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for OR resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for END resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 49 (expression -> expression MINUS expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 49 (expression -> expression MINUS expression .)
    RANGE_EXCLUSIVE reduce using rule 49 (expression -> expression MINUS expression .)
    RANGE_INCLUSIVE reduce using rule 49 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 49 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 49 (expression -> expression MINUS expression .)
    EQUAL           reduce using rule 49 (expression -> expression MINUS expression .)
    NOT_EQUAL       reduce using rule 49 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 49 (expression -> expression MINUS expression .)
    LESS            reduce using rule 49 (expression -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 49 (expression -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 49 (expression -> expression MINUS expression .)
    SPACESHIP       reduce using rule 49 (expression -> expression MINUS expression .)
    CASE_EQUAL      reduce using rule 49 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 49 (expression -> expression MINUS expression .)
    BREAK           reduce using rule 49 (expression -> expression MINUS expression .)
    NEXT            reduce using rule 49 (expression -> expression MINUS expression .)
    IDENTIFIER      reduce using rule 49 (expression -> expression MINUS expression .)
    INSTANCE_VARIABLE reduce using rule 49 (expression -> expression MINUS expression .)
    CLASS_VARIABLE  reduce using rule 49 (expression -> expression MINUS expression .)
    GLOBAL_VARIABLE reduce using rule 49 (expression -> expression MINUS expression .)
    CONSTANT        reduce using rule 49 (expression -> expression MINUS expression .)
    PUTS            reduce using rule 49 (expression -> expression MINUS expression .)
    FOR             reduce using rule 49 (expression -> expression MINUS expression .)
    IF              reduce using rule 49 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 49 (expression -> expression MINUS expression .)
    DEF             reduce using rule 49 (expression -> expression MINUS expression .)
    RETURN          reduce using rule 49 (expression -> expression MINUS expression .)
    CLASS           reduce using rule 49 (expression -> expression MINUS expression .)
    $end            reduce using rule 49 (expression -> expression MINUS expression .)
    LOGICAL_AND     reduce using rule 49 (expression -> expression MINUS expression .)
    AND             reduce using rule 49 (expression -> expression MINUS expression .)
    LOGICAL_OR      reduce using rule 49 (expression -> expression MINUS expression .)
    OR              reduce using rule 49 (expression -> expression MINUS expression .)
    END             reduce using rule 49 (expression -> expression MINUS expression .)
    ELSIF           reduce using rule 49 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 49 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 49 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 49 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 49 (expression -> expression MINUS expression .)
    HASH_ROCKET     reduce using rule 49 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 49 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94

  ! TIMES           [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! MODULE_OP       [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! POWER           [ reduce using rule 49 (expression -> expression MINUS expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! PLUS            [ shift and go to state 89 ]
  ! MINUS           [ shift and go to state 90 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 142

    (50) expression -> expression TIMES expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 50 (expression -> expression TIMES expression .)
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for LESS resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for FOR resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for IF resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for DEF resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for $end resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for AND resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for OR resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for END resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 50 (expression -> expression TIMES expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 50 (expression -> expression TIMES expression .)
    RANGE_EXCLUSIVE reduce using rule 50 (expression -> expression TIMES expression .)
    RANGE_INCLUSIVE reduce using rule 50 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 50 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 50 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 50 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 50 (expression -> expression TIMES expression .)
    MODULE_OP       reduce using rule 50 (expression -> expression TIMES expression .)
    EQUAL           reduce using rule 50 (expression -> expression TIMES expression .)
    NOT_EQUAL       reduce using rule 50 (expression -> expression TIMES expression .)
    GREATER         reduce using rule 50 (expression -> expression TIMES expression .)
    LESS            reduce using rule 50 (expression -> expression TIMES expression .)
    GREATER_EQUAL   reduce using rule 50 (expression -> expression TIMES expression .)
    LESS_EQUAL      reduce using rule 50 (expression -> expression TIMES expression .)
    SPACESHIP       reduce using rule 50 (expression -> expression TIMES expression .)
    CASE_EQUAL      reduce using rule 50 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 50 (expression -> expression TIMES expression .)
    BREAK           reduce using rule 50 (expression -> expression TIMES expression .)
    NEXT            reduce using rule 50 (expression -> expression TIMES expression .)
    IDENTIFIER      reduce using rule 50 (expression -> expression TIMES expression .)
    INSTANCE_VARIABLE reduce using rule 50 (expression -> expression TIMES expression .)
    CLASS_VARIABLE  reduce using rule 50 (expression -> expression TIMES expression .)
    GLOBAL_VARIABLE reduce using rule 50 (expression -> expression TIMES expression .)
    CONSTANT        reduce using rule 50 (expression -> expression TIMES expression .)
    PUTS            reduce using rule 50 (expression -> expression TIMES expression .)
    FOR             reduce using rule 50 (expression -> expression TIMES expression .)
    IF              reduce using rule 50 (expression -> expression TIMES expression .)
    WHILE           reduce using rule 50 (expression -> expression TIMES expression .)
    DEF             reduce using rule 50 (expression -> expression TIMES expression .)
    RETURN          reduce using rule 50 (expression -> expression TIMES expression .)
    CLASS           reduce using rule 50 (expression -> expression TIMES expression .)
    $end            reduce using rule 50 (expression -> expression TIMES expression .)
    LOGICAL_AND     reduce using rule 50 (expression -> expression TIMES expression .)
    AND             reduce using rule 50 (expression -> expression TIMES expression .)
    LOGICAL_OR      reduce using rule 50 (expression -> expression TIMES expression .)
    OR              reduce using rule 50 (expression -> expression TIMES expression .)
    END             reduce using rule 50 (expression -> expression TIMES expression .)
    ELSIF           reduce using rule 50 (expression -> expression TIMES expression .)
    ELSE            reduce using rule 50 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 50 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 50 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 50 (expression -> expression TIMES expression .)
    HASH_ROCKET     reduce using rule 50 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 50 (expression -> expression TIMES expression .)
    POWER           shift and go to state 94

  ! POWER           [ reduce using rule 50 (expression -> expression TIMES expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! PLUS            [ shift and go to state 89 ]
  ! MINUS           [ shift and go to state 90 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 92 ]
  ! MODULE_OP       [ shift and go to state 93 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 143

    (51) expression -> expression DIVIDE expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for LESS resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for FOR resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for IF resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for DEF resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for $end resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for AND resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for OR resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for END resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 51 (expression -> expression DIVIDE expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 51 (expression -> expression DIVIDE expression .)
    RANGE_EXCLUSIVE reduce using rule 51 (expression -> expression DIVIDE expression .)
    RANGE_INCLUSIVE reduce using rule 51 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 51 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 51 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 51 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 51 (expression -> expression DIVIDE expression .)
    MODULE_OP       reduce using rule 51 (expression -> expression DIVIDE expression .)
    EQUAL           reduce using rule 51 (expression -> expression DIVIDE expression .)
    NOT_EQUAL       reduce using rule 51 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 51 (expression -> expression DIVIDE expression .)
    LESS            reduce using rule 51 (expression -> expression DIVIDE expression .)
    GREATER_EQUAL   reduce using rule 51 (expression -> expression DIVIDE expression .)
    LESS_EQUAL      reduce using rule 51 (expression -> expression DIVIDE expression .)
    SPACESHIP       reduce using rule 51 (expression -> expression DIVIDE expression .)
    CASE_EQUAL      reduce using rule 51 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 51 (expression -> expression DIVIDE expression .)
    BREAK           reduce using rule 51 (expression -> expression DIVIDE expression .)
    NEXT            reduce using rule 51 (expression -> expression DIVIDE expression .)
    IDENTIFIER      reduce using rule 51 (expression -> expression DIVIDE expression .)
    INSTANCE_VARIABLE reduce using rule 51 (expression -> expression DIVIDE expression .)
    CLASS_VARIABLE  reduce using rule 51 (expression -> expression DIVIDE expression .)
    GLOBAL_VARIABLE reduce using rule 51 (expression -> expression DIVIDE expression .)
    CONSTANT        reduce using rule 51 (expression -> expression DIVIDE expression .)
    PUTS            reduce using rule 51 (expression -> expression DIVIDE expression .)
    FOR             reduce using rule 51 (expression -> expression DIVIDE expression .)
    IF              reduce using rule 51 (expression -> expression DIVIDE expression .)
    WHILE           reduce using rule 51 (expression -> expression DIVIDE expression .)
    DEF             reduce using rule 51 (expression -> expression DIVIDE expression .)
    RETURN          reduce using rule 51 (expression -> expression DIVIDE expression .)
    CLASS           reduce using rule 51 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 51 (expression -> expression DIVIDE expression .)
    LOGICAL_AND     reduce using rule 51 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 51 (expression -> expression DIVIDE expression .)
    LOGICAL_OR      reduce using rule 51 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 51 (expression -> expression DIVIDE expression .)
    END             reduce using rule 51 (expression -> expression DIVIDE expression .)
    ELSIF           reduce using rule 51 (expression -> expression DIVIDE expression .)
    ELSE            reduce using rule 51 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 51 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 51 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 51 (expression -> expression DIVIDE expression .)
    HASH_ROCKET     reduce using rule 51 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 51 (expression -> expression DIVIDE expression .)
    POWER           shift and go to state 94

  ! POWER           [ reduce using rule 51 (expression -> expression DIVIDE expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! PLUS            [ shift and go to state 89 ]
  ! MINUS           [ shift and go to state 90 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 92 ]
  ! MODULE_OP       [ shift and go to state 93 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 144

    (52) expression -> expression MODULE_OP expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for LESS resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for FOR resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for IF resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for DEF resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for $end resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for AND resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for OR resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for END resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 52 (expression -> expression MODULE_OP expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 52 (expression -> expression MODULE_OP expression .)
    RANGE_EXCLUSIVE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RANGE_INCLUSIVE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    PLUS            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    MINUS           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    TIMES           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    DIVIDE          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    MODULE_OP       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    EQUAL           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    NOT_EQUAL       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    GREATER         reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LESS            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    GREATER_EQUAL   reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LESS_EQUAL      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    SPACESHIP       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CASE_EQUAL      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    SEMICOLON       reduce using rule 52 (expression -> expression MODULE_OP expression .)
    BREAK           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    NEXT            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    IDENTIFIER      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    INSTANCE_VARIABLE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CLASS_VARIABLE  reduce using rule 52 (expression -> expression MODULE_OP expression .)
    GLOBAL_VARIABLE reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CONSTANT        reduce using rule 52 (expression -> expression MODULE_OP expression .)
    PUTS            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    FOR             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    IF              reduce using rule 52 (expression -> expression MODULE_OP expression .)
    WHILE           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    DEF             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RETURN          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    CLASS           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    $end            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LOGICAL_AND     reduce using rule 52 (expression -> expression MODULE_OP expression .)
    AND             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    LOGICAL_OR      reduce using rule 52 (expression -> expression MODULE_OP expression .)
    OR              reduce using rule 52 (expression -> expression MODULE_OP expression .)
    END             reduce using rule 52 (expression -> expression MODULE_OP expression .)
    ELSIF           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    ELSE            reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RBRACKET        reduce using rule 52 (expression -> expression MODULE_OP expression .)
    COMMA           reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RPAREN          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    HASH_ROCKET     reduce using rule 52 (expression -> expression MODULE_OP expression .)
    RBRACE          reduce using rule 52 (expression -> expression MODULE_OP expression .)
    POWER           shift and go to state 94

  ! POWER           [ reduce using rule 52 (expression -> expression MODULE_OP expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! PLUS            [ shift and go to state 89 ]
  ! MINUS           [ shift and go to state 90 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 92 ]
  ! MODULE_OP       [ shift and go to state 93 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 145

    (53) expression -> expression POWER expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for PLUS resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for MINUS resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for TIMES resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 53 (expression -> expression POWER expression .)
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for EQUAL resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for GREATER resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for LESS resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for FOR resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for IF resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for DEF resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for $end resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for AND resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for OR resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for END resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 53 (expression -> expression POWER expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 53 (expression -> expression POWER expression .)
    RANGE_EXCLUSIVE reduce using rule 53 (expression -> expression POWER expression .)
    RANGE_INCLUSIVE reduce using rule 53 (expression -> expression POWER expression .)
    PLUS            reduce using rule 53 (expression -> expression POWER expression .)
    MINUS           reduce using rule 53 (expression -> expression POWER expression .)
    TIMES           reduce using rule 53 (expression -> expression POWER expression .)
    DIVIDE          reduce using rule 53 (expression -> expression POWER expression .)
    MODULE_OP       reduce using rule 53 (expression -> expression POWER expression .)
    EQUAL           reduce using rule 53 (expression -> expression POWER expression .)
    NOT_EQUAL       reduce using rule 53 (expression -> expression POWER expression .)
    GREATER         reduce using rule 53 (expression -> expression POWER expression .)
    LESS            reduce using rule 53 (expression -> expression POWER expression .)
    GREATER_EQUAL   reduce using rule 53 (expression -> expression POWER expression .)
    LESS_EQUAL      reduce using rule 53 (expression -> expression POWER expression .)
    SPACESHIP       reduce using rule 53 (expression -> expression POWER expression .)
    CASE_EQUAL      reduce using rule 53 (expression -> expression POWER expression .)
    SEMICOLON       reduce using rule 53 (expression -> expression POWER expression .)
    BREAK           reduce using rule 53 (expression -> expression POWER expression .)
    NEXT            reduce using rule 53 (expression -> expression POWER expression .)
    IDENTIFIER      reduce using rule 53 (expression -> expression POWER expression .)
    INSTANCE_VARIABLE reduce using rule 53 (expression -> expression POWER expression .)
    CLASS_VARIABLE  reduce using rule 53 (expression -> expression POWER expression .)
    GLOBAL_VARIABLE reduce using rule 53 (expression -> expression POWER expression .)
    CONSTANT        reduce using rule 53 (expression -> expression POWER expression .)
    PUTS            reduce using rule 53 (expression -> expression POWER expression .)
    FOR             reduce using rule 53 (expression -> expression POWER expression .)
    IF              reduce using rule 53 (expression -> expression POWER expression .)
    WHILE           reduce using rule 53 (expression -> expression POWER expression .)
    DEF             reduce using rule 53 (expression -> expression POWER expression .)
    RETURN          reduce using rule 53 (expression -> expression POWER expression .)
    CLASS           reduce using rule 53 (expression -> expression POWER expression .)
    $end            reduce using rule 53 (expression -> expression POWER expression .)
    LOGICAL_AND     reduce using rule 53 (expression -> expression POWER expression .)
    AND             reduce using rule 53 (expression -> expression POWER expression .)
    LOGICAL_OR      reduce using rule 53 (expression -> expression POWER expression .)
    OR              reduce using rule 53 (expression -> expression POWER expression .)
    END             reduce using rule 53 (expression -> expression POWER expression .)
    ELSIF           reduce using rule 53 (expression -> expression POWER expression .)
    ELSE            reduce using rule 53 (expression -> expression POWER expression .)
    RBRACKET        reduce using rule 53 (expression -> expression POWER expression .)
    COMMA           reduce using rule 53 (expression -> expression POWER expression .)
    RPAREN          reduce using rule 53 (expression -> expression POWER expression .)
    HASH_ROCKET     reduce using rule 53 (expression -> expression POWER expression .)
    RBRACE          reduce using rule 53 (expression -> expression POWER expression .)
    POWER           shift and go to state 94

  ! POWER           [ reduce using rule 53 (expression -> expression POWER expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! PLUS            [ shift and go to state 89 ]
  ! MINUS           [ shift and go to state 90 ]
  ! TIMES           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 92 ]
  ! MODULE_OP       [ shift and go to state 93 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 146

    (78) condition -> expression EQUAL expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 78 (condition -> expression EQUAL expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for FOR resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for IF resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for DEF resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for $end resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for AND resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for OR resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for END resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 78 (condition -> expression EQUAL expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 78 (condition -> expression EQUAL expression .)
    RANGE_EXCLUSIVE reduce using rule 78 (condition -> expression EQUAL expression .)
    RANGE_INCLUSIVE reduce using rule 78 (condition -> expression EQUAL expression .)
    SEMICOLON       reduce using rule 78 (condition -> expression EQUAL expression .)
    BREAK           reduce using rule 78 (condition -> expression EQUAL expression .)
    NEXT            reduce using rule 78 (condition -> expression EQUAL expression .)
    IDENTIFIER      reduce using rule 78 (condition -> expression EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 78 (condition -> expression EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 78 (condition -> expression EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 78 (condition -> expression EQUAL expression .)
    CONSTANT        reduce using rule 78 (condition -> expression EQUAL expression .)
    PUTS            reduce using rule 78 (condition -> expression EQUAL expression .)
    FOR             reduce using rule 78 (condition -> expression EQUAL expression .)
    IF              reduce using rule 78 (condition -> expression EQUAL expression .)
    WHILE           reduce using rule 78 (condition -> expression EQUAL expression .)
    DEF             reduce using rule 78 (condition -> expression EQUAL expression .)
    RETURN          reduce using rule 78 (condition -> expression EQUAL expression .)
    CLASS           reduce using rule 78 (condition -> expression EQUAL expression .)
    $end            reduce using rule 78 (condition -> expression EQUAL expression .)
    LOGICAL_AND     reduce using rule 78 (condition -> expression EQUAL expression .)
    AND             reduce using rule 78 (condition -> expression EQUAL expression .)
    LOGICAL_OR      reduce using rule 78 (condition -> expression EQUAL expression .)
    OR              reduce using rule 78 (condition -> expression EQUAL expression .)
    END             reduce using rule 78 (condition -> expression EQUAL expression .)
    ELSIF           reduce using rule 78 (condition -> expression EQUAL expression .)
    ELSE            reduce using rule 78 (condition -> expression EQUAL expression .)
    RBRACKET        reduce using rule 78 (condition -> expression EQUAL expression .)
    COMMA           reduce using rule 78 (condition -> expression EQUAL expression .)
    RPAREN          reduce using rule 78 (condition -> expression EQUAL expression .)
    HASH_ROCKET     reduce using rule 78 (condition -> expression EQUAL expression .)
    RBRACE          reduce using rule 78 (condition -> expression EQUAL expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! MINUS           [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! TIMES           [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! MODULE_OP       [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! POWER           [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! EQUAL           [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! GREATER         [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! LESS            [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! SPACESHIP       [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! CASE_EQUAL      [ reduce using rule 78 (condition -> expression EQUAL expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 147

    (79) condition -> expression NOT_EQUAL expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for FOR resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for IF resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for DEF resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for $end resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for AND resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for OR resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for END resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 79 (condition -> expression NOT_EQUAL expression .)
    RANGE_EXCLUSIVE reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    RANGE_INCLUSIVE reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    SEMICOLON       reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    BREAK           reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    NEXT            reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    IDENTIFIER      reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    CONSTANT        reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    PUTS            reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    FOR             reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    IF              reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    WHILE           reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    DEF             reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    RETURN          reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    CLASS           reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    $end            reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    LOGICAL_AND     reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    AND             reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    LOGICAL_OR      reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    OR              reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    END             reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    ELSIF           reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    ELSE            reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    RBRACKET        reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    COMMA           reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    RPAREN          reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    HASH_ROCKET     reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    RBRACE          reduce using rule 79 (condition -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! MODULE_OP       [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! POWER           [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! EQUAL           [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! LESS            [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! SPACESHIP       [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! CASE_EQUAL      [ reduce using rule 79 (condition -> expression NOT_EQUAL expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 148

    (80) condition -> expression GREATER expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 80 (condition -> expression GREATER expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for FOR resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for IF resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for DEF resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for $end resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for AND resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for OR resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for END resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 80 (condition -> expression GREATER expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 80 (condition -> expression GREATER expression .)
    RANGE_EXCLUSIVE reduce using rule 80 (condition -> expression GREATER expression .)
    RANGE_INCLUSIVE reduce using rule 80 (condition -> expression GREATER expression .)
    SEMICOLON       reduce using rule 80 (condition -> expression GREATER expression .)
    BREAK           reduce using rule 80 (condition -> expression GREATER expression .)
    NEXT            reduce using rule 80 (condition -> expression GREATER expression .)
    IDENTIFIER      reduce using rule 80 (condition -> expression GREATER expression .)
    INSTANCE_VARIABLE reduce using rule 80 (condition -> expression GREATER expression .)
    CLASS_VARIABLE  reduce using rule 80 (condition -> expression GREATER expression .)
    GLOBAL_VARIABLE reduce using rule 80 (condition -> expression GREATER expression .)
    CONSTANT        reduce using rule 80 (condition -> expression GREATER expression .)
    PUTS            reduce using rule 80 (condition -> expression GREATER expression .)
    FOR             reduce using rule 80 (condition -> expression GREATER expression .)
    IF              reduce using rule 80 (condition -> expression GREATER expression .)
    WHILE           reduce using rule 80 (condition -> expression GREATER expression .)
    DEF             reduce using rule 80 (condition -> expression GREATER expression .)
    RETURN          reduce using rule 80 (condition -> expression GREATER expression .)
    CLASS           reduce using rule 80 (condition -> expression GREATER expression .)
    $end            reduce using rule 80 (condition -> expression GREATER expression .)
    LOGICAL_AND     reduce using rule 80 (condition -> expression GREATER expression .)
    AND             reduce using rule 80 (condition -> expression GREATER expression .)
    LOGICAL_OR      reduce using rule 80 (condition -> expression GREATER expression .)
    OR              reduce using rule 80 (condition -> expression GREATER expression .)
    END             reduce using rule 80 (condition -> expression GREATER expression .)
    ELSIF           reduce using rule 80 (condition -> expression GREATER expression .)
    ELSE            reduce using rule 80 (condition -> expression GREATER expression .)
    RBRACKET        reduce using rule 80 (condition -> expression GREATER expression .)
    COMMA           reduce using rule 80 (condition -> expression GREATER expression .)
    RPAREN          reduce using rule 80 (condition -> expression GREATER expression .)
    HASH_ROCKET     reduce using rule 80 (condition -> expression GREATER expression .)
    RBRACE          reduce using rule 80 (condition -> expression GREATER expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! MINUS           [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! TIMES           [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! DIVIDE          [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! MODULE_OP       [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! POWER           [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! EQUAL           [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! NOT_EQUAL       [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! GREATER         [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! LESS            [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! LESS_EQUAL      [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! SPACESHIP       [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! CASE_EQUAL      [ reduce using rule 80 (condition -> expression GREATER expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 149

    (81) condition -> expression LESS expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 81 (condition -> expression LESS expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for FOR resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for IF resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for DEF resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for $end resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for AND resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for OR resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for END resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 81 (condition -> expression LESS expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 81 (condition -> expression LESS expression .)
    RANGE_EXCLUSIVE reduce using rule 81 (condition -> expression LESS expression .)
    RANGE_INCLUSIVE reduce using rule 81 (condition -> expression LESS expression .)
    SEMICOLON       reduce using rule 81 (condition -> expression LESS expression .)
    BREAK           reduce using rule 81 (condition -> expression LESS expression .)
    NEXT            reduce using rule 81 (condition -> expression LESS expression .)
    IDENTIFIER      reduce using rule 81 (condition -> expression LESS expression .)
    INSTANCE_VARIABLE reduce using rule 81 (condition -> expression LESS expression .)
    CLASS_VARIABLE  reduce using rule 81 (condition -> expression LESS expression .)
    GLOBAL_VARIABLE reduce using rule 81 (condition -> expression LESS expression .)
    CONSTANT        reduce using rule 81 (condition -> expression LESS expression .)
    PUTS            reduce using rule 81 (condition -> expression LESS expression .)
    FOR             reduce using rule 81 (condition -> expression LESS expression .)
    IF              reduce using rule 81 (condition -> expression LESS expression .)
    WHILE           reduce using rule 81 (condition -> expression LESS expression .)
    DEF             reduce using rule 81 (condition -> expression LESS expression .)
    RETURN          reduce using rule 81 (condition -> expression LESS expression .)
    CLASS           reduce using rule 81 (condition -> expression LESS expression .)
    $end            reduce using rule 81 (condition -> expression LESS expression .)
    LOGICAL_AND     reduce using rule 81 (condition -> expression LESS expression .)
    AND             reduce using rule 81 (condition -> expression LESS expression .)
    LOGICAL_OR      reduce using rule 81 (condition -> expression LESS expression .)
    OR              reduce using rule 81 (condition -> expression LESS expression .)
    END             reduce using rule 81 (condition -> expression LESS expression .)
    ELSIF           reduce using rule 81 (condition -> expression LESS expression .)
    ELSE            reduce using rule 81 (condition -> expression LESS expression .)
    RBRACKET        reduce using rule 81 (condition -> expression LESS expression .)
    COMMA           reduce using rule 81 (condition -> expression LESS expression .)
    RPAREN          reduce using rule 81 (condition -> expression LESS expression .)
    HASH_ROCKET     reduce using rule 81 (condition -> expression LESS expression .)
    RBRACE          reduce using rule 81 (condition -> expression LESS expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! MINUS           [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! TIMES           [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! DIVIDE          [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! MODULE_OP       [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! POWER           [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! EQUAL           [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! NOT_EQUAL       [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! GREATER         [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! LESS            [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! LESS_EQUAL      [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! SPACESHIP       [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! CASE_EQUAL      [ reduce using rule 81 (condition -> expression LESS expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 150

    (82) condition -> expression GREATER_EQUAL expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for FOR resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for IF resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for DEF resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for $end resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for AND resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for OR resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for END resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 82 (condition -> expression GREATER_EQUAL expression .)
    RANGE_EXCLUSIVE reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    RANGE_INCLUSIVE reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    SEMICOLON       reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    BREAK           reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    NEXT            reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    IDENTIFIER      reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    CONSTANT        reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    PUTS            reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    FOR             reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    IF              reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    WHILE           reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    DEF             reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    RETURN          reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    CLASS           reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    $end            reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    LOGICAL_AND     reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    AND             reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    LOGICAL_OR      reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    OR              reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    END             reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    ELSIF           reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    ELSE            reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    RBRACKET        reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    COMMA           reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    RPAREN          reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    HASH_ROCKET     reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    RBRACE          reduce using rule 82 (condition -> expression GREATER_EQUAL expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! MODULE_OP       [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! POWER           [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! EQUAL           [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! LESS            [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! SPACESHIP       [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! CASE_EQUAL      [ reduce using rule 82 (condition -> expression GREATER_EQUAL expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 151

    (83) condition -> expression LESS_EQUAL expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for FOR resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for IF resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for DEF resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for $end resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for AND resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for OR resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for END resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 83 (condition -> expression LESS_EQUAL expression .)
    RANGE_EXCLUSIVE reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    RANGE_INCLUSIVE reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    SEMICOLON       reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    BREAK           reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    NEXT            reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    IDENTIFIER      reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    CONSTANT        reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    PUTS            reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    FOR             reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    IF              reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    WHILE           reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    DEF             reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    RETURN          reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    CLASS           reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    $end            reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    LOGICAL_AND     reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    AND             reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    LOGICAL_OR      reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    OR              reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    END             reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    ELSIF           reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    ELSE            reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    RBRACKET        reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    COMMA           reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    RPAREN          reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    HASH_ROCKET     reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    RBRACE          reduce using rule 83 (condition -> expression LESS_EQUAL expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! MODULE_OP       [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! POWER           [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! EQUAL           [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! LESS            [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! SPACESHIP       [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! CASE_EQUAL      [ reduce using rule 83 (condition -> expression LESS_EQUAL expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 152

    (84) condition -> expression SPACESHIP expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for FOR resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for IF resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for DEF resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for $end resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for AND resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for OR resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for END resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 84 (condition -> expression SPACESHIP expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 84 (condition -> expression SPACESHIP expression .)
    RANGE_EXCLUSIVE reduce using rule 84 (condition -> expression SPACESHIP expression .)
    RANGE_INCLUSIVE reduce using rule 84 (condition -> expression SPACESHIP expression .)
    SEMICOLON       reduce using rule 84 (condition -> expression SPACESHIP expression .)
    BREAK           reduce using rule 84 (condition -> expression SPACESHIP expression .)
    NEXT            reduce using rule 84 (condition -> expression SPACESHIP expression .)
    IDENTIFIER      reduce using rule 84 (condition -> expression SPACESHIP expression .)
    INSTANCE_VARIABLE reduce using rule 84 (condition -> expression SPACESHIP expression .)
    CLASS_VARIABLE  reduce using rule 84 (condition -> expression SPACESHIP expression .)
    GLOBAL_VARIABLE reduce using rule 84 (condition -> expression SPACESHIP expression .)
    CONSTANT        reduce using rule 84 (condition -> expression SPACESHIP expression .)
    PUTS            reduce using rule 84 (condition -> expression SPACESHIP expression .)
    FOR             reduce using rule 84 (condition -> expression SPACESHIP expression .)
    IF              reduce using rule 84 (condition -> expression SPACESHIP expression .)
    WHILE           reduce using rule 84 (condition -> expression SPACESHIP expression .)
    DEF             reduce using rule 84 (condition -> expression SPACESHIP expression .)
    RETURN          reduce using rule 84 (condition -> expression SPACESHIP expression .)
    CLASS           reduce using rule 84 (condition -> expression SPACESHIP expression .)
    $end            reduce using rule 84 (condition -> expression SPACESHIP expression .)
    LOGICAL_AND     reduce using rule 84 (condition -> expression SPACESHIP expression .)
    AND             reduce using rule 84 (condition -> expression SPACESHIP expression .)
    LOGICAL_OR      reduce using rule 84 (condition -> expression SPACESHIP expression .)
    OR              reduce using rule 84 (condition -> expression SPACESHIP expression .)
    END             reduce using rule 84 (condition -> expression SPACESHIP expression .)
    ELSIF           reduce using rule 84 (condition -> expression SPACESHIP expression .)
    ELSE            reduce using rule 84 (condition -> expression SPACESHIP expression .)
    RBRACKET        reduce using rule 84 (condition -> expression SPACESHIP expression .)
    COMMA           reduce using rule 84 (condition -> expression SPACESHIP expression .)
    RPAREN          reduce using rule 84 (condition -> expression SPACESHIP expression .)
    HASH_ROCKET     reduce using rule 84 (condition -> expression SPACESHIP expression .)
    RBRACE          reduce using rule 84 (condition -> expression SPACESHIP expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! MINUS           [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! TIMES           [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! DIVIDE          [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! MODULE_OP       [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! POWER           [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! EQUAL           [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! NOT_EQUAL       [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! GREATER         [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! LESS            [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! LESS_EQUAL      [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! SPACESHIP       [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! CASE_EQUAL      [ reduce using rule 84 (condition -> expression SPACESHIP expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 153

    (85) condition -> expression CASE_EQUAL expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! reduce/reduce conflict for COMMA resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for FOR resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for IF resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for DEF resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for $end resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for AND resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for OR resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for END resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 85 (condition -> expression CASE_EQUAL expression .)
    RANGE_EXCLUSIVE reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    RANGE_INCLUSIVE reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    SEMICOLON       reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    BREAK           reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    NEXT            reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    IDENTIFIER      reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    INSTANCE_VARIABLE reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    CLASS_VARIABLE  reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    GLOBAL_VARIABLE reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    CONSTANT        reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    PUTS            reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    FOR             reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    IF              reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    WHILE           reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    DEF             reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    RETURN          reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    CLASS           reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    $end            reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    LOGICAL_AND     reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    AND             reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    LOGICAL_OR      reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    OR              reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    END             reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    ELSIF           reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    ELSE            reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    RBRACKET        reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    COMMA           reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    RPAREN          reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    HASH_ROCKET     reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    RBRACE          reduce using rule 85 (condition -> expression CASE_EQUAL expression .)
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           reduce using rule 92 (condition -> expression .)
    NOT_EQUAL       reduce using rule 92 (condition -> expression .)
    GREATER         reduce using rule 92 (condition -> expression .)
    LESS            reduce using rule 92 (condition -> expression .)
    GREATER_EQUAL   reduce using rule 92 (condition -> expression .)
    LESS_EQUAL      reduce using rule 92 (condition -> expression .)
    SPACESHIP       reduce using rule 92 (condition -> expression .)
    CASE_EQUAL      reduce using rule 92 (condition -> expression .)

  ! PLUS            [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! MODULE_OP       [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! POWER           [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! EQUAL           [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! NOT_EQUAL       [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! LESS            [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! SPACESHIP       [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! CASE_EQUAL      [ reduce using rule 85 (condition -> expression CASE_EQUAL expression .) ]
  ! RANGE_EXCLUSIVE [ shift and go to state 87 ]
  ! RANGE_INCLUSIVE [ shift and go to state 88 ]
  ! EQUAL           [ shift and go to state 95 ]
  ! NOT_EQUAL       [ shift and go to state 96 ]
  ! GREATER         [ shift and go to state 97 ]
  ! LESS            [ shift and go to state 98 ]
  ! GREATER_EQUAL   [ shift and go to state 99 ]
  ! LESS_EQUAL      [ shift and go to state 100 ]
  ! SPACESHIP       [ shift and go to state 101 ]
  ! CASE_EQUAL      [ shift and go to state 102 ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! $end            [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_AND     [ reduce using rule 92 (condition -> expression .) ]
  ! AND             [ reduce using rule 92 (condition -> expression .) ]
  ! LOGICAL_OR      [ reduce using rule 92 (condition -> expression .) ]
  ! OR              [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]
  ! ELSIF           [ reduce using rule 92 (condition -> expression .) ]
  ! ELSE            [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! HASH_ROCKET     [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]


state 154

    (86) condition -> condition LOGICAL_AND condition .
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .

  ! reduce/reduce conflict for COMMA resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NEXT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PUTS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for WHILE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DEF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RETURN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for $end resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for AND resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for END resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSIF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACE resolved using rule 24 (expression -> condition .)
    COMMA           reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 24 (expression -> condition .)
    BREAK           reduce using rule 24 (expression -> condition .)
    NEXT            reduce using rule 24 (expression -> condition .)
    IDENTIFIER      reduce using rule 24 (expression -> condition .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> condition .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> condition .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> condition .)
    CONSTANT        reduce using rule 24 (expression -> condition .)
    PUTS            reduce using rule 24 (expression -> condition .)
    FOR             reduce using rule 24 (expression -> condition .)
    IF              reduce using rule 24 (expression -> condition .)
    WHILE           reduce using rule 24 (expression -> condition .)
    DEF             reduce using rule 24 (expression -> condition .)
    RETURN          reduce using rule 24 (expression -> condition .)
    CLASS           reduce using rule 24 (expression -> condition .)
    $end            reduce using rule 24 (expression -> condition .)
    LOGICAL_AND     reduce using rule 24 (expression -> condition .)
    AND             reduce using rule 24 (expression -> condition .)
    LOGICAL_OR      reduce using rule 24 (expression -> condition .)
    OR              reduce using rule 24 (expression -> condition .)
    END             reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 24 (expression -> condition .)
    ELSE            reduce using rule 24 (expression -> condition .)
    RBRACKET        reduce using rule 24 (expression -> condition .)
    RPAREN          reduce using rule 24 (expression -> condition .)
    HASH_ROCKET     reduce using rule 24 (expression -> condition .)
    RBRACE          reduce using rule 24 (expression -> condition .)

  ! RANGE_EXCLUSIVE [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! PLUS            [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! MINUS           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! TIMES           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! DIVIDE          [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! MODULE_OP       [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! POWER           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! EQUAL           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! NOT_EQUAL       [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! GREATER         [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! LESS            [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! LESS_EQUAL      [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! SPACESHIP       [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! CASE_EQUAL      [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! SEMICOLON       [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! BREAK           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! NEXT            [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! IDENTIFIER      [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! CONSTANT        [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! PUTS            [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! FOR             [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! IF              [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! WHILE           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! DEF             [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! RETURN          [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! CLASS           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! $end            [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! LOGICAL_AND     [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! AND             [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! LOGICAL_OR      [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! OR              [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! END             [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! ELSIF           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! ELSE            [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! RBRACKET        [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! COMMA           [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! RPAREN          [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! HASH_ROCKET     [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! RBRACE          [ reduce using rule 86 (condition -> condition LOGICAL_AND condition .) ]
  ! LOGICAL_AND     [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! LOGICAL_OR      [ shift and go to state 105 ]
  ! OR              [ shift and go to state 106 ]


state 155

    (87) condition -> condition AND condition .
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .

  ! reduce/reduce conflict for COMMA resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NEXT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PUTS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for WHILE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DEF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RETURN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for $end resolved using rule 24 (expression -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 24 (expression -> condition .)
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! reduce/reduce conflict for OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for END resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSIF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACE resolved using rule 24 (expression -> condition .)
    LOGICAL_AND     shift and go to state 103
    LOGICAL_OR      shift and go to state 105
    COMMA           reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 24 (expression -> condition .)
    BREAK           reduce using rule 24 (expression -> condition .)
    NEXT            reduce using rule 24 (expression -> condition .)
    IDENTIFIER      reduce using rule 24 (expression -> condition .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> condition .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> condition .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> condition .)
    CONSTANT        reduce using rule 24 (expression -> condition .)
    PUTS            reduce using rule 24 (expression -> condition .)
    FOR             reduce using rule 24 (expression -> condition .)
    IF              reduce using rule 24 (expression -> condition .)
    WHILE           reduce using rule 24 (expression -> condition .)
    DEF             reduce using rule 24 (expression -> condition .)
    RETURN          reduce using rule 24 (expression -> condition .)
    CLASS           reduce using rule 24 (expression -> condition .)
    $end            reduce using rule 24 (expression -> condition .)
    AND             reduce using rule 24 (expression -> condition .)
    OR              reduce using rule 24 (expression -> condition .)
    END             reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 24 (expression -> condition .)
    ELSE            reduce using rule 24 (expression -> condition .)
    RBRACKET        reduce using rule 24 (expression -> condition .)
    RPAREN          reduce using rule 24 (expression -> condition .)
    HASH_ROCKET     reduce using rule 24 (expression -> condition .)
    RBRACE          reduce using rule 24 (expression -> condition .)

  ! RANGE_EXCLUSIVE [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! PLUS            [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! MINUS           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! TIMES           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! DIVIDE          [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! MODULE_OP       [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! POWER           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! EQUAL           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! NOT_EQUAL       [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! GREATER         [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! LESS            [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! LESS_EQUAL      [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! SPACESHIP       [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! CASE_EQUAL      [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! SEMICOLON       [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! BREAK           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! NEXT            [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! IDENTIFIER      [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! CONSTANT        [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! PUTS            [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! FOR             [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! IF              [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! WHILE           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! DEF             [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! RETURN          [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! CLASS           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! $end            [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! LOGICAL_AND     [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! AND             [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! LOGICAL_OR      [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! OR              [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! END             [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! ELSIF           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! ELSE            [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! RBRACKET        [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! COMMA           [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! RPAREN          [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! HASH_ROCKET     [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! RBRACE          [ reduce using rule 87 (condition -> condition AND condition .) ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 106 ]
  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 24 (expression -> condition .) ]


state 156

    (88) condition -> condition LOGICAL_OR condition .
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .

  ! reduce/reduce conflict for COMMA resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NEXT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PUTS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for WHILE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DEF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RETURN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for $end resolved using rule 24 (expression -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for END resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSIF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACE resolved using rule 24 (expression -> condition .)
    LOGICAL_AND     shift and go to state 103
    COMMA           reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 24 (expression -> condition .)
    BREAK           reduce using rule 24 (expression -> condition .)
    NEXT            reduce using rule 24 (expression -> condition .)
    IDENTIFIER      reduce using rule 24 (expression -> condition .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> condition .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> condition .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> condition .)
    CONSTANT        reduce using rule 24 (expression -> condition .)
    PUTS            reduce using rule 24 (expression -> condition .)
    FOR             reduce using rule 24 (expression -> condition .)
    IF              reduce using rule 24 (expression -> condition .)
    WHILE           reduce using rule 24 (expression -> condition .)
    DEF             reduce using rule 24 (expression -> condition .)
    RETURN          reduce using rule 24 (expression -> condition .)
    CLASS           reduce using rule 24 (expression -> condition .)
    $end            reduce using rule 24 (expression -> condition .)
    AND             reduce using rule 24 (expression -> condition .)
    LOGICAL_OR      reduce using rule 24 (expression -> condition .)
    OR              reduce using rule 24 (expression -> condition .)
    END             reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 24 (expression -> condition .)
    ELSE            reduce using rule 24 (expression -> condition .)
    RBRACKET        reduce using rule 24 (expression -> condition .)
    RPAREN          reduce using rule 24 (expression -> condition .)
    HASH_ROCKET     reduce using rule 24 (expression -> condition .)
    RBRACE          reduce using rule 24 (expression -> condition .)

  ! RANGE_EXCLUSIVE [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! PLUS            [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! MINUS           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! TIMES           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! DIVIDE          [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! MODULE_OP       [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! POWER           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! EQUAL           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! NOT_EQUAL       [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! GREATER         [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! LESS            [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! LESS_EQUAL      [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! SPACESHIP       [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! CASE_EQUAL      [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! SEMICOLON       [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! BREAK           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! NEXT            [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! IDENTIFIER      [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! CONSTANT        [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! PUTS            [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! FOR             [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! IF              [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! WHILE           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! DEF             [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! RETURN          [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! CLASS           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! $end            [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! LOGICAL_AND     [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! AND             [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! LOGICAL_OR      [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! OR              [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! END             [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! ELSIF           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! ELSE            [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! RBRACKET        [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! COMMA           [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! RPAREN          [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! HASH_ROCKET     [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! RBRACE          [ reduce using rule 88 (condition -> condition LOGICAL_OR condition .) ]
  ! AND             [ shift and go to state 104 ]
  ! LOGICAL_OR      [ shift and go to state 105 ]
  ! OR              [ shift and go to state 106 ]
  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]


state 157

    (89) condition -> condition OR condition .
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .

  ! reduce/reduce conflict for COMMA resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for TIMES resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for MODULE_OP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for POWER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SPACESHIP resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CASE_EQUAL resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for NEXT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for PUTS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for IF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for WHILE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for DEF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RETURN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for CLASS resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for $end resolved using rule 24 (expression -> condition .)
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 24 (expression -> condition .)
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! reduce/reduce conflict for OR resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for END resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSIF resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for ELSE resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 24 (expression -> condition .)
  ! reduce/reduce conflict for RBRACE resolved using rule 24 (expression -> condition .)
    LOGICAL_AND     shift and go to state 103
    LOGICAL_OR      shift and go to state 105
    COMMA           reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    SEMICOLON       reduce using rule 24 (expression -> condition .)
    BREAK           reduce using rule 24 (expression -> condition .)
    NEXT            reduce using rule 24 (expression -> condition .)
    IDENTIFIER      reduce using rule 24 (expression -> condition .)
    INSTANCE_VARIABLE reduce using rule 24 (expression -> condition .)
    CLASS_VARIABLE  reduce using rule 24 (expression -> condition .)
    GLOBAL_VARIABLE reduce using rule 24 (expression -> condition .)
    CONSTANT        reduce using rule 24 (expression -> condition .)
    PUTS            reduce using rule 24 (expression -> condition .)
    FOR             reduce using rule 24 (expression -> condition .)
    IF              reduce using rule 24 (expression -> condition .)
    WHILE           reduce using rule 24 (expression -> condition .)
    DEF             reduce using rule 24 (expression -> condition .)
    RETURN          reduce using rule 24 (expression -> condition .)
    CLASS           reduce using rule 24 (expression -> condition .)
    $end            reduce using rule 24 (expression -> condition .)
    AND             reduce using rule 24 (expression -> condition .)
    OR              reduce using rule 24 (expression -> condition .)
    END             reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 24 (expression -> condition .)
    ELSE            reduce using rule 24 (expression -> condition .)
    RBRACKET        reduce using rule 24 (expression -> condition .)
    RPAREN          reduce using rule 24 (expression -> condition .)
    HASH_ROCKET     reduce using rule 24 (expression -> condition .)
    RBRACE          reduce using rule 24 (expression -> condition .)

  ! RANGE_EXCLUSIVE [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! PLUS            [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! MINUS           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! TIMES           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! DIVIDE          [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! MODULE_OP       [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! POWER           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! EQUAL           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! NOT_EQUAL       [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! GREATER         [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! LESS            [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! GREATER_EQUAL   [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! LESS_EQUAL      [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! SPACESHIP       [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! CASE_EQUAL      [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! SEMICOLON       [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! BREAK           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! NEXT            [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! IDENTIFIER      [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! CONSTANT        [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! PUTS            [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! FOR             [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! IF              [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! WHILE           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! DEF             [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! RETURN          [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! CLASS           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! $end            [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! LOGICAL_AND     [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! AND             [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! LOGICAL_OR      [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! OR              [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! END             [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! ELSIF           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! ELSE            [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! RBRACKET        [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! COMMA           [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! RPAREN          [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! HASH_ROCKET     [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! RBRACE          [ reduce using rule 89 (condition -> condition OR condition .) ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 106 ]
  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 24 (expression -> condition .) ]


state 158

    (33) expression -> IDENTIFIER DOT IDENTIFIER .
    (107) function_call -> IDENTIFIER . LPAREN arguments RPAREN
    (108) function_call -> IDENTIFIER . LPAREN RPAREN
    (109) function_call -> IDENTIFIER . arguments
    (110) arguments -> . arguments COMMA expression
    (111) arguments -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INSTANCE_VARIABLE resolved as shift
  ! shift/reduce conflict for CLASS_VARIABLE resolved as shift
  ! shift/reduce conflict for GLOBAL_VARIABLE resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RANGE_EXCLUSIVE reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    PLUS            reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    TIMES           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    DIVIDE          reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    MODULE_OP       reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    POWER           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    EQUAL           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    NOT_EQUAL       reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    GREATER         reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    LESS            reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    LESS_EQUAL      reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    SPACESHIP       reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    CASE_EQUAL      reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    BREAK           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    NEXT            reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    PUTS            reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    FOR             reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    IF              reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    WHILE           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    DEF             reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RETURN          reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    CLASS           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    $end            reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    LOGICAL_AND     reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    AND             reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    LOGICAL_OR      reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    OR              reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    END             reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    ELSIF           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    ELSE            reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RBRACKET        reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    COMMA           reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RPAREN          reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    HASH_ROCKET     reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RBRACE          reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .)
    LPAREN          shift and go to state 110
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

  ! MINUS           [ reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .) ]
  ! CLASS_VARIABLE  [ reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .) ]
  ! CONSTANT        [ reduce using rule 33 (expression -> IDENTIFIER DOT IDENTIFIER .) ]

    arguments                      shift and go to state 111
    expression                     shift and go to state 109
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 159

    (34) expression -> IDENTIFIER DOT function_call .

    RANGE_EXCLUSIVE reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    RANGE_INCLUSIVE reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    PLUS            reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    MINUS           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    TIMES           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    DIVIDE          reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    MODULE_OP       reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    POWER           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    EQUAL           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    NOT_EQUAL       reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    GREATER         reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    LESS            reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    GREATER_EQUAL   reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    LESS_EQUAL      reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    SPACESHIP       reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    CASE_EQUAL      reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    SEMICOLON       reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    BREAK           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    NEXT            reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    IDENTIFIER      reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    INSTANCE_VARIABLE reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    CLASS_VARIABLE  reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    GLOBAL_VARIABLE reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    CONSTANT        reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    PUTS            reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    FOR             reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    IF              reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    WHILE           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    DEF             reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    RETURN          reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    CLASS           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    $end            reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    LOGICAL_AND     reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    AND             reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    LOGICAL_OR      reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    OR              reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    END             reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    ELSIF           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    ELSE            reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    RBRACKET        reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    COMMA           reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    RPAREN          reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    HASH_ROCKET     reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)
    RBRACE          reduce using rule 34 (expression -> IDENTIFIER DOT function_call .)


state 160

    (47) array_access -> IDENTIFIER LBRACKET expression . RBRACKET
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (96) array_elements -> expression .
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RBRACKET resolved as shift
  ! shift/reduce conflict for RBRACKET resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 92 (condition -> expression .)
    RBRACKET        shift and go to state 137
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)
    COMMA           reduce using rule 92 (condition -> expression .)

  ! RBRACKET        [ reduce using rule 96 (array_elements -> expression .) ]
  ! COMMA           [ reduce using rule 96 (array_elements -> expression .) ]
  ! RBRACKET        [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 161

    (107) function_call -> IDENTIFIER LPAREN arguments . RPAREN
    (110) arguments -> arguments . COMMA expression

    RPAREN          shift and go to state 185
    COMMA           shift and go to state 164


state 162

    (108) function_call -> IDENTIFIER LPAREN RPAREN .

    RANGE_EXCLUSIVE reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RANGE_INCLUSIVE reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    MODULE_OP       reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    POWER           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    EQUAL           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    GREATER         reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LESS            reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    GREATER_EQUAL   reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LESS_EQUAL      reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SPACESHIP       reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CASE_EQUAL      reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    SEMICOLON       reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    BREAK           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    NEXT            reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    INSTANCE_VARIABLE reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CLASS_VARIABLE  reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    GLOBAL_VARIABLE reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CONSTANT        reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    PUTS            reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    FOR             reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    IF              reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    WHILE           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    DEF             reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RETURN          reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    CLASS           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    $end            reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LOGICAL_AND     reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    AND             reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    LOGICAL_OR      reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    OR              reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    END             reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ELSIF           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    ELSE            reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    HASH_ROCKET     reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 108 (function_call -> IDENTIFIER LPAREN RPAREN .)


state 163

    (54) expression -> LPAREN expression . RPAREN
    (111) arguments -> expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 92 (condition -> expression .)
    RPAREN          shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)
    COMMA           reduce using rule 92 (condition -> expression .)

  ! RPAREN          [ reduce using rule 111 (arguments -> expression .) ]
  ! COMMA           [ reduce using rule 111 (arguments -> expression .) ]
  ! RPAREN          [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 164

    (110) arguments -> arguments COMMA . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 186
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 165

    (54) expression -> LPAREN expression RPAREN .

    RANGE_EXCLUSIVE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RANGE_INCLUSIVE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    MODULE_OP       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    POWER           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LESS            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    GREATER_EQUAL   reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LESS_EQUAL      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    SPACESHIP       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CASE_EQUAL      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    NEXT            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    INSTANCE_VARIABLE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CLASS_VARIABLE  reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    GLOBAL_VARIABLE reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CONSTANT        reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    FOR             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    IF              reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    DEF             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    CLASS           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LOGICAL_AND     reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    LOGICAL_OR      reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    END             reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    ELSIF           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    HASH_ROCKET     reduce using rule 54 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 54 (expression -> LPAREN expression RPAREN .)


state 166

    (67) expression -> LBRACE hash_pairs RBRACE .

    RANGE_EXCLUSIVE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RANGE_INCLUSIVE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    PLUS            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    MINUS           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    TIMES           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    DIVIDE          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    MODULE_OP       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    POWER           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    EQUAL           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    NOT_EQUAL       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    GREATER         reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LESS            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    GREATER_EQUAL   reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LESS_EQUAL      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    SPACESHIP       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CASE_EQUAL      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    SEMICOLON       reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    BREAK           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    NEXT            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    IDENTIFIER      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    INSTANCE_VARIABLE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CLASS_VARIABLE  reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    GLOBAL_VARIABLE reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CONSTANT        reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    PUTS            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    FOR             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    IF              reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    WHILE           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    DEF             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RETURN          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    CLASS           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    $end            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LOGICAL_AND     reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    AND             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    LOGICAL_OR      reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    OR              reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    END             reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    ELSIF           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    ELSE            reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RBRACKET        reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    COMMA           reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RPAREN          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    HASH_ROCKET     reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)
    RBRACE          reduce using rule 67 (expression -> LBRACE hash_pairs RBRACE .)


state 167

    (69) hash_pairs -> hash_pairs COMMA . hash_pair
    (71) hash_pair -> . expression HASH_ROCKET expression
    (72) hash_pair -> . SYMBOL HASH_ROCKET expression
    (73) hash_pair -> . STRING HASH_ROCKET expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    SYMBOL          shift and go to state 118
    STRING          shift and go to state 119
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    hash_pair                      shift and go to state 187
    expression                     shift and go to state 117
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 168

    (71) hash_pair -> expression HASH_ROCKET . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 188
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 169

    (72) hash_pair -> SYMBOL HASH_ROCKET . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 189
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 170

    (73) hash_pair -> STRING HASH_ROCKET . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 190
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 171

    (93) expression -> LBRACKET array_elements RBRACKET .

    RANGE_EXCLUSIVE reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    PLUS            reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    MINUS           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    TIMES           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    DIVIDE          reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    MODULE_OP       reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    POWER           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    EQUAL           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    NOT_EQUAL       reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    GREATER         reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    LESS            reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    GREATER_EQUAL   reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    LESS_EQUAL      reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    SPACESHIP       reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    CASE_EQUAL      reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    SEMICOLON       reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    BREAK           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    NEXT            reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    IDENTIFIER      reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    INSTANCE_VARIABLE reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    CLASS_VARIABLE  reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    GLOBAL_VARIABLE reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    CONSTANT        reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    PUTS            reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    FOR             reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    IF              reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    WHILE           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    DEF             reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    RETURN          reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    CLASS           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    $end            reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    LOGICAL_AND     reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    AND             reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    LOGICAL_OR      reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    OR              reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    END             reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    ELSIF           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    ELSE            reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    RBRACKET        reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    COMMA           reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    RPAREN          reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    HASH_ROCKET     reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)
    RBRACE          reduce using rule 93 (expression -> LBRACKET array_elements RBRACKET .)


state 172

    (95) array_elements -> array_elements COMMA . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63

    expression                     shift and go to state 191
    condition                      shift and go to state 50
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 173

    (97) control_statement -> FOR for_setup statements exit_scope . END

    END             shift and go to state 192


state 174

    (4) exit_scope -> empty .

    END             reduce using rule 4 (exit_scope -> empty .)
    ELSE            reduce using rule 4 (exit_scope -> empty .)


state 175

    (98) for_setup -> IDENTIFIER IN expression . enter_loop_scope
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .
    (3) enter_loop_scope -> . empty
    (1) empty -> .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for NEXT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for PUTS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for FOR resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for DEF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for END resolved using rule 1 (empty -> .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SEMICOLON       [ reduce using rule 92 (condition -> expression .) ]
  ! BREAK           [ reduce using rule 92 (condition -> expression .) ]
  ! NEXT            [ reduce using rule 92 (condition -> expression .) ]
  ! IDENTIFIER      [ reduce using rule 92 (condition -> expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 92 (condition -> expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 92 (condition -> expression .) ]
  ! CONSTANT        [ reduce using rule 92 (condition -> expression .) ]
  ! PUTS            [ reduce using rule 92 (condition -> expression .) ]
  ! FOR             [ reduce using rule 92 (condition -> expression .) ]
  ! IF              [ reduce using rule 92 (condition -> expression .) ]
  ! WHILE           [ reduce using rule 92 (condition -> expression .) ]
  ! DEF             [ reduce using rule 92 (condition -> expression .) ]
  ! RETURN          [ reduce using rule 92 (condition -> expression .) ]
  ! CLASS           [ reduce using rule 92 (condition -> expression .) ]
  ! END             [ reduce using rule 92 (condition -> expression .) ]

    enter_loop_scope               shift and go to state 193
    empty                          shift and go to state 130

state 176

    (99) control_statement -> IF condition enter_scope statements . exit_scope END
    (100) control_statement -> IF condition enter_scope statements . exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> IF condition enter_scope statements . elsif_clauses exit_scope END
    (102) control_statement -> IF condition enter_scope statements . elsif_clauses ELSE enter_scope statements exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (103) elsif_clauses -> . ELSIF condition statements elsif_clauses
    (104) elsif_clauses -> . ELSIF condition statements
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    ELSIF           shift and go to state 196
    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 194
    elsif_clauses                  shift and go to state 195
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 177

    (105) control_statement -> WHILE condition enter_loop_scope statements . exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 197
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 178

    (60) function_definition -> DEF func_name_hook func_header statements . exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 198
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 179

    (62) func_header -> LPAREN param_list . RPAREN

    RPAREN          shift and go to state 199


state 180

    (63) func_header -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 63 (func_header -> LPAREN RPAREN .)
    BREAK           reduce using rule 63 (func_header -> LPAREN RPAREN .)
    NEXT            reduce using rule 63 (func_header -> LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 63 (func_header -> LPAREN RPAREN .)
    INSTANCE_VARIABLE reduce using rule 63 (func_header -> LPAREN RPAREN .)
    CLASS_VARIABLE  reduce using rule 63 (func_header -> LPAREN RPAREN .)
    GLOBAL_VARIABLE reduce using rule 63 (func_header -> LPAREN RPAREN .)
    CONSTANT        reduce using rule 63 (func_header -> LPAREN RPAREN .)
    PUTS            reduce using rule 63 (func_header -> LPAREN RPAREN .)
    FOR             reduce using rule 63 (func_header -> LPAREN RPAREN .)
    IF              reduce using rule 63 (func_header -> LPAREN RPAREN .)
    WHILE           reduce using rule 63 (func_header -> LPAREN RPAREN .)
    DEF             reduce using rule 63 (func_header -> LPAREN RPAREN .)
    RETURN          reduce using rule 63 (func_header -> LPAREN RPAREN .)
    CLASS           reduce using rule 63 (func_header -> LPAREN RPAREN .)
    END             reduce using rule 63 (func_header -> LPAREN RPAREN .)


state 181

    (58) param_list -> IDENTIFIER . COMMA param_list
    (59) param_list -> IDENTIFIER .

    COMMA           shift and go to state 200
    RPAREN          reduce using rule 59 (param_list -> IDENTIFIER .)


state 182

    (56) class_definition -> CLASS CONSTANT enter_scope statements . exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 201
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 183

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT . enter_scope statements exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 202
    empty                          shift and go to state 128

state 184

    (76) io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .

    SEMICOLON       reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    BREAK           reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    NEXT            reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    INSTANCE_VARIABLE reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    CLASS_VARIABLE  reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    GLOBAL_VARIABLE reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    CONSTANT        reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    PUTS            reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    FOR             reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    IF              reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    WHILE           reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    DEF             reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    RETURN          reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    CLASS           reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    $end            reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    END             reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    ELSIF           reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)
    ELSE            reduce using rule 76 (io_statement -> IDENTIFIER ASSIGN GETS DOT IDENTIFIER .)


state 185

    (107) function_call -> IDENTIFIER LPAREN arguments RPAREN .

    RANGE_EXCLUSIVE reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    RANGE_INCLUSIVE reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    PLUS            reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    MINUS           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    TIMES           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    MODULE_OP       reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    POWER           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    NOT_EQUAL       reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    GREATER         reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    LESS            reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    GREATER_EQUAL   reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    LESS_EQUAL      reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    SPACESHIP       reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    CASE_EQUAL      reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    BREAK           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    NEXT            reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    IDENTIFIER      reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    INSTANCE_VARIABLE reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    CLASS_VARIABLE  reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    GLOBAL_VARIABLE reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    CONSTANT        reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    PUTS            reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    FOR             reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    IF              reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    WHILE           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    DEF             reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    RETURN          reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    CLASS           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    $end            reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    LOGICAL_AND     reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    AND             reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    LOGICAL_OR      reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    OR              reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    END             reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    ELSIF           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    ELSE            reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    RBRACKET        reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    COMMA           reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    HASH_ROCKET     reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)
    RBRACE          reduce using rule 107 (function_call -> IDENTIFIER LPAREN arguments RPAREN .)


state 186

    (110) arguments -> arguments COMMA expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for COMMA resolved using rule 92 (condition -> expression .)
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for BREAK resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for NEXT resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for PUTS resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for FOR resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for IF resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for WHILE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for DEF resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RETURN resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for CLASS resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for $end resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for LOGICAL_AND resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for AND resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for LOGICAL_OR resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for OR resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for END resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for ELSIF resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for ELSE resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for RBRACE resolved using rule 92 (condition -> expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    COMMA           reduce using rule 92 (condition -> expression .)
    SEMICOLON       reduce using rule 92 (condition -> expression .)
    BREAK           reduce using rule 92 (condition -> expression .)
    NEXT            reduce using rule 92 (condition -> expression .)
    IDENTIFIER      reduce using rule 92 (condition -> expression .)
    INSTANCE_VARIABLE reduce using rule 92 (condition -> expression .)
    CLASS_VARIABLE  reduce using rule 92 (condition -> expression .)
    GLOBAL_VARIABLE reduce using rule 92 (condition -> expression .)
    CONSTANT        reduce using rule 92 (condition -> expression .)
    PUTS            reduce using rule 92 (condition -> expression .)
    FOR             reduce using rule 92 (condition -> expression .)
    IF              reduce using rule 92 (condition -> expression .)
    WHILE           reduce using rule 92 (condition -> expression .)
    DEF             reduce using rule 92 (condition -> expression .)
    RETURN          reduce using rule 92 (condition -> expression .)
    CLASS           reduce using rule 92 (condition -> expression .)
    $end            reduce using rule 92 (condition -> expression .)
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)
    END             reduce using rule 92 (condition -> expression .)
    ELSIF           reduce using rule 92 (condition -> expression .)
    ELSE            reduce using rule 92 (condition -> expression .)
    RBRACKET        reduce using rule 92 (condition -> expression .)
    RPAREN          reduce using rule 92 (condition -> expression .)
    HASH_ROCKET     reduce using rule 92 (condition -> expression .)
    RBRACE          reduce using rule 92 (condition -> expression .)

  ! COMMA           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! PLUS            [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! MINUS           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! TIMES           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! DIVIDE          [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! MODULE_OP       [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! POWER           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! EQUAL           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! NOT_EQUAL       [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! GREATER         [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! LESS            [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! LESS_EQUAL      [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! SPACESHIP       [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! CASE_EQUAL      [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! SEMICOLON       [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! BREAK           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! NEXT            [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! IDENTIFIER      [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! CLASS_VARIABLE  [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! CONSTANT        [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! PUTS            [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! FOR             [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! IF              [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! WHILE           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! DEF             [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! RETURN          [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! CLASS           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! $end            [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! LOGICAL_AND     [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! AND             [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! LOGICAL_OR      [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! OR              [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! END             [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! ELSIF           [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! ELSE            [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! RBRACKET        [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! RPAREN          [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! HASH_ROCKET     [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! RBRACE          [ reduce using rule 110 (arguments -> arguments COMMA expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 187

    (69) hash_pairs -> hash_pairs COMMA hash_pair .

    RBRACE          reduce using rule 69 (hash_pairs -> hash_pairs COMMA hash_pair .)
    COMMA           reduce using rule 69 (hash_pairs -> hash_pairs COMMA hash_pair .)


state 188

    (71) hash_pair -> expression HASH_ROCKET expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 71 (hash_pair -> expression HASH_ROCKET expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 71 (hash_pair -> expression HASH_ROCKET expression .)
    RBRACE          reduce using rule 71 (hash_pair -> expression HASH_ROCKET expression .)
    COMMA           reduce using rule 71 (hash_pair -> expression HASH_ROCKET expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]


state 189

    (72) hash_pair -> SYMBOL HASH_ROCKET expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 72 (hash_pair -> SYMBOL HASH_ROCKET expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 72 (hash_pair -> SYMBOL HASH_ROCKET expression .)
    RBRACE          reduce using rule 72 (hash_pair -> SYMBOL HASH_ROCKET expression .)
    COMMA           reduce using rule 72 (hash_pair -> SYMBOL HASH_ROCKET expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]


state 190

    (73) hash_pair -> STRING HASH_ROCKET expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 73 (hash_pair -> STRING HASH_ROCKET expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 73 (hash_pair -> STRING HASH_ROCKET expression .)
    RBRACE          reduce using rule 73 (hash_pair -> STRING HASH_ROCKET expression .)
    COMMA           reduce using rule 73 (hash_pair -> STRING HASH_ROCKET expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! RBRACE          [ reduce using rule 92 (condition -> expression .) ]
  ! COMMA           [ reduce using rule 92 (condition -> expression .) ]


state 191

    (95) array_elements -> array_elements COMMA expression .
    (31) expression -> expression . RANGE_EXCLUSIVE expression
    (32) expression -> expression . RANGE_INCLUSIVE expression
    (48) expression -> expression . PLUS expression
    (49) expression -> expression . MINUS expression
    (50) expression -> expression . TIMES expression
    (51) expression -> expression . DIVIDE expression
    (52) expression -> expression . MODULE_OP expression
    (53) expression -> expression . POWER expression
    (78) condition -> expression . EQUAL expression
    (79) condition -> expression . NOT_EQUAL expression
    (80) condition -> expression . GREATER expression
    (81) condition -> expression . LESS expression
    (82) condition -> expression . GREATER_EQUAL expression
    (83) condition -> expression . LESS_EQUAL expression
    (84) condition -> expression . SPACESHIP expression
    (85) condition -> expression . CASE_EQUAL expression
    (92) condition -> expression .

  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULE_OP resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for SPACESHIP resolved as shift
  ! shift/reduce conflict for CASE_EQUAL resolved as shift
  ! reduce/reduce conflict for RBRACKET resolved using rule 92 (condition -> expression .)
  ! reduce/reduce conflict for COMMA resolved using rule 92 (condition -> expression .)
    RANGE_EXCLUSIVE shift and go to state 87
    RANGE_INCLUSIVE shift and go to state 88
    PLUS            shift and go to state 89
    MINUS           shift and go to state 90
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULE_OP       shift and go to state 93
    POWER           shift and go to state 94
    EQUAL           shift and go to state 95
    NOT_EQUAL       shift and go to state 96
    GREATER         shift and go to state 97
    LESS            shift and go to state 98
    GREATER_EQUAL   shift and go to state 99
    LESS_EQUAL      shift and go to state 100
    SPACESHIP       shift and go to state 101
    CASE_EQUAL      shift and go to state 102
    RBRACKET        reduce using rule 92 (condition -> expression .)
    COMMA           reduce using rule 92 (condition -> expression .)
    LOGICAL_AND     reduce using rule 92 (condition -> expression .)
    AND             reduce using rule 92 (condition -> expression .)
    LOGICAL_OR      reduce using rule 92 (condition -> expression .)
    OR              reduce using rule 92 (condition -> expression .)

  ! RBRACKET        [ reduce using rule 95 (array_elements -> array_elements COMMA expression .) ]
  ! COMMA           [ reduce using rule 95 (array_elements -> array_elements COMMA expression .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 92 (condition -> expression .) ]
  ! PLUS            [ reduce using rule 92 (condition -> expression .) ]
  ! MINUS           [ reduce using rule 92 (condition -> expression .) ]
  ! TIMES           [ reduce using rule 92 (condition -> expression .) ]
  ! DIVIDE          [ reduce using rule 92 (condition -> expression .) ]
  ! MODULE_OP       [ reduce using rule 92 (condition -> expression .) ]
  ! POWER           [ reduce using rule 92 (condition -> expression .) ]
  ! EQUAL           [ reduce using rule 92 (condition -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER         [ reduce using rule 92 (condition -> expression .) ]
  ! LESS            [ reduce using rule 92 (condition -> expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 92 (condition -> expression .) ]
  ! LESS_EQUAL      [ reduce using rule 92 (condition -> expression .) ]
  ! SPACESHIP       [ reduce using rule 92 (condition -> expression .) ]
  ! CASE_EQUAL      [ reduce using rule 92 (condition -> expression .) ]


state 192

    (97) control_statement -> FOR for_setup statements exit_scope END .

    SEMICOLON       reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    BREAK           reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    NEXT            reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    IDENTIFIER      reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    CONSTANT        reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    PUTS            reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    FOR             reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    IF              reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    WHILE           reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    DEF             reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    RETURN          reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    CLASS           reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    $end            reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    END             reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    ELSIF           reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)
    ELSE            reduce using rule 97 (control_statement -> FOR for_setup statements exit_scope END .)


state 193

    (98) for_setup -> IDENTIFIER IN expression enter_loop_scope .

    SEMICOLON       reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    BREAK           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    NEXT            reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    IDENTIFIER      reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    INSTANCE_VARIABLE reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    CLASS_VARIABLE  reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    GLOBAL_VARIABLE reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    CONSTANT        reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    PUTS            reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    FOR             reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    IF              reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    WHILE           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    DEF             reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    RETURN          reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    CLASS           reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)
    END             reduce using rule 98 (for_setup -> IDENTIFIER IN expression enter_loop_scope .)


state 194

    (99) control_statement -> IF condition enter_scope statements exit_scope . END
    (100) control_statement -> IF condition enter_scope statements exit_scope . ELSE enter_scope statements exit_scope END

    END             shift and go to state 203
    ELSE            shift and go to state 204


state 195

    (101) control_statement -> IF condition enter_scope statements elsif_clauses . exit_scope END
    (102) control_statement -> IF condition enter_scope statements elsif_clauses . ELSE enter_scope statements exit_scope END
    (4) exit_scope -> . empty
    (1) empty -> .

    ELSE            shift and go to state 206
    END             reduce using rule 1 (empty -> .)

    exit_scope                     shift and go to state 205
    empty                          shift and go to state 174

state 196

    (103) elsif_clauses -> ELSIF . condition statements elsif_clauses
    (104) elsif_clauses -> ELSIF . condition statements
    (78) condition -> . expression EQUAL expression
    (79) condition -> . expression NOT_EQUAL expression
    (80) condition -> . expression GREATER expression
    (81) condition -> . expression LESS expression
    (82) condition -> . expression GREATER_EQUAL expression
    (83) condition -> . expression LESS_EQUAL expression
    (84) condition -> . expression SPACESHIP expression
    (85) condition -> . expression CASE_EQUAL expression
    (86) condition -> . condition LOGICAL_AND condition
    (87) condition -> . condition AND condition
    (88) condition -> . condition LOGICAL_OR condition
    (89) condition -> . condition OR condition
    (90) condition -> . LOGICAL_NOT condition
    (91) condition -> . NOT condition
    (92) condition -> . expression
    (16) expression -> . INTEGER
    (17) expression -> . FLOAT
    (18) expression -> . STRING
    (19) expression -> . SYMBOL
    (20) expression -> . REGEXP
    (21) expression -> . TRUE
    (22) expression -> . FALSE
    (23) expression -> . NIL
    (24) expression -> . condition
    (25) expression -> . IDENTIFIER
    (26) expression -> . INSTANCE_VARIABLE
    (27) expression -> . CLASS_VARIABLE
    (28) expression -> . GLOBAL_VARIABLE
    (29) expression -> . CONSTANT
    (30) expression -> . array_access
    (31) expression -> . expression RANGE_EXCLUSIVE expression
    (32) expression -> . expression RANGE_INCLUSIVE expression
    (33) expression -> . IDENTIFIER DOT IDENTIFIER
    (34) expression -> . IDENTIFIER DOT function_call
    (48) expression -> . expression PLUS expression
    (49) expression -> . expression MINUS expression
    (50) expression -> . expression TIMES expression
    (51) expression -> . expression DIVIDE expression
    (52) expression -> . expression MODULE_OP expression
    (53) expression -> . expression POWER expression
    (54) expression -> . LPAREN expression RPAREN
    (55) expression -> . MINUS expression
    (67) expression -> . LBRACE hash_pairs RBRACE
    (68) expression -> . LBRACE RBRACE
    (93) expression -> . LBRACKET array_elements RBRACKET
    (94) expression -> . LBRACKET RBRACKET
    (106) expression -> . function_call
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET
    (107) function_call -> . IDENTIFIER LPAREN arguments RPAREN
    (108) function_call -> . IDENTIFIER LPAREN RPAREN
    (109) function_call -> . IDENTIFIER arguments

    LOGICAL_NOT     shift and go to state 62
    NOT             shift and go to state 63
    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43
    STRING          shift and go to state 44
    SYMBOL          shift and go to state 45
    REGEXP          shift and go to state 46
    TRUE            shift and go to state 47
    FALSE           shift and go to state 48
    NIL             shift and go to state 49
    IDENTIFIER      shift and go to state 51
    INSTANCE_VARIABLE shift and go to state 52
    CLASS_VARIABLE  shift and go to state 53
    GLOBAL_VARIABLE shift and go to state 54
    CONSTANT        shift and go to state 55
    LPAREN          shift and go to state 59
    MINUS           shift and go to state 58
    LBRACE          shift and go to state 60
    LBRACKET        shift and go to state 61

    condition                      shift and go to state 207
    expression                     shift and go to state 67
    array_access                   shift and go to state 56
    function_call                  shift and go to state 57

state 197

    (105) control_statement -> WHILE condition enter_loop_scope statements exit_scope . END

    END             shift and go to state 208


state 198

    (60) function_definition -> DEF func_name_hook func_header statements exit_scope . END

    END             shift and go to state 209


state 199

    (62) func_header -> LPAREN param_list RPAREN .

    SEMICOLON       reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    BREAK           reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    NEXT            reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    IDENTIFIER      reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    INSTANCE_VARIABLE reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    CLASS_VARIABLE  reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    GLOBAL_VARIABLE reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    CONSTANT        reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    PUTS            reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    FOR             reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    IF              reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    WHILE           reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    DEF             reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    RETURN          reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    CLASS           reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)
    END             reduce using rule 62 (func_header -> LPAREN param_list RPAREN .)


state 200

    (58) param_list -> IDENTIFIER COMMA . param_list
    (58) param_list -> . IDENTIFIER COMMA param_list
    (59) param_list -> . IDENTIFIER

    IDENTIFIER      shift and go to state 181

    param_list                     shift and go to state 210

state 201

    (56) class_definition -> CLASS CONSTANT enter_scope statements exit_scope . END

    END             shift and go to state 211


state 202

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope . statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    statements                     shift and go to state 212
    empty                          shift and go to state 3

state 203

    (99) control_statement -> IF condition enter_scope statements exit_scope END .

    SEMICOLON       reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    BREAK           reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    NEXT            reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    IDENTIFIER      reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    CONSTANT        reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    PUTS            reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    FOR             reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    IF              reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    WHILE           reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    DEF             reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    RETURN          reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    CLASS           reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    $end            reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    END             reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    ELSIF           reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)
    ELSE            reduce using rule 99 (control_statement -> IF condition enter_scope statements exit_scope END .)


state 204

    (100) control_statement -> IF condition enter_scope statements exit_scope ELSE . enter_scope statements exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 213
    empty                          shift and go to state 128

state 205

    (101) control_statement -> IF condition enter_scope statements elsif_clauses exit_scope . END

    END             shift and go to state 214


state 206

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE . enter_scope statements exit_scope END
    (2) enter_scope -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    enter_scope                    shift and go to state 215
    empty                          shift and go to state 128

state 207

    (103) elsif_clauses -> ELSIF condition . statements elsif_clauses
    (104) elsif_clauses -> ELSIF condition . statements
    (86) condition -> condition . LOGICAL_AND condition
    (87) condition -> condition . AND condition
    (88) condition -> condition . LOGICAL_OR condition
    (89) condition -> condition . OR condition
    (24) expression -> condition .
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for ELSIF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for NEXT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for INSTANCE_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for GLOBAL_VARIABLE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for PUTS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for FOR resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for IF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for DEF resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for CLASS resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 1 (empty -> .)
  ! reduce/reduce conflict for END resolved using rule 1 (empty -> .)
    LOGICAL_AND     shift and go to state 103
    AND             shift and go to state 104
    LOGICAL_OR      shift and go to state 105
    OR              shift and go to state 106
    EQUAL           reduce using rule 24 (expression -> condition .)
    NOT_EQUAL       reduce using rule 24 (expression -> condition .)
    GREATER         reduce using rule 24 (expression -> condition .)
    LESS            reduce using rule 24 (expression -> condition .)
    GREATER_EQUAL   reduce using rule 24 (expression -> condition .)
    LESS_EQUAL      reduce using rule 24 (expression -> condition .)
    SPACESHIP       reduce using rule 24 (expression -> condition .)
    CASE_EQUAL      reduce using rule 24 (expression -> condition .)
    RANGE_EXCLUSIVE reduce using rule 24 (expression -> condition .)
    RANGE_INCLUSIVE reduce using rule 24 (expression -> condition .)
    PLUS            reduce using rule 24 (expression -> condition .)
    MINUS           reduce using rule 24 (expression -> condition .)
    TIMES           reduce using rule 24 (expression -> condition .)
    DIVIDE          reduce using rule 24 (expression -> condition .)
    MODULE_OP       reduce using rule 24 (expression -> condition .)
    POWER           reduce using rule 24 (expression -> condition .)
    ELSIF           reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    ELSE            reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

  ! LOGICAL_AND     [ reduce using rule 24 (expression -> condition .) ]
  ! AND             [ reduce using rule 24 (expression -> condition .) ]
  ! LOGICAL_OR      [ reduce using rule 24 (expression -> condition .) ]
  ! OR              [ reduce using rule 24 (expression -> condition .) ]
  ! ELSIF           [ reduce using rule 24 (expression -> condition .) ]
  ! SEMICOLON       [ reduce using rule 24 (expression -> condition .) ]
  ! BREAK           [ reduce using rule 24 (expression -> condition .) ]
  ! NEXT            [ reduce using rule 24 (expression -> condition .) ]
  ! IDENTIFIER      [ reduce using rule 24 (expression -> condition .) ]
  ! INSTANCE_VARIABLE [ reduce using rule 24 (expression -> condition .) ]
  ! CLASS_VARIABLE  [ reduce using rule 24 (expression -> condition .) ]
  ! GLOBAL_VARIABLE [ reduce using rule 24 (expression -> condition .) ]
  ! CONSTANT        [ reduce using rule 24 (expression -> condition .) ]
  ! PUTS            [ reduce using rule 24 (expression -> condition .) ]
  ! FOR             [ reduce using rule 24 (expression -> condition .) ]
  ! IF              [ reduce using rule 24 (expression -> condition .) ]
  ! WHILE           [ reduce using rule 24 (expression -> condition .) ]
  ! DEF             [ reduce using rule 24 (expression -> condition .) ]
  ! RETURN          [ reduce using rule 24 (expression -> condition .) ]
  ! CLASS           [ reduce using rule 24 (expression -> condition .) ]
  ! ELSE            [ reduce using rule 24 (expression -> condition .) ]
  ! END             [ reduce using rule 24 (expression -> condition .) ]

    statements                     shift and go to state 216
    empty                          shift and go to state 3

state 208

    (105) control_statement -> WHILE condition enter_loop_scope statements exit_scope END .

    SEMICOLON       reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    BREAK           reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    NEXT            reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    IDENTIFIER      reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    CONSTANT        reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    PUTS            reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    FOR             reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    IF              reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    WHILE           reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    DEF             reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    RETURN          reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    CLASS           reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    $end            reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    END             reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    ELSIF           reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)
    ELSE            reduce using rule 105 (control_statement -> WHILE condition enter_loop_scope statements exit_scope END .)


state 209

    (60) function_definition -> DEF func_name_hook func_header statements exit_scope END .

    SEMICOLON       reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    BREAK           reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    NEXT            reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    IDENTIFIER      reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    CONSTANT        reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    PUTS            reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    FOR             reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    IF              reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    WHILE           reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    DEF             reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    RETURN          reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    CLASS           reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    $end            reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    END             reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    ELSIF           reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)
    ELSE            reduce using rule 60 (function_definition -> DEF func_name_hook func_header statements exit_scope END .)


state 210

    (58) param_list -> IDENTIFIER COMMA param_list .

    RPAREN          reduce using rule 58 (param_list -> IDENTIFIER COMMA param_list .)


state 211

    (56) class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .

    SEMICOLON       reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    BREAK           reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    NEXT            reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    IDENTIFIER      reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    CONSTANT        reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    PUTS            reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    FOR             reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    IF              reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    WHILE           reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    DEF             reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    RETURN          reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    CLASS           reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    $end            reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    END             reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    ELSIF           reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)
    ELSE            reduce using rule 56 (class_definition -> CLASS CONSTANT enter_scope statements exit_scope END .)


state 212

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements . exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 217
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 213

    (100) control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope . statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    statements                     shift and go to state 218
    empty                          shift and go to state 3

state 214

    (101) control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .

    SEMICOLON       reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    BREAK           reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    NEXT            reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    IDENTIFIER      reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    CLASS_VARIABLE  reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    CONSTANT        reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    PUTS            reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    FOR             reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    IF              reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    WHILE           reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    DEF             reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    RETURN          reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    CLASS           reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    $end            reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    END             reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    ELSIF           reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)
    ELSE            reduce using rule 101 (control_statement -> IF condition enter_scope statements elsif_clauses exit_scope END .)


state 215

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope . statements exit_scope END
    (6) statements -> . statements statement
    (7) statements -> . empty
    (1) empty -> .

    SEMICOLON       reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    NEXT            reduce using rule 1 (empty -> .)
    IDENTIFIER      reduce using rule 1 (empty -> .)
    INSTANCE_VARIABLE reduce using rule 1 (empty -> .)
    CLASS_VARIABLE  reduce using rule 1 (empty -> .)
    GLOBAL_VARIABLE reduce using rule 1 (empty -> .)
    CONSTANT        reduce using rule 1 (empty -> .)
    PUTS            reduce using rule 1 (empty -> .)
    FOR             reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    WHILE           reduce using rule 1 (empty -> .)
    DEF             reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    CLASS           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)

    statements                     shift and go to state 219
    empty                          shift and go to state 3

state 216

    (103) elsif_clauses -> ELSIF condition statements . elsif_clauses
    (104) elsif_clauses -> ELSIF condition statements .
    (6) statements -> statements . statement
    (103) elsif_clauses -> . ELSIF condition statements elsif_clauses
    (104) elsif_clauses -> . ELSIF condition statements
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    ELSE            reduce using rule 104 (elsif_clauses -> ELSIF condition statements .)
    END             reduce using rule 104 (elsif_clauses -> ELSIF condition statements .)
    ELSIF           shift and go to state 196
    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    elsif_clauses                  shift and go to state 220
    statement                      shift and go to state 4
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 217

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope . END

    END             shift and go to state 221


state 218

    (100) control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements . exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 222
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 219

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements . exit_scope END
    (6) statements -> statements . statement
    (4) exit_scope -> . empty
    (8) statement -> . assignment
    (9) statement -> . special_assignment
    (10) statement -> . io_statement
    (11) statement -> . control_statement
    (12) statement -> . function_definition
    (13) statement -> . return_statement
    (14) statement -> . class_definition
    (15) statement -> . SEMICOLON
    (112) statement -> . BREAK
    (113) statement -> . NEXT
    (1) empty -> .
    (41) assignment -> . IDENTIFIER ASSIGN expression
    (42) assignment -> . INSTANCE_VARIABLE ASSIGN expression
    (43) assignment -> . CLASS_VARIABLE ASSIGN expression
    (44) assignment -> . GLOBAL_VARIABLE ASSIGN expression
    (45) assignment -> . CONSTANT ASSIGN expression
    (46) assignment -> . array_access ASSIGN expression
    (35) special_assignment -> . IDENTIFIER PLUS_ASSIGN expression
    (36) special_assignment -> . IDENTIFIER MINUS_ASSIGN expression
    (37) special_assignment -> . IDENTIFIER TIMES_ASSIGN expression
    (38) special_assignment -> . IDENTIFIER DIVIDE_ASSIGN expression
    (39) special_assignment -> . IDENTIFIER MOD_ASSIGN expression
    (40) special_assignment -> . IDENTIFIER POWER_ASSIGN expression
    (74) io_statement -> . PUTS expression
    (75) io_statement -> . PUTS
    (76) io_statement -> . IDENTIFIER ASSIGN GETS DOT IDENTIFIER
    (77) io_statement -> . IDENTIFIER ASSIGN GETS
    (97) control_statement -> . FOR for_setup statements exit_scope END
    (99) control_statement -> . IF condition enter_scope statements exit_scope END
    (100) control_statement -> . IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END
    (101) control_statement -> . IF condition enter_scope statements elsif_clauses exit_scope END
    (102) control_statement -> . IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END
    (105) control_statement -> . WHILE condition enter_loop_scope statements exit_scope END
    (60) function_definition -> . DEF func_name_hook func_header statements exit_scope END
    (65) return_statement -> . RETURN expression
    (66) return_statement -> . RETURN
    (56) class_definition -> . CLASS CONSTANT enter_scope statements exit_scope END
    (57) class_definition -> . CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END
    (47) array_access -> . IDENTIFIER LBRACKET expression RBRACKET

    SEMICOLON       shift and go to state 12
    BREAK           shift and go to state 13
    NEXT            shift and go to state 14
    END             reduce using rule 1 (empty -> .)
    IDENTIFIER      shift and go to state 15
    INSTANCE_VARIABLE shift and go to state 16
    CLASS_VARIABLE  shift and go to state 17
    GLOBAL_VARIABLE shift and go to state 18
    CONSTANT        shift and go to state 19
    PUTS            shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    WHILE           shift and go to state 24
    DEF             shift and go to state 25
    RETURN          shift and go to state 26
    CLASS           shift and go to state 27

    exit_scope                     shift and go to state 223
    statement                      shift and go to state 4
    empty                          shift and go to state 174
    assignment                     shift and go to state 5
    special_assignment             shift and go to state 6
    io_statement                   shift and go to state 7
    control_statement              shift and go to state 8
    function_definition            shift and go to state 9
    return_statement               shift and go to state 10
    class_definition               shift and go to state 11
    array_access                   shift and go to state 20

state 220

    (103) elsif_clauses -> ELSIF condition statements elsif_clauses .

    ELSE            reduce using rule 103 (elsif_clauses -> ELSIF condition statements elsif_clauses .)
    END             reduce using rule 103 (elsif_clauses -> ELSIF condition statements elsif_clauses .)


state 221

    (57) class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .

    SEMICOLON       reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    BREAK           reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    NEXT            reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    IDENTIFIER      reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    CONSTANT        reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    PUTS            reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    FOR             reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    IF              reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    WHILE           reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    DEF             reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    RETURN          reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    CLASS           reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    $end            reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    END             reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    ELSIF           reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)
    ELSE            reduce using rule 57 (class_definition -> CLASS CONSTANT LESS CONSTANT enter_scope statements exit_scope END .)


state 222

    (100) control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope . END

    END             shift and go to state 224


state 223

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope . END

    END             shift and go to state 225


state 224

    (100) control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .

    SEMICOLON       reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    BREAK           reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    NEXT            reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    IDENTIFIER      reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    CONSTANT        reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    PUTS            reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    FOR             reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    IF              reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    WHILE           reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    DEF             reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    RETURN          reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    CLASS           reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    $end            reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    END             reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    ELSIF           reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)
    ELSE            reduce using rule 100 (control_statement -> IF condition enter_scope statements exit_scope ELSE enter_scope statements exit_scope END .)


state 225

    (102) control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .

    SEMICOLON       reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    BREAK           reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    NEXT            reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    IDENTIFIER      reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    INSTANCE_VARIABLE reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    CLASS_VARIABLE  reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    GLOBAL_VARIABLE reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    CONSTANT        reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    PUTS            reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    FOR             reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    IF              reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    WHILE           reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    DEF             reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    RETURN          reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    CLASS           reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    $end            reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    END             reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    ELSIF           reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)
    ELSE            reduce using rule 102 (control_statement -> IF condition enter_scope statements elsif_clauses ELSE enter_scope statements exit_scope END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 21 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VARIABLE in state 21 resolved as shift
WARNING: shift/reduce conflict for CLASS_VARIABLE in state 21 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VARIABLE in state 21 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 21 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 26 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VARIABLE in state 26 resolved as shift
WARNING: shift/reduce conflict for CLASS_VARIABLE in state 26 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VARIABLE in state 26 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 26 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 41 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 41 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 41 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 41 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 41 resolved as shift
WARNING: shift/reduce conflict for POWER in state 41 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 41 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 41 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 41 resolved as shift
WARNING: shift/reduce conflict for LESS in state 41 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 41 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 41 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 41 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 41 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 50 resolved as shift
WARNING: shift/reduce conflict for AND in state 50 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 50 resolved as shift
WARNING: shift/reduce conflict for OR in state 50 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 51 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VARIABLE in state 51 resolved as shift
WARNING: shift/reduce conflict for CLASS_VARIABLE in state 51 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VARIABLE in state 51 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 51 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 51 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 66 resolved as shift
WARNING: shift/reduce conflict for AND in state 66 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 66 resolved as shift
WARNING: shift/reduce conflict for OR in state 66 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 67 resolved as shift
WARNING: shift/reduce conflict for LESS in state 67 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 67 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 67 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 67 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 67 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 67 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 67 resolved as shift
WARNING: shift/reduce conflict for POWER in state 67 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 68 resolved as shift
WARNING: shift/reduce conflict for AND in state 68 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 68 resolved as shift
WARNING: shift/reduce conflict for OR in state 68 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 71 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 71 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 71 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 71 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 71 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 71 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 71 resolved as shift
WARNING: shift/reduce conflict for POWER in state 71 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 71 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 71 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 71 resolved as shift
WARNING: shift/reduce conflict for LESS in state 71 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 71 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 71 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 71 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 71 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 73 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 73 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 73 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 73 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 73 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 73 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 73 resolved as shift
WARNING: shift/reduce conflict for POWER in state 73 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 73 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 73 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 73 resolved as shift
WARNING: shift/reduce conflict for LESS in state 73 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 73 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 73 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 73 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 73 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 75 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 75 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 75 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 75 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 75 resolved as shift
WARNING: shift/reduce conflict for POWER in state 75 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 75 resolved as shift
WARNING: shift/reduce conflict for LESS in state 75 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 75 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 75 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 76 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 76 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 76 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 76 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 76 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 76 resolved as shift
WARNING: shift/reduce conflict for POWER in state 76 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 76 resolved as shift
WARNING: shift/reduce conflict for LESS in state 76 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 76 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 76 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 77 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 77 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 77 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 77 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 77 resolved as shift
WARNING: shift/reduce conflict for POWER in state 77 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 77 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 77 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 77 resolved as shift
WARNING: shift/reduce conflict for LESS in state 77 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 77 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 77 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 77 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 77 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 78 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 78 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 78 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 78 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 78 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 78 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 78 resolved as shift
WARNING: shift/reduce conflict for POWER in state 78 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 78 resolved as shift
WARNING: shift/reduce conflict for LESS in state 78 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 78 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 78 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 79 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 79 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 79 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 79 resolved as shift
WARNING: shift/reduce conflict for POWER in state 79 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 79 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 79 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 79 resolved as shift
WARNING: shift/reduce conflict for LESS in state 79 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 79 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 79 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 79 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 79 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 80 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 80 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 80 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 80 resolved as shift
WARNING: shift/reduce conflict for POWER in state 80 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 80 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 80 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 80 resolved as shift
WARNING: shift/reduce conflict for LESS in state 80 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 80 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 80 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 80 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 80 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 81 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 81 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 81 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 81 resolved as shift
WARNING: shift/reduce conflict for POWER in state 81 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 81 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 81 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 81 resolved as shift
WARNING: shift/reduce conflict for LESS in state 81 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 81 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 81 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 81 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 81 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 82 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 82 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 82 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 82 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 82 resolved as shift
WARNING: shift/reduce conflict for POWER in state 82 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 82 resolved as shift
WARNING: shift/reduce conflict for LESS in state 82 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 82 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 83 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 83 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 83 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 83 resolved as shift
WARNING: shift/reduce conflict for POWER in state 83 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 83 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 83 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 83 resolved as shift
WARNING: shift/reduce conflict for LESS in state 83 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 83 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 83 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 83 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 83 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 84 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 84 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 84 resolved as shift
WARNING: shift/reduce conflict for POWER in state 84 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 84 resolved as shift
WARNING: shift/reduce conflict for LESS in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 84 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 85 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 85 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 85 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 85 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 85 resolved as shift
WARNING: shift/reduce conflict for POWER in state 85 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 85 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 85 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 85 resolved as shift
WARNING: shift/reduce conflict for LESS in state 85 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 85 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 85 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 85 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 85 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 86 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 86 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 86 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 86 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 86 resolved as shift
WARNING: shift/reduce conflict for POWER in state 86 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 86 resolved as shift
WARNING: shift/reduce conflict for LESS in state 86 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 86 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 86 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 109 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 109 resolved as shift
WARNING: shift/reduce conflict for POWER in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 109 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 109 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 109 resolved as shift
WARNING: shift/reduce conflict for POWER in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 109 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 111 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 113 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 113 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 113 resolved as shift
WARNING: shift/reduce conflict for POWER in state 113 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 113 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 113 resolved as shift
WARNING: shift/reduce conflict for HASH_ROCKET in state 117 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 117 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 117 resolved as shift
WARNING: shift/reduce conflict for POWER in state 117 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 117 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 117 resolved as shift
WARNING: shift/reduce conflict for HASH_ROCKET in state 118 resolved as shift
WARNING: shift/reduce conflict for HASH_ROCKET in state 119 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 122 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 122 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 122 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 122 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 122 resolved as shift
WARNING: shift/reduce conflict for POWER in state 122 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 122 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 122 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 124 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 124 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 138 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 138 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 138 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 138 resolved as shift
WARNING: shift/reduce conflict for POWER in state 138 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 138 resolved as shift
WARNING: shift/reduce conflict for LESS in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 138 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 138 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 138 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 138 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 138 resolved as shift
WARNING: shift/reduce conflict for POWER in state 138 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 138 resolved as shift
WARNING: shift/reduce conflict for LESS in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 138 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 138 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 139 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 139 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 139 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 139 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 139 resolved as shift
WARNING: shift/reduce conflict for POWER in state 139 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 139 resolved as shift
WARNING: shift/reduce conflict for LESS in state 139 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 139 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 139 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 139 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 139 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 139 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 139 resolved as shift
WARNING: shift/reduce conflict for POWER in state 139 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 139 resolved as shift
WARNING: shift/reduce conflict for LESS in state 139 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 139 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 140 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 140 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 140 resolved as shift
WARNING: shift/reduce conflict for POWER in state 140 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 141 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 141 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 141 resolved as shift
WARNING: shift/reduce conflict for POWER in state 141 resolved as shift
WARNING: shift/reduce conflict for POWER in state 142 resolved as shift
WARNING: shift/reduce conflict for POWER in state 143 resolved as shift
WARNING: shift/reduce conflict for POWER in state 144 resolved as shift
WARNING: shift/reduce conflict for POWER in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 146 resolved as shift
WARNING: shift/reduce conflict for POWER in state 146 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 147 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 147 resolved as shift
WARNING: shift/reduce conflict for POWER in state 147 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 148 resolved as shift
WARNING: shift/reduce conflict for POWER in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 149 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 149 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 149 resolved as shift
WARNING: shift/reduce conflict for POWER in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 150 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 150 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 150 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 150 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 150 resolved as shift
WARNING: shift/reduce conflict for POWER in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 151 resolved as shift
WARNING: shift/reduce conflict for POWER in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 152 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 152 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 152 resolved as shift
WARNING: shift/reduce conflict for POWER in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 153 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 153 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 153 resolved as shift
WARNING: shift/reduce conflict for POWER in state 153 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 155 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 155 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 156 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 157 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 157 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 158 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VARIABLE in state 158 resolved as shift
WARNING: shift/reduce conflict for CLASS_VARIABLE in state 158 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VARIABLE in state 158 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 160 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 160 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 160 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 160 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 160 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 160 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 160 resolved as shift
WARNING: shift/reduce conflict for POWER in state 160 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 160 resolved as shift
WARNING: shift/reduce conflict for LESS in state 160 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 160 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 163 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 163 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 163 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 163 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 163 resolved as shift
WARNING: shift/reduce conflict for POWER in state 163 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 163 resolved as shift
WARNING: shift/reduce conflict for LESS in state 163 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 163 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 163 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 175 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 175 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 175 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 175 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 175 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 175 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 175 resolved as shift
WARNING: shift/reduce conflict for POWER in state 175 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 175 resolved as shift
WARNING: shift/reduce conflict for LESS in state 175 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 175 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 175 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 186 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 186 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 186 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 186 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 186 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 186 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 186 resolved as shift
WARNING: shift/reduce conflict for POWER in state 186 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 186 resolved as shift
WARNING: shift/reduce conflict for LESS in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 186 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 186 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 186 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 186 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 186 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 186 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 186 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 186 resolved as shift
WARNING: shift/reduce conflict for POWER in state 186 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 186 resolved as shift
WARNING: shift/reduce conflict for LESS in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 186 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 188 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 188 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 188 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 188 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 188 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 188 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 188 resolved as shift
WARNING: shift/reduce conflict for POWER in state 188 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 188 resolved as shift
WARNING: shift/reduce conflict for LESS in state 188 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 188 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 189 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 189 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 189 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 189 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 189 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 189 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 189 resolved as shift
WARNING: shift/reduce conflict for POWER in state 189 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 189 resolved as shift
WARNING: shift/reduce conflict for LESS in state 189 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 189 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 190 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 190 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 190 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 190 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 190 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 190 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 190 resolved as shift
WARNING: shift/reduce conflict for POWER in state 190 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 190 resolved as shift
WARNING: shift/reduce conflict for LESS in state 190 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 190 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 190 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 191 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 191 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 191 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 191 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 191 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 191 resolved as shift
WARNING: shift/reduce conflict for MODULE_OP in state 191 resolved as shift
WARNING: shift/reduce conflict for POWER in state 191 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 191 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 191 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 191 resolved as shift
WARNING: shift/reduce conflict for LESS in state 191 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 191 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 191 resolved as shift
WARNING: shift/reduce conflict for SPACESHIP in state 191 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUAL in state 191 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 207 resolved as shift
WARNING: shift/reduce conflict for AND in state 207 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 207 resolved as shift
WARNING: shift/reduce conflict for OR in state 207 resolved as shift
WARNING: reduce/reduce conflict in state 41 resolved using rule (io_statement -> PUTS expression)
WARNING: rejected rule (condition -> expression) in state 41
WARNING: reduce/reduce conflict in state 66 resolved using rule (empty -> <empty>)
WARNING: rejected rule (expression -> condition) in state 66
WARNING: reduce/reduce conflict in state 68 resolved using rule (empty -> <empty>)
WARNING: rejected rule (expression -> condition) in state 68
WARNING: reduce/reduce conflict in state 71 resolved using rule (return_statement -> RETURN expression)
WARNING: rejected rule (condition -> expression) in state 71
WARNING: reduce/reduce conflict in state 73 resolved using rule (assignment -> IDENTIFIER ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 73
WARNING: reduce/reduce conflict in state 75 resolved using rule (special_assignment -> IDENTIFIER PLUS_ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 75
WARNING: reduce/reduce conflict in state 76 resolved using rule (special_assignment -> IDENTIFIER MINUS_ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 76
WARNING: reduce/reduce conflict in state 77 resolved using rule (special_assignment -> IDENTIFIER TIMES_ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 77
WARNING: reduce/reduce conflict in state 78 resolved using rule (special_assignment -> IDENTIFIER DIVIDE_ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 78
WARNING: reduce/reduce conflict in state 79 resolved using rule (special_assignment -> IDENTIFIER MOD_ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 79
WARNING: reduce/reduce conflict in state 80 resolved using rule (special_assignment -> IDENTIFIER POWER_ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 80
WARNING: reduce/reduce conflict in state 82 resolved using rule (assignment -> INSTANCE_VARIABLE ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 82
WARNING: reduce/reduce conflict in state 83 resolved using rule (assignment -> CLASS_VARIABLE ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 83
WARNING: reduce/reduce conflict in state 84 resolved using rule (assignment -> GLOBAL_VARIABLE ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 84
WARNING: reduce/reduce conflict in state 85 resolved using rule (assignment -> CONSTANT ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 85
WARNING: reduce/reduce conflict in state 86 resolved using rule (assignment -> array_access ASSIGN expression)
WARNING: rejected rule (condition -> expression) in state 86
WARNING: reduce/reduce conflict in state 109 resolved using rule (condition -> expression)
WARNING: rejected rule (arguments -> expression) in state 109
WARNING: reduce/reduce conflict in state 112 resolved using rule (expression -> MINUS expression)
WARNING: rejected rule (condition -> expression) in state 112
WARNING: reduce/reduce conflict in state 122 resolved using rule (condition -> expression)
WARNING: rejected rule (array_elements -> expression) in state 122
WARNING: reduce/reduce conflict in state 123 resolved using rule (expression -> condition)
WARNING: rejected rule (condition -> LOGICAL_NOT condition) in state 123
WARNING: reduce/reduce conflict in state 124 resolved using rule (expression -> condition)
WARNING: rejected rule (condition -> NOT condition) in state 124
WARNING: reduce/reduce conflict in state 138 resolved using rule (expression -> expression RANGE_EXCLUSIVE expression)
WARNING: rejected rule (condition -> expression) in state 138
WARNING: reduce/reduce conflict in state 139 resolved using rule (expression -> expression RANGE_INCLUSIVE expression)
WARNING: rejected rule (condition -> expression) in state 139
WARNING: reduce/reduce conflict in state 140 resolved using rule (expression -> expression PLUS expression)
WARNING: rejected rule (condition -> expression) in state 140
WARNING: reduce/reduce conflict in state 141 resolved using rule (expression -> expression MINUS expression)
WARNING: rejected rule (condition -> expression) in state 141
WARNING: reduce/reduce conflict in state 142 resolved using rule (expression -> expression TIMES expression)
WARNING: rejected rule (condition -> expression) in state 142
WARNING: reduce/reduce conflict in state 143 resolved using rule (expression -> expression DIVIDE expression)
WARNING: rejected rule (condition -> expression) in state 143
WARNING: reduce/reduce conflict in state 144 resolved using rule (expression -> expression MODULE_OP expression)
WARNING: rejected rule (condition -> expression) in state 144
WARNING: reduce/reduce conflict in state 145 resolved using rule (expression -> expression POWER expression)
WARNING: rejected rule (condition -> expression) in state 145
WARNING: reduce/reduce conflict in state 146 resolved using rule (condition -> expression EQUAL expression)
WARNING: rejected rule (condition -> expression) in state 146
WARNING: reduce/reduce conflict in state 147 resolved using rule (condition -> expression NOT_EQUAL expression)
WARNING: rejected rule (condition -> expression) in state 147
WARNING: reduce/reduce conflict in state 148 resolved using rule (condition -> expression GREATER expression)
WARNING: rejected rule (condition -> expression) in state 148
WARNING: reduce/reduce conflict in state 149 resolved using rule (condition -> expression LESS expression)
WARNING: rejected rule (condition -> expression) in state 149
WARNING: reduce/reduce conflict in state 150 resolved using rule (condition -> expression GREATER_EQUAL expression)
WARNING: rejected rule (condition -> expression) in state 150
WARNING: reduce/reduce conflict in state 151 resolved using rule (condition -> expression LESS_EQUAL expression)
WARNING: rejected rule (condition -> expression) in state 151
WARNING: reduce/reduce conflict in state 152 resolved using rule (condition -> expression SPACESHIP expression)
WARNING: rejected rule (condition -> expression) in state 152
WARNING: reduce/reduce conflict in state 153 resolved using rule (condition -> expression CASE_EQUAL expression)
WARNING: rejected rule (condition -> expression) in state 153
WARNING: reduce/reduce conflict in state 154 resolved using rule (expression -> condition)
WARNING: rejected rule (condition -> condition LOGICAL_AND condition) in state 154
WARNING: reduce/reduce conflict in state 155 resolved using rule (expression -> condition)
WARNING: rejected rule (condition -> condition AND condition) in state 155
WARNING: reduce/reduce conflict in state 156 resolved using rule (expression -> condition)
WARNING: rejected rule (condition -> condition LOGICAL_OR condition) in state 156
WARNING: reduce/reduce conflict in state 157 resolved using rule (expression -> condition)
WARNING: rejected rule (condition -> condition OR condition) in state 157
WARNING: reduce/reduce conflict in state 160 resolved using rule (condition -> expression)
WARNING: rejected rule (array_elements -> expression) in state 160
WARNING: reduce/reduce conflict in state 163 resolved using rule (condition -> expression)
WARNING: rejected rule (arguments -> expression) in state 163
WARNING: reduce/reduce conflict in state 175 resolved using rule (empty -> <empty>)
WARNING: rejected rule (condition -> expression) in state 175
WARNING: reduce/reduce conflict in state 186 resolved using rule (condition -> expression)
WARNING: rejected rule (arguments -> arguments COMMA expression) in state 186
WARNING: reduce/reduce conflict in state 188 resolved using rule (hash_pair -> expression HASH_ROCKET expression)
WARNING: rejected rule (condition -> expression) in state 188
WARNING: reduce/reduce conflict in state 189 resolved using rule (hash_pair -> SYMBOL HASH_ROCKET expression)
WARNING: rejected rule (condition -> expression) in state 189
WARNING: reduce/reduce conflict in state 190 resolved using rule (hash_pair -> STRING HASH_ROCKET expression)
WARNING: rejected rule (condition -> expression) in state 190
WARNING: reduce/reduce conflict in state 191 resolved using rule (condition -> expression)
WARNING: rejected rule (array_elements -> array_elements COMMA expression) in state 191
WARNING: reduce/reduce conflict in state 207 resolved using rule (empty -> <empty>)
WARNING: rejected rule (expression -> condition) in state 207
WARNING: Rule (arguments -> expression) is never reduced
WARNING: Rule (array_elements -> expression) is never reduced
WARNING: Rule (condition -> LOGICAL_NOT condition) is never reduced
WARNING: Rule (condition -> NOT condition) is never reduced
WARNING: Rule (condition -> condition LOGICAL_AND condition) is never reduced
WARNING: Rule (condition -> condition AND condition) is never reduced
WARNING: Rule (condition -> condition LOGICAL_OR condition) is never reduced
WARNING: Rule (condition -> condition OR condition) is never reduced
WARNING: Rule (arguments -> arguments COMMA expression) is never reduced
WARNING: Rule (array_elements -> array_elements COMMA expression) is never reduced
